<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阔落煮酒</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyin.top/"/>
  <updated>2019-11-18T15:49:32.976Z</updated>
  <id>http://chenyin.top/</id>
  
  <author>
    <name>Barwe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>requests</title>
    <link href="http://chenyin.top/spider/20191118-23bd.html"/>
    <id>http://chenyin.top/spider/20191118-23bd.html</id>
    <published>2019-11-18T15:42:00.000Z</published>
    <updated>2019-11-18T15:49:32.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/requests-post.png" alt=""></p><p>在python里面，<strong>requests包</strong>足够应付简单的爬虫需求，具有很强的用户友好性。一般情况下，我们只需要向服务器请求数据，此时使用<strong>GET请求</strong>，如果需要向服务器提交数据则使用<strong>POST请求</strong>。</p><a id="more"></a><h2 id="GET请求的基本格式"><a href="#GET请求的基本格式" class="headerlink" title="GET请求的基本格式"></a>GET请求的基本格式</h2><p>get请求通过 <code>requests.get(...)</code> 实现，正常情况下将返回一个<strong>requests.models.Response对象</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">"https://api.github.com/events"</span>)</span><br><span class="line">type(response) <span class="comment"># requests.models.Response</span></span><br></pre></td></tr></table></figure></p><h3 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h3><p>如果get访问的服务器需要参数需要在URL中加入参数，常见的方式有两种：</p><ol><li>直接构建带参数的URL字符串，通过<strong>问号</strong>分隔，例如 <code>http://xxx.com/?key=value</code></li><li>通过<strong>param参数</strong>传递URL参数，该参数接受一个<strong>字典</strong>，如 <code>response = requests.get(..., param = {&#39;k&#39;: &#39;v&#39;})</code><ol><li>可以是简单的字典，如 <code>{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}</code>构造出的参数字符串为 <code>?key1=value1&amp;key2=value2</code></li><li>可以有多个值，如 <code>{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: [&quot;key21&quot;, &quot;key22&quot;]}</code>构造出的参数字符串为<code>?key1=value1&amp;key2=value21&amp;key2=value22</code> </li><li>可以是空值，此时会忽略这个参数，如 <code>{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: None}</code>构造出的参数字符串为 <code>?key1=value1</code></li></ol></li></ol><h3 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h3><p>部分网站需要设置正确的<strong>用户代理</strong>（<code>User-Agent</code>）用来模仿真人使用浏览器的行为。用户代理信息存储在<strong>头部信息</strong>中，因此可以通过 <code>headers</code> 参数设定：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://www.zhihu.com"</span></span><br><span class="line">headers = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36"</span>&#125;</span><br><span class="line">response = requests.get(url, headers = headers)</span><br></pre></td></tr></table></figure></p><p>使用chrome可以通过访问 <code>chrome://version</code> 查询到<strong>用户代理</strong>信息。<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/01.png" alt=""></p><h3 id="超时请求"><a href="#超时请求" class="headerlink" title="超时请求"></a>超时请求</h3><p>客户端通过get请求服务器响应时需要等待时间，假设服务器突然傲娇，短时间不打算响应或者根本不打算回应你，如果此时没有一些约束条件客户端就会永远等下去，子子孙孙无穷尽矣。通过设置参数<code>timeout</code>（单位：秒）告诉客户端等待多长时间即可放弃等待。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">'...'</span>, timeout = <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>如果服务器在指定时间（秒）内没有做出应答，get将会抛出异常。</p><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p>每一个请求成功的 <code>requests.get(...)</code> 都会返回一个<strong>Response对象</strong>，它有一些基本属性：</p><ul><li><code>.url</code>：包含URL参数的字符串</li><li><code>.status_code</code>：状态码，<strong>int类型</strong></li><li><code>.headers</code>：头部信息</li><li><code>.cookies</code>：cookie信息</li><li><code>.encoding</code>：编码方式，如utf-8</li><li><code>.text</code> ：内容，<strong>str类型</strong>（python3）</li><li><code>.content</code>：内容，<strong>bytes类型</strong></li></ul><p>requests为每个<strong>HTTP状态码</strong>分配了相应的<strong>常量</strong>，这些状态码值存储在 <code>requests.codes</code> 中，例如200对应的常量是 <code>requests.codes.ok</code>。</p><blockquote><p>常见HTTP状态码对应的requests常量：<a href="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/doc/HTTPStatusCodeKeys.txt" target="_blank" rel="noopener">点此查看</a><br>常见的HTTP状态码：<a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">点此查看</a></p></blockquote><p>当访问 <code>.text</code> 时，requests会自动识别头部信息中的编码方式并解码文本，编码方式可以通过 <code>.encoding</code> 查看。<code>.text</code> 返回一个字符串类型（str）。相应的，<code>.content</code> 返回的是<strong>bytes类型</strong>的字节串。</p><p>对于普通的文本网页，<code>.text</code> 能够正确解码，但是对于那些<strong>二进制文件</strong>的URL，<code>.text</code> 并不能正确解析内容，如下：<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/02.png" alt=""><br>此时需要使用 <code>.content</code> 读取请求内容：<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/03.png" alt=""></p><h3 id="如果返回了json数据"><a href="#如果返回了json数据" class="headerlink" title="如果返回了json数据"></a>如果返回了json数据</h3><p><strong>get请求</strong>结果中如果有json数据需要进行解码，requests包中内置了json数据解码器用于处理服务器返回的json数据。但是<u>成功获取到了json数据并不意味着响应成功</u>，因为有些服务器即使没有正常相应，仍然会返回包含了例如错误状态码在内的信息。服务器正常响应请求也不一定会返回json数据，如：<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/04.png" alt=""></p><h3 id="如果返回了cookie数据"><a href="#如果返回了cookie数据" class="headerlink" title="如果返回了cookie数据"></a>如果返回了cookie数据</h3><p>get请求的结果如果包含了cookie，可以通过 <code>.cookies</code> 属性访问cookie内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> response.cookies.items(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/05.png" alt=""></p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>暂时用不上~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/11/requests-post.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在python里面，&lt;strong&gt;requests包&lt;/strong&gt;足够应付简单的爬虫需求，具有很强的用户友好性。一般情况下，我们只需要向服务器请求数据，此时使用&lt;strong&gt;GET请求&lt;/strong&gt;，如果需要向服务器提交数据则使用&lt;strong&gt;POST请求&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="spider" scheme="http://chenyin.top/categories/spider/"/>
    
    
  </entry>
  
  <entry>
    <title>R读取内容为空的文件报错怎么办？</title>
    <link href="http://chenyin.top/R/20191112-e00c.html"/>
    <id>http://chenyin.top/R/20191112-e00c.html</id>
    <published>2019-11-12T07:29:42.000Z</published>
    <updated>2019-11-12T07:37:08.372Z</updated>
    
    <content type="html"><![CDATA[<p>一般我们用R处理的多半都是表格文件，但是当文件内容为空时（准确的描述应该是没有有效的表格内容，这意味着可以有许多<code>#</code>注释的行），直接使用<code>read.table</code>函数读取文件会报错。</p><a id="more"></a><p>报错如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; read.table(<span class="string">'kws_included.txt'</span>, sep = <span class="string">','</span>, stringsAsFactors = <span class="literal">F</span>)</span><br><span class="line">Error <span class="keyword">in</span> read.table(<span class="string">"kws_included.txt"</span>, sep = <span class="string">","</span>, stringsAsFactors = <span class="literal">F</span>) : </span><br><span class="line">  输入中没有多出的行</span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><p>用<code>try(...)</code>函数捕获异常，只是R中的<code>try(...)</code>函数功能比较简单，但是用来判断一下语句执行是否报错还是没有什么问题的。用法如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = <span class="keyword">try</span>(read.table(<span class="string">'kws_included.txt'</span>, sep = <span class="string">','</span>, stringsAsFactors = <span class="literal">F</span>), silent = <span class="literal">T</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'try-error'</span> %<span class="keyword">in</span>% class(df)) <span class="keyword">...</span> <span class="comment"># 语句执行出错</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">...</span> <span class="comment"># 语句执行1正常</span></span><br></pre></td></tr></table></figure><p><strong>其他解决办法</strong>：</p><p>未知~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般我们用R处理的多半都是表格文件，但是当文件内容为空时（准确的描述应该是没有有效的表格内容，这意味着可以有许多&lt;code&gt;#&lt;/code&gt;注释的行），直接使用&lt;code&gt;read.table&lt;/code&gt;函数读取文件会报错。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>使用parallel包的apply并行计算函数</title>
    <link href="http://chenyin.top/R/20191112-d180.html"/>
    <id>http://chenyin.top/R/20191112-d180.html</id>
    <published>2019-11-12T07:24:12.000Z</published>
    <updated>2019-11-12T07:26:07.622Z</updated>
    
    <content type="html"><![CDATA[<p><code>apply</code>系列的函数（例如常见的<code>lapply</code>, <code>sapply</code>）都是可以并行计算的，这在计算单位数较多且每个计算单位非常耗时时，能大大加快计算速度。这里简单记录内建的<code>parallel</code>包如何进行并行计算。</p><a id="more"></a><p><strong>1. 加载R包</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(parallel)</span><br></pre></td></tr></table></figure><p><strong>2. 查看当前节点可用CPU数，确定任务所需CPU数</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detectCores()</span><br></pre></td></tr></table></figure><p><strong>3. 指定任务所需CPU数，初始化资源调度器</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里假设调度10核</span></span><br><span class="line">mkc = makeCluster(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>4. 运行主程序</strong></p><p>并行运算的<code>apply</code>家族的函数与原函数都是一一对应的，如</p><ul><li><code>apply</code> $\to$ <code>parApply</code></li><li><code>lapply</code> $\to$ <code>parLapply</code></li><li><code>sapply</code> $\to$ <code>parSapply</code></li></ul><p>代码示例如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xs = parLapply(mkc, xs, func()&#123;<span class="keyword">...</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>注意，<code>func(){...}</code>中的所有第三方包都需要在函数内导入，因为<code>parLapply</code>会启动R的额外进程，在新的进程里面不会自动导入当前环境中已经导入的第三方包。</p><p><strong>4. 关闭资源调度器</strong></p><p>结束并行运算后一定要关闭资源调度器<code>mkc</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopCluster(mkc)</span><br></pre></td></tr></table></figure><p>不然<code>top</code>之后你会发现自己刷屏了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;apply&lt;/code&gt;系列的函数（例如常见的&lt;code&gt;lapply&lt;/code&gt;, &lt;code&gt;sapply&lt;/code&gt;）都是可以并行计算的，这在计算单位数较多且每个计算单位非常耗时时，能大大加快计算速度。这里简单记录内建的&lt;code&gt;parallel&lt;/code&gt;包如何进行并行计算。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>从因变量类型对回归分类</title>
    <link href="http://chenyin.top/stat/20191017-ca7e.html"/>
    <id>http://chenyin.top/stat/20191017-ca7e.html</id>
    <published>2019-10-16T16:26:37.000Z</published>
    <updated>2019-10-16T16:30:30.892Z</updated>
    
    <content type="html"><![CDATA[<p>假设自变量是$X$，因变量是$Y$。按照$Y$的数据类型将回归分为以下几种：</p><a id="more"></a><p><strong>(一) $Y$是数值资料</strong></p><ol><li><p>$Y$是连续数据：普通线性回归</p></li><li><p>$Y$是计数数据：计数回归</p><ul><li>泊松回归</li><li>负二项回归</li><li>零膨胀泊松回归等</li></ul></li></ol><blockquote><p><strong>计数数据</strong>：对某些对象计数的数据，取值为自然数</p></blockquote><ol start="3"><li>$Y$是生存数据：生存回归</li></ol><blockquote><p><strong>生存数据</strong>：生存数据表征了对象从”出生”到”死亡”的<strong>生存时间</strong>，本质上还是一个连续型数据。但是当我们进行分析时对象往往还未”死亡”，我们不能获得准确的生存时间，但是我们能获得该对象的最小生存时间（即到记录数据为止时的生存时间），记录数据时以”60d+”这种形式表示，意味着该对象的最小生存时间为60天。有趣的是，如果我们能获得所有样本的准确生存时间，生存回归本质上就是普通线性回归。</p></blockquote><p><strong>(二) $Y$是分类资料</strong></p><ol><li><p>$Y$是二值数据：0-1回归</p><ul><li>Logistic Regression</li><li>Probit Regression</li></ul></li><li><p>$Y$是定序数据：定序回归</p></li></ol><blockquote><p><strong>定序数据</strong>：数值无意义（意味着不能进行代数运算），但是顺序很重要</p></blockquote><hr><p>注：本文只是简单总结记录方便查阅，<a href="https://cosx.org/2016/06/five-useful-regression-models/" target="_blank" rel="noopener">欲览全文，查看此处</a>，尊重原创！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设自变量是$X$，因变量是$Y$。按照$Y$的数据类型将回归分为以下几种：&lt;/p&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
  </entry>
  
  <entry>
    <title>编写bash脚本时怎么方便的测试代码</title>
    <link href="http://chenyin.top/os/20190928-1314.html"/>
    <id>http://chenyin.top/os/20190928-1314.html</id>
    <published>2019-09-28T03:01:25.000Z</published>
    <updated>2019-09-28T03:02:18.596Z</updated>
    
    <content type="html"><![CDATA[<p>编写bash脚本时怎么方便的测试代码？</p><a id="more"></a><p><code>Esc Shift :/; wq</code> 太麻烦了</p><p>当然前提是能频繁测试的代码</p><p>解决办法：开两个窗口，一个vim编辑并保存，一个通过<code>watch -n 2 &quot;sh test.sh ...&quot;</code>频繁刷新执行test.sh</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写bash脚本时怎么方便的测试代码？&lt;/p&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>screen-SSH终端离线持久化工具</title>
    <link href="http://chenyin.top/os/20190911-89a2.html"/>
    <id>http://chenyin.top/os/20190911-89a2.html</id>
    <published>2019-09-11T03:03:26.000Z</published>
    <updated>2019-11-08T08:43:11.960Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们使用自己的电脑远程连接服务器（例如SSH）进行工作，某些任务我们希望放在<strong>前台</strong>运行但是其运行时间可能很长，如果程序运行期间我们需要断开连接，一般情况下这个前台任务也会随之中断。例如R交互式环境中的程序。screen工具就是为了解决这样一个问题。</p><a id="more"></a><p>screen工具不仅可以保证在断开远程连接的情况下继续运行当前任务，还可以实现单个<strong>实际窗口</strong>中操纵多个<strong>工作窗口</strong>。简单来说，新建一个<strong>screen会话</strong>会创建一个主进程，这个主进程对应着一个会话窗口。这个主进程是存储在服务器上的，它不受我们连接服务器的SSH进程的影响，因此当我们断开SSH连接时这个进程依旧存在，在下次重新连接服务器时依然可以恢复。而我们连接服务器时的工作环境中的任务实际上受SSH连接进程的影响，当我们断开连接时相关联的任务自然而然也就停止了。（PS: 下面提到的<strong>会话</strong>就是指一个虚拟窗口）</p><p>screen的用法如下：</p><ul><li><strong>怎么查询当前服务器中建立了哪些会话？</strong> <code>screen -ls</code> 即可</li><li><strong>怎么建立一个会话？</strong> <code>screen -S &lt;SOCKNAME&gt;</code> 可以建立一个虚拟会话，查看会话信息如下：<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/09/01.png" alt="screen_info_1"><br>由上可知，一个虚拟窗口的ID标识由<strong>进程号PID</strong>和<strong>会话名（SOCKNAME）</strong>组成，我们可以通过这两个信息恢复会话。除了 <code>screen -s ...</code> 之外，<code>screen -R ...</code> 也能建立一个新的虚拟窗口，与<code>-S</code>不同的是，<code>-R</code>是去尝试着恢复一个已有的会话，如果在已有会话中没有找到，他就会建立一个新的会话，跟“若目录不存在则创建目录”是一个意思。</li><li><strong>怎么恢复一个会话？</strong> <code>screen -r ...</code>可以恢复一个会话，当会话不存在时会报错；<code>screen -R ...</code>也能恢复一个会话，但是当会话不存在时会创建一个新的会话。注意：同一时间一个会话只能在一个实际窗口中打开（例如你可能会在不同的电脑上连接服务器或者在一台电脑上打开多个SSH会话）。当会话被挂起时（意味着此时没有窗口打开这个会话），会话信息中每个ID后面会标识出<code>(Detached)</code>，此时意味着你可以在当前窗口中打开这个会话继续工作；如果标识的是<code>(Attached)</code>，那么标识这个虚拟窗口已经在其它的地方被打开了，你将不能打开这个会话。如果你确定这属于异常情况，你可以使用<code>screen -d ...</code>强制挂起一个会话，此时状态会变成<code>(Detached)</code>，这表示你单方面终止了在某个未知地方打开的虚拟窗口。<br><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/09/02.png" alt="screen_info_2"><br>screen对你命令传入的会话名与会话ID进行匹配，例如你可以：<ul><li>只指定进程号PID，例如<code>screen -r 23288</code></li><li>在不引起歧义的情况下只指定会话名的首字母或前几个字母，例如<code>screen -r n</code>将恢复<code>23288.net</code></li><li>当然你也可以传入完整的<code>&lt;SOCKNAME&gt;</code>或者<code>&lt;PID&gt;.&lt;SOCKNAME&gt;</code></li></ul></li><li><strong>怎么退出并挂起当前会话？</strong> 依次摁下<code>Ctrl A D</code>三个键即可退出并挂起当前会话</li><li><strong>怎么挂起当前窗口中创建的指定会话？</strong>上面已经提到了，<code>screen -d ...</code>可强制挂起指定会话</li><li><strong>怎么删除一个会话？</strong>请确认你的虚拟窗口完成使命后再删除它，不然追悔莫及。<ul><li>直接<code>kill &lt;PID&gt;</code>可删除相应的会话</li><li>摁下<code>Ctrl A K D</code>可删除当前会话中的所有任务并退出当前会话</li></ul></li></ul><p>总结一下，screen常用的命令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br><span class="line">screen -r</span><br><span class="line">screen -R</span><br><span class="line">screen -S</span><br><span class="line">screen -d</span><br><span class="line">Ctrl + A + D 组合键</span><br><span class="line">Ctrl + A + K + D 组合键</span><br><span class="line">kill &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>下面是我设置的alias（使用极其频繁，根据奥卡姆剃刀原则，越频繁越简洁）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> sr=<span class="string">"screen -r"</span></span><br><span class="line"><span class="built_in">alias</span> sl=<span class="string">"screen -ls"</span></span><br><span class="line"><span class="comment"># 还可以设置几个快捷窗口</span></span><br><span class="line"><span class="built_in">alias</span> srq=<span class="string">'sr q'</span></span><br><span class="line"><span class="built_in">alias</span> srr=<span class="string">'sr r'</span></span><br></pre></td></tr></table></figure><p>其它命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 重命名已经存在的会话名称</span></span><br><span class="line">screen -S &lt;OLDNAME&gt; -X sessionname &lt;NEWNAME&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们使用自己的电脑远程连接服务器（例如SSH）进行工作，某些任务我们希望放在&lt;strong&gt;前台&lt;/strong&gt;运行但是其运行时间可能很长，如果程序运行期间我们需要断开连接，一般情况下这个前台任务也会随之中断。例如R交互式环境中的程序。screen工具就是为了解决这样一个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
      <category term="Linux实用命令" scheme="http://chenyin.top/tags/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++中与号和星号的再理解</title>
    <link href="http://chenyin.top/C/20190713-1536.html"/>
    <id>http://chenyin.top/C/20190713-1536.html</id>
    <published>2019-07-13T07:36:39.000Z</published>
    <updated>2019-09-15T02:40:27.026Z</updated>
    
    <content type="html"><![CDATA[<p>大学初识<strong>指针</strong>和<strong>引用</strong>，一知半解。最近想重新学习C++，发现自己对指针和引用的了解透彻了许多，遂记之以温习。</p><a id="more"></a><p><code>&amp;</code>和<code>*</code>实际上各有两种含义：出现在<strong>定义</strong>中时，作为<strong>运算符</strong>时</p><ul><li><code>&amp;</code>用于定义往往只在函数形参中使用，表示<strong>引用</strong>，如<code>void func (int&amp; x, int&amp; y) ...</code></li><li><code>&amp;</code>作为运算符表示<strong>取地址</strong>操作，例如<code>int* p = &amp;x</code></li><li><code>*</code>用于定义中时表示定义一个指针型变量，例如<code>int* p</code>或者<code>int *p</code></li><li><code>*</code>作为运算符时表示<strong>间接取值</strong>，即通过地址间接而不是通过变量名直接获取值，如<code>(*p)++</code></li></ul><h1 id="作为运算符"><a href="#作为运算符" class="headerlink" title="作为运算符"></a>作为运算符</h1><p><code>&amp;</code>和<code>*</code>分别称之为<strong>取地址运算符</strong>和<strong>间接取值运算符</strong>。</p><p><code>&amp;</code>是一个<strong>一元运算符</strong>，是一个<strong>运算符</strong>，它的作用是取出<strong>变量的地址</strong>，取出的是<strong>地址</strong>，地址的类型会带上<code>*</code> ，例如<code>int</code>型的变量<code>x</code>的地址（例如<code>0x61fe44</code>）的<strong>值</strong>的类型就是<code>int*</code>，这个值不能被保存到<code>int</code>类型中（因为<code>int</code>和<code>int*</code>是两种不同的数据类型），那么这个地址值怎么保存呢？这里定义了<strong>指针</strong>类型用于保存地址的值。上面例子中我们可以定义<strong>int指针类型</strong>用于保存int类型的变量的地址（通过<code>&amp;</code>获取），即<code>int *p = &amp;x</code>。其实<code>int *p</code>这种写法容易引起误解，<code>int* p</code>就明显一点，但是前者似乎更通用。上面的定义已经表明了：<code>p</code> 是一个<code>int*</code>类型（即int指针类型）,它保存的是变量<code>x</code>的内存地址，因此可以直接通过<strong>指针</strong>访问变量<code>x</code>存储的值，方法是<code>*p</code>，所以实际上<code>*p</code>和<code>x</code>都能访问到相应地址块上的值，这里<code>*</code>使得我们可以间接通过地址<code>p</code>访问值，所以叫<strong>间接寻址运算符</strong>。这里注意体会<code>int*</code>中的<code>*</code>和<code>*p</code>中的<code>*</code>意义是不完全相同的：前者表明这是变量（<code>p</code>）是一个指针型变量，后者是一种运算符，所谓<strong>运算</strong>，就从一个状态出发得到新的状态，这里就是指从<strong>地址</strong>出发计算得到了<strong>值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">// 写作 int* p可能更好理解点</span></span><br><span class="line">p = &amp;x; <span class="comment">// 这两步可以直接写作 int *p = &amp;x，写成 int* p = &amp;x 可能更加容易理解</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p; <span class="comment">// 类似于 0x61fe44 这样的表示地址的值，其类型为 int*</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">// 1000，对地址进行*运算得到值</span></span><br></pre></td></tr></table></figure><h1 id="用于参数定义"><a href="#用于参数定义" class="headerlink" title="用于参数定义"></a>用于参数定义</h1><p><code>*</code>用于参数定义时表示定义一个指针型变量，这十分容易理解。</p><p>那么<code>&amp;</code>用于参数定义时表示什么意思呢？<strong>引用</strong>！</p><p>下面以常见的三种函数参数传递方式为例说说<strong>引用</strong>的用法。</p><p><strong>参数传递</strong>有三种常见方式：值传递、指针传递、引用传递</p><p>不得不说时隔这么多年，我总算理解了三种参数传递的方式的基本区别，真笨。</p><p>假设我们现在需要对一个整型变量<code>x</code>进行加1操作，三种参数传递的解决方案如下：</p><ol><li><p><strong>值传递</strong>：值传递即按照普通方式定义形参，此时会对变量进行复制，以保证函数内部不会修改实参的任何信息，这样的参数传递方式当然不能直接修改实参的值，它返回的实际上是一块新的内存区域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> ++v;&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = f(x);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针传递</strong>：指针传递实际上传递的不是变量名称，而是变量指向的内存区域，这个区域怎么表示呢？当然用一个地址来表示啦。这个地址怎么获取呢？当然是用 <strong>取地址运算符&amp;</strong> 啦。对于指针传递来说，形参定义为一个<strong>指针型</strong>变量，而实参也是一个指针型变量（地址），所以指针传递将会直接修改原内存块的值，这导致函数执行后我们再通过相同的方式取访问变量（实际上是访问变量指向的内存块的值），它的值已经发生了改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addone</span> <span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;(*p)++;&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 1</span></span><br><span class="line">addone(&amp;x);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>引用传递</strong>：指针传递实际上并不优雅，它直接让程序接触到了内存地址。与其如此，我们为什么不直接定义一个类似于<strong>值传递</strong>中的但是又不用对实参进行复制的形参呢？这个形参本质上还是一个<strong>非指针数据类型</strong>，但是它能直接修改实参的值，就相当于给实参定义了一个<strong>别名</strong>，不论通过实参本身修改值还是通过这个别名修改值都是等价的。这种方式称之为<strong>引用</strong>，通过<code>&amp;</code>实现，<code>&amp;</code>作为<strong>引用</strong>含义时常常出现在函数形参中（<code>&amp;</code>还可作为<strong>运算符</strong>使用），它表示形参实际上是实参的一个别名，对形参的任何修改都将等价于对实参的修改，例如形参<code>int&amp; x</code>定义的就是对某个整形实参的<strong>引用</strong>，此时传递的实参也不需要像<strong>指针传递</strong>那样需要先获取地址，程序本身规避了对地址进行直接操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addone</span> <span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;++v;&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 1</span></span><br><span class="line">addone(x);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p><code>*</code>和<code>&amp;</code>的其它高级用法以后遇到了再温习吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大学初识&lt;strong&gt;指针&lt;/strong&gt;和&lt;strong&gt;引用&lt;/strong&gt;，一知半解。最近想重新学习C++，发现自己对指针和引用的了解透彻了许多，遂记之以温习。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://chenyin.top/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux三个常见的压缩打包命令</title>
    <link href="http://chenyin.top/os/20190515-feae.html"/>
    <id>http://chenyin.top/os/20190515-feae.html</id>
    <published>2019-05-15T01:32:02.000Z</published>
    <updated>2019-09-15T02:52:16.040Z</updated>
    
    <content type="html"><![CDATA[<p>常见压缩文件扩展名</p><table><thead><tr><th style="text-align:center">扩展名</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">*.gz</td><td style="text-align:center">gzip压缩文件</td></tr><tr><td style="text-align:center">*.bz2</td><td style="text-align:center">bzip2压缩文件</td></tr><tr><td style="text-align:center">*.tar</td><td style="text-align:center">tar打包的文件，没有压缩</td></tr><tr><td style="text-align:center">*.tar.gz</td><td style="text-align:center">tar打包文件。经过gzip压缩</td></tr><tr><td style="text-align:center">*.tar.bz2</td><td style="text-align:center">tar打包文件，经过bzip2压缩</td></tr></tbody></table><a id="more"></a><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><p>压缩并<strong>删除</strong>本地文件：<code>gzip -v SOURCE</code></p><p>压缩但<strong>保留</strong>本地文件：<code>gzip -c SOURCE &gt; TARGET</code></p><p>解压缩：<code>gzip -d SOURCE</code></p><p>不解压缩但查看文件内容：<code>zcat SOURCE</code></p><h1 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h1><p>取代gzip，压缩比例高于gzip</p><p>压缩并<strong>删除</strong>本地文件：<code>bzip2 -zv SOURCE</code></p><p>压缩但<strong>保留</strong>本地文件：<code>bzip2 -kv SOURCE</code></p><p>解压缩：<code>bzip2 -d SOURCE</code></p><p>不解压缩但查看文件内容：<code>bzcat SOURCE</code></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>将（多个）文件打包（压缩）成一个文件</p><p>压缩 <code>-c</code>：</p><ul><li>创建bzip2压缩文件：<code>tar -jcvf TARGET.tar.bz2 SOURCE</code></li><li>创建gzip压缩文件：<code>tar -zcvf TARGET.tar.gz SOURCE</code></li></ul><p>不解压缩查看文件列表 <code>-t</code>：</p><ul><li><code>tar -jtvf SOUTCE.tar.bz2</code></li><li><code>tar -ztvf SOURCE.tar.gz</code></li></ul><p>解压缩 <code>-x</code>：</p><ul><li><code>tar -jxvf SOURCE.tar.bz2</code></li><li><code>tar -zxvf SOURCE.tar.gz</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见压缩文件扩展名&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;扩展名&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*.gz&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;gzip压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*.bz2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;bzip2压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*.tar&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;tar打包的文件，没有压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*.tar.gz&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;tar打包文件。经过gzip压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;*.tar.bz2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;tar打包文件，经过bzip2压缩&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
      <category term="Linux实用命令" scheme="http://chenyin.top/tags/Linux%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>markdown奇淫技巧</title>
    <link href="http://chenyin.top/cargo/20190514-71e.html"/>
    <id>http://chenyin.top/cargo/20190514-71e.html</id>
    <published>2019-05-14T03:13:16.000Z</published>
    <updated>2019-05-14T03:19:02.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原生表格中插入包含-的代码"><a href="#原生表格中插入包含-的代码" class="headerlink" title="原生表格中插入包含 | 的代码"></a>原生表格中插入包含 <code>|</code> 的代码</h1><p>由于markdown原生表格使用”|”分隔列，在表格中直接输入”|”会使表格结构解析错误。</p><p>下面这种写法可以使表格正常解析：</p><table><thead><tr><th style="text-align:center">样式</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center"><code>A &#124; B</code></td><td style="text-align:center"><code>&lt;code&gt;A &amp;#124; B&lt;/code&gt;</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原生表格中插入包含-的代码&quot;&gt;&lt;a href=&quot;#原生表格中插入包含-的代码&quot; class=&quot;headerlink&quot; title=&quot;原生表格中插入包含 | 的代码&quot;&gt;&lt;/a&gt;原生表格中插入包含 &lt;code&gt;|&lt;/code&gt; 的代码&lt;/h1&gt;&lt;p&gt;由于markdow
      
    
    </summary>
    
      <category term="cargo" scheme="http://chenyin.top/categories/cargo/"/>
    
    
  </entry>
  
  <entry>
    <title>R模型公式</title>
    <link href="http://chenyin.top/R/20190514-95ad.html"/>
    <id>http://chenyin.top/R/20190514-95ad.html</id>
    <published>2019-05-14T03:00:25.000Z</published>
    <updated>2019-05-14T03:10:26.650Z</updated>
    
    <content type="html"><![CDATA[<p>在进行 <strong>方差分析</strong>（ANOVA）或者 <strong>回归分析</strong> 时我们常常会遇到 <strong>~</strong> 操作符，这对R新手来说实在是难以理解，遂查查<a href="http://ww2.coastal.edu/kingw/statistics/R-tutorials/formulae.html" target="_blank" rel="noopener">文档</a>整理整理。<img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/05/tildeBig.jpg" alt=""></p><a id="more"></a><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aov(formula, data = <span class="literal">NULL</span>, projections = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, contrasts = <span class="literal">NULL</span>, <span class="keyword">...</span>)</span><br><span class="line"></span><br><span class="line">lm(formula, data, subset, weights, na.action, method = <span class="string">"qr"</span>, model = <span class="literal">TRUE</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">FALSE</span>, qr = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, contrasts = <span class="literal">NULL</span>, offset, <span class="keyword">...</span>)</span><br><span class="line"></span><br><span class="line">glm(formula, family = gaussian, data, weights, subset, na.action, start = <span class="literal">NULL</span>, etastart, mustart, offset, control = list(<span class="keyword">...</span>), model = <span class="literal">TRUE</span>, method = <span class="string">"glm.fit"</span>, x = <span class="literal">FALSE</span>, y = <span class="literal">TRUE</span>, singular.ok = <span class="literal">TRUE</span>, contrasts = <span class="literal">NULL</span>, <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure><p>R函数例如 <code>aov()</code>, <code>lm()</code>, <code>glm()</code> 都提供了 <code>formula</code> 参数供用户定义将要进行的分析中涉及到的变量（反应变量、解释变量）。这个 <code>formula</code> 参数直接决定了R构建和测试的模型结构。<code>formula</code> 参数的基本格式为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response_variable[反应变量] ~ explanatory_variables[解释变量]</span><br></pre></td></tr></table></figure><p>上式中的波浪号（tilde）可以理解为“通过……建模”或者“是……的函数”。</p><p>上式的技巧多在于，如何书写解释变量。</p><p>最基础的回归分析的 <code>formula</code> 参数格式如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y ~ x</span><br></pre></td></tr></table></figure><p>上式中的”x” 称之为 <strong>解释变量</strong>（Explanatory Variable）或者 <strong>自变量</strong>（Independent Variable, IV）,”y”称之为 <strong>反应变量</strong>（Response Variable）或者 <strong>因变量</strong>（Dependent Variable, DV）。</p><p>如果还有其它的解释变量添加到表达式后面即可。下式表示构建两变量的多回归模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y ~ x + z</span><br></pre></td></tr></table></figure><p>类似于上面的式子我们称之为 <strong>模型公式</strong>（Model Formula），它将传递给 <code>formula</code> 参数。</p><p>如何书写正确优雅的模型公式是一件很有意思的事情……</p><p>尤其注意，我们在其它地方使用的数学运算符（例如四则运算符）在模型公式里都有新的含义，也就是说我们不能像读一般数学公式那样去阅读模型公式。</p><p>下面这张表列出了模型公式中常用符号的意义，我们可以直观地感受到它们与一般意义地显著差别：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">例子</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center"><code>+ x</code></td><td style="text-align:center">包含了解释变量x</td></tr><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center"><code>- x</code></td><td style="text-align:center">删除解释变量x（没太理解）</td></tr><tr><td style="text-align:center"><code>:</code></td><td style="text-align:center"><code>x : z</code></td><td style="text-align:center">包含了解释变量x和z间的互作</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center"><code>x * z</code></td><td style="text-align:center">包含了解释变量x和z，以及它们之间的互作</td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center"><code>x / z</code></td><td style="text-align:center">嵌套：包含了嵌套在x中的z</td></tr><tr><td style="text-align:center"><code>&#124;</code></td><td style="text-align:center"><code>x &#124; z</code></td><td style="text-align:center">条件：包含了给定z时的x</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center"><code>(u + v + w + z) ^ 3</code></td><td style="text-align:center">包含了四个变量，以及它们之间最多三个变量间的互作</td></tr><tr><td style="text-align:center"><code>poly</code></td><td style="text-align:center"><code>poly(x, 3)</code></td><td style="text-align:center">多项式回归：正交多项式</td></tr><tr><td style="text-align:center"><code>Error</code></td><td style="text-align:center"><code>Error(a/b)</code></td><td style="text-align:center">指定误差项</td></tr><tr><td style="text-align:center"><code>I</code></td><td style="text-align:center"><code>I(x*z)</code></td><td style="text-align:center"><code>I()</code> 中的表达式保留一般的数学意义，表示包含了x乘以z这个新变量</td></tr><tr><td style="text-align:center"><code>1</code> (数字)</td><td style="text-align:center"><code>- 1</code></td><td style="text-align:center">截距：删除截距，即通过原点回归</td></tr></tbody></table><p>同一个模型可以通过不同的公式表达：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model 1</span></span><br><span class="line">y ~ u + v + w + u:v + u:w + v:w + u:v:w</span><br><span class="line">y ~ u * v * w</span><br><span class="line">y ~ (u + v + w)^<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model 2</span></span><br><span class="line">y ~ u + v + w + u:v + v:w + v:w</span><br><span class="line">y ~ u * v * w - u:v:w</span><br><span class="line">y ~ (u + v + w)^<span class="number">2</span></span><br></pre></td></tr></table></figure><p>解释变量的属性（例如二值变量、分类变量、数值变量……）决定了模型的特性，例如对公式 <code>y ~ x + z</code>：</p><ul><li>如果x和y是两个分类变量，该公式表示方差分析[?]</li><li>如果x和y是两个数值变量，该公式表示多回归[?]</li><li>如果一个是数值变量一个是分类变量，则表示相关性分析[?]</li></ul><p><strong>关于 <code>Error()</code> 的一点见解</strong></p><p>略</p><!-- url -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行 &lt;strong&gt;方差分析&lt;/strong&gt;（ANOVA）或者 &lt;strong&gt;回归分析&lt;/strong&gt; 时我们常常会遇到 &lt;strong&gt;~&lt;/strong&gt; 操作符，这对R新手来说实在是难以理解，遂查查&lt;a href=&quot;http://ww2.coastal.edu/kingw/statistics/R-tutorials/formulae.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;整理整理。&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/05/tildeBig.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>Basset：CNN学习新的染色体开放位点</title>
    <link href="http://chenyin.top/bioinfo/20190423-1702.html"/>
    <id>http://chenyin.top/bioinfo/20190423-1702.html</id>
    <published>2019-04-23T07:07:47.000Z</published>
    <updated>2019-04-23T07:37:11.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/25.jpg" alt=""></p><p>尝试着将神经网络的元件与生物学意义联系起来。大胆假设，小心求证！</p><p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4937568/" target="_blank" rel="noopener">PMC</a>   |  <a href="https://genome.cshlp.org/content/early/2016/05/03/gr.200535.115.abstract" target="_blank" rel="noopener">Genome Res.</a>  |  <a href="https://github.com/davek44/Basset" target="_blank" rel="noopener">GitHub</a></p><a id="more"></a><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从<a href="https://www.encodeproject.org/" target="_blank" rel="noopener">ENCODE Project Consortium</a>下载125种细胞类型的数据。<br>从<a href="http://www.roadmapepigenomics.org/" target="_blank" rel="noopener">Roadmap Epigenomics Consortium</a>下载39种细胞类型的数据。<br>数据形式为DNase-seq的peak信息，保存在<a href="https://vip.biotrainee.com/d/167-bed" target="_blank" rel="noopener">BED格式</a>的文件中。<br>使用未去重叠（overlap）的peak数据。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ol><li>以1%的FDR使用模拟方法修改原始数据集——robustness</li><li>归并重叠的peaks共 $2,071,886$ 个峰，比对到hg19参考基因组<ul><li><strong>标准输入</strong>为每个位点600bp的DNA序列长度</li><li><strong>标准标签</strong>为一个164维的二值向量，该向量表示这个峰（位点）在164种细胞类型中的开放情况（1为开放，0为不开放）</li></ul></li><li>将数据集切分为训练集、测试集和验证集<ul><li>training data：训练模型参数</li><li>testing data：计算序列特异性参数</li><li>validation data：用于early stopping</li></ul></li><li>应模型后续分析需要，使用GENOME v18 reference catalog将位点分为promoter（转录起始位点周围2kb区域）、intragenic（与基因区域发生重叠）、intergenic（位于基因间区域内）三类</li></ol><hr><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>训练模型和测试模型的用途有细微差别。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练模型是一个3CNN+2FC的简单神经网络，此项目的亮点不在神经网络的设计，而在于将神经网络的元件与生物学意义结合起来，这也是以往项目中我所想不透的地方。训练网络如下：<img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/22.jpg" alt=""></p><p>模型的输入是一个one-hot编码的 $4 \times 600$ 的序列（与处理中已经将所有位点的序列长度截取到了600bp）。</p><p>the first CNN是本模型的重点，它包括了一个卷积层、一个激活层和一个池化层。</p><p>卷积层使用的是300个 $4 \times M$ 的一维卷积核（filter，滤波器），其中 $M$ 长度跟motif长度相当（这里取19b）。作者在这里给每个filter赋予了生命力，认为它们不仅是一种网络元件。因为<u>每个卷积核是基于所有序列优化得来的</u>，所以我们认为卷积核代表了所有序列共有的一种信息，即模式。这是符合思考逻辑的。</p><p>简而言之，每个卷积核可能代表了一种motif，这个motif具体的生物学意义未知。此项目试图从蛋白质结合motif出发去验证卷积核中是否存在相应的结构与之对应。<img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/23.jpg" alt=""></p><p>这是一种不错的假设-验证思想。</p><p>模型的最后一层也就是第二个全连接层的输出是164个节点，分别代表了该600bp的序列在164种类型细胞种的开放情况。参考标准标签计算binary loss进行参数优化。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试阶段作者做了很有意思的事情。</p><p>为了计算卷积核（motif）对（预测的）开放性打分结果的影响程度，将第一CNN的输出结果（每个卷积核会将 $4 \times 600$ 的序列转化为（600-19+1）维的向量）全部用其平均值替换，这将消除卷积核的特异性影响。用替换结果进行后续计算，将计算结果与未经替换的预测结果进行比较。计算差异的平方和，这个值作为该卷积核的influence值。</p><p>IC（Information Content）值得原文计算方法如下：<br>$$<br>\mathrm{IC} = \sum_{i,j}{m_{ij}\log_2 m_{ij}} - \sum_{i,j}{ b_j \log_{2}b_{j}}<br>$$<br>写成这样似乎更清楚点：<br>$$<br>\mathrm{IC} = \sum_{i=1}^{19} \sum_{j=1}^4 m_i^{(j)} \log_2 m_i^{(j)} - 19\sum_{j=1}^4 b^{(j)} \log_2 b^{(j)}<br>$$</p><p>其中向量 $b$ 是四个碱基分布的背景值，向量 $m\;(4 \times 19)$ 是motif各个位置的碱基概率分布，等效于一个卷积核。</p><p>有趣的是，除了对卷积核进行上述操作计算IC值influence值，作者还直接从数据库中（CIS-BP数据库）下载已知的蛋白质motif代替卷积核进行计算，最后一同进行比较分析。<img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/24.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/25.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;尝试着将神经网络的元件与生物学意义联系起来。大胆假设，小心求证！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4937568/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PMC&lt;/a&gt;   |  &lt;a href=&quot;https://genome.cshlp.org/content/early/2016/05/03/gr.200535.115.abstract&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Genome Res.&lt;/a&gt;  |  &lt;a href=&quot;https://github.com/davek44/Basset&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="bioinfo" scheme="http://chenyin.top/categories/bioinfo/"/>
    
    
      <category term="深度学习" scheme="http://chenyin.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="卷积神经网络" scheme="http://chenyin.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="基因组开放位点" scheme="http://chenyin.top/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%BC%80%E6%94%BE%E4%BD%8D%E7%82%B9/"/>
    
      <category term="paper" scheme="http://chenyin.top/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>采样5 - M-H采样解决接受率α过小的问题</title>
    <link href="http://chenyin.top/stat/20190422-551c.html"/>
    <id>http://chenyin.top/stat/20190422-551c.html</id>
    <published>2019-04-22T02:06:51.000Z</published>
    <updated>2019-04-22T03:13:44.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>M-H采样</strong> 是 <strong>Metropolis-Hastings采样</strong> 的简称，这个算法首先由Metropolis提出，被Hastings改进，因此被称之为Metropolis-Hastings采样或M-H采样。</p><p>M-H采样解决了<a href="/stat/20190417-ea8c.html">原始MCMC采样</a>中接受率过小的问题。</p><a id="more"></a><p>对于细致平稳条件<br>$$<br>\pi_i Q_{ij} \alpha_{ij} = \pi_j Q_{ji} \alpha_{ji}<br>$$<br>既然 $\alpha_{ij}​$ 太小，我们就把它扩大到1，多么简单粗暴：<br>$$<br>\alpha(i, j)=\min \left \lbrace \frac{\pi(j) Q(j, i)}{\pi(i) Q(i, j)},\; 1 \right \rbrace<br>$$<br>M-H采样过程如下：</p><ol><li>已知平稳分布 $\pi(x)​$，预设状态转移次数阈值 $n​$ 和采样样本数 $m​$，选定任意的某个马氏链对应的状态转移矩阵 $Q(i,\;j)​$</li><li>从任意简单概率采样得 $x_0$</li><li>从 $t=1$ 到 $t=n+m-1$ 循环采样：<ol><li>从 $q(x|x_{t-1})$ 中采样得到状态 $\ast$ 的采样值 $x^\ast$</li><li>从均匀分布中采样得到 $u \sim uniform(0,\;1)$</li><li>如果 $u \lt \alpha(t-1,\;\ast)=\min \left \lbrace \frac{\pi(\ast) Q(\ast, \;t-1)}{\pi(t-1) Q(t-1,\;\ast)},\; 1 \right \rbrace$ ，则接受采样值 $x^\ast$，这意味着我们接受了状态 $t-1$ 到状态 $\ast$ 的转移，即 $x_t=x^\ast$；否则拒绝转移，即 $x_t=x_{t-1}$</li></ol></li><li>$\left \lbrace x_n,\; x_{n+1},\; \cdots,\; x_{n+m-1} \right \rbrace$ 即为平稳分布对应的采样集</li></ol><p>一般强化先验知识有助于简化计算。如果我们预设的 $Q​$ 是对称矩阵，即 $Q(i,\;j)=Q(j,\;i)​$，那么此时 $\alpha​$ 可以简化为<br>$$<br>\alpha(i,\;j) = \min \left \lbrace \frac{\pi_j}{\pi_i},\; 1 \right \rbrace<br>$$<br>尽管M-H采样解决了[原始MCMMC采样][]过小的问题，它还是有很多缺陷，特别是在特征维度很大时：</p><ol><li>接受概率 $\alpha$ 难以计算，或进行了许多的无用计算（拒绝采样）；</li><li>联合分布难以计算，相比之下条件概率分布计算更容易</li></ol><p><a href="/stat/20190422-dcdd.html">Gibbs采样</a>解决了上面的问题。</p><!-- URL -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;M-H采样&lt;/strong&gt; 是 &lt;strong&gt;Metropolis-Hastings采样&lt;/strong&gt; 的简称，这个算法首先由Metropolis提出，被Hastings改进，因此被称之为Metropolis-Hastings采样或M-H采样。&lt;/p&gt;
&lt;p&gt;M-H采样解决了&lt;a href=&quot;/stat/20190417-ea8c.html&quot;&gt;原始MCMC采样&lt;/a&gt;中接受率过小的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
  </entry>
  
  <entry>
    <title>采样4 - 细致平稳条件和MCMC采样</title>
    <link href="http://chenyin.top/stat/20190417-ea8c.html"/>
    <id>http://chenyin.top/stat/20190417-ea8c.html</id>
    <published>2019-04-17T03:07:54.000Z</published>
    <updated>2019-07-09T01:07:01.007Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/07/01.jpg" alt=""><br><a id="more"></a></p><h1 id="细致平稳条件"><a href="#细致平稳条件" class="headerlink" title="细致平稳条件"></a>细致平稳条件</h1><p><strong>&gt; 细致平稳条件（Detailed Banlance Condition）</strong></p><p>当一个系统微观上达到平衡时满足 <strong>细致平稳条件</strong>：$\pi_i​$ 表示系统处于状态 $i​$ 的概率，$P_{i{\to}j}​$ 表示系统从状态 $i​$ 转移到状态 $j​$ 的概率，一个反应（转移）应该与它的逆反应（逆转移）达到平衡，即<br>$$<br>\pi_i P_{i \to j} = \pi_j P_{j \to i} \tag{1}<br>$$<br><a href="https://en.wikipedia.org/wiki/Detailed_balance" target="_blank" rel="noopener">细致平稳条件</a> 是 Ludwig Boltzmann 于1872年提出来的。</p><p><strong>&gt; 马尔可夫链具有平稳分布的充分条件</strong></p><p>假设马尔可夫链的状态分布为 $\pi$，状态转移矩阵为 $P$，如果存在某一个时间节点使得对于任意的状态 $i$ 和 $j$ 有<br>$$<br>\pi_i P_{ij} = \pi_j P_{ji} \tag{2}<br>$$<br>上述细致平稳条件成立，则该马尔可夫链具有<strong>平稳分布</strong> $\pi$（Stationary Distribution）。</p><p>细致平稳条件是马氏链收敛的充分条件，而不是必要条件。</p><blockquote><p>充分性证明：</p><p>因为 $\sum_i \pi_i P_{ij} = \sum_i \pi_j P_{ji} = \pi_j \sum_i P_{ji} = \pi_j$</p><p>所以 $ \sum_i \pi_i P_{ij} = \pi P = \pi $</p></blockquote><p>仅在二状态系统下，细致平稳条件也是马氏链收敛的必要条件，即充要条件。</p><p><strong>&gt; 从目标平稳分布 $\pi(x)$ 出发寻找转移矩阵 $P$</strong></p><p>假设目标平稳分布 $\pi(x)$ 已知，根据细致平稳条件，我们只需要确定一个矩阵 $P$ 作为相应的状态转移概率矩阵，就能确定这样一个马尔可夫链：转移矩阵为 $P$，平稳分布为 $\pi(x)$。</p><p>但是，矩阵 $P$ 的确定并不是一件很容易的事情，MCMC采样算法很巧妙的解决了这个问题。</p><h1 id="MCMC采样"><a href="#MCMC采样" class="headerlink" title="MCMC采样"></a>MCMC采样</h1><p><strong>&gt; 马尔可夫蒙特卡洛采样（Markov Chain Monte Carlo，MCMC）的基本思想</strong></p><p>我们随机确定一个马尔可夫链的状态转移矩阵 $Q$，它并不满足细致平衡条件，即<br>$$<br>\pi_i Q_{ij} \ne \pi_j Q_{ji} \tag{3}<br>$$<br>为了使等式成立，引入非零 $\alpha_{ij}$ 项，即<br>$$<br>\pi_i Q_{ij} \alpha_{ij} = \pi_j Q_{ji} \alpha_{ji} \tag{4}<br>$$<br>取<br>$$<br>\begin{cases}<br>\alpha_{ij} &amp;= \pi_j Q_{ji} \<br>\alpha_{ji} &amp;= \pi_i Q_{ij}<br>\end{cases} \tag{5}<br>$$<br>此时目标平稳分布 $\pi(x)$ 对应的马氏链的状态转移概率矩阵 $P$ 可表示为<br>$$<br>P_{ij} = Q_{ij} \alpha_{ij} \tag{6}<br>$$<br>由(5)式可知，$0 \le \alpha_{ij}^{(k)} \le 1$，对于特定的 $Q_{ij}$，$\alpha_{ij}$ 越小，则相应的 $P_{ij}$ 越小：这可以解释为 $\alpha_{ij}$ 是对 $Q_{ij}$ 的接受率，目标状态转移矩阵 $P$ 可以通过任意一个马尔可夫链的状态转移矩阵 $Q$ 以一定概率 $\alpha$ 接受获得。</p><p><strong>&gt; MCMC采样算法过程</strong></p><blockquote><ol><li>初始化状态分布 $\pi_0$ 并采样 $x_0$</li><li>循环采样直到获得 $m$ 个样本：<ol><li>$t$ 时刻马氏链的状态分布为 $\pi_t$（未知，我们也不关系纯向量的值），从 $Q(x|x_t)$ 采样得样本 $x^*$</li><li>从均匀分布中采样 $u \sim uniform(0,\;1)​$</li><li>如果 $u &lt; \alpha_{x_t \to x^<em>} = \pi_(x^</em>)Q(x^<em>,\;x_t)$ 则接受转移 $x_t \to x^</em>$，即 $x_{t+1}=x^*$；否则不接受转移，即 $x_{t+1}=x_t$</li><li>舍弃第 $0$ 到第 $n-1$ 共 $n$ 个样本，保留第 $n$ 到第 $n+m-1$ 共 $m$ 个样本作为采样样本 </li></ol></li></ol></blockquote><p>上面的 $\alpha_{ij}$ 实际上很小，这导致大部分采样都会被拒绝，这意味着我们的 $n$ 要预设的非常大。</p><p>基于这个困境，<strong>M-H采样</strong> 对 <strong>MCMC采样</strong> 进行了优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/07/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
      <category term="采样" scheme="http://chenyin.top/tags/%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>采样3 - 离散马尔可夫链采样</title>
    <link href="http://chenyin.top/stat/20190416-1f84.html"/>
    <id>http://chenyin.top/stat/20190416-1f84.html</id>
    <published>2019-04-16T08:03:14.000Z</published>
    <updated>2019-04-17T05:45:25.680Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们的目标分布是<strong>简单</strong>、<strong>离散</strong>的分布，这个目标分布可以当作某个马尔可夫链的<strong>平稳分布</strong>，这个平稳分布对应着一个<strong>状态转移矩阵</strong>。如果这个状态转移矩阵已知，我们就可以十分容易的得到目标分布的采样集。</p><p>离散马尔可夫链采样只是理论基础，实用价值不大。</p><a id="more"></a><h1 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h1><p>下面直接以例子说明采样过程：</p><p>假设一个质量分布不均匀的六面骰子掷出六个点数的概率服从一个简单、离散的概率分布，记为 $\pi(x)$，$x=\lbrace 1\;2\;3\;4\;5\;6 \rbrace$。</p><p>$\pi(x)$ 可以通过大量独立重复实验用频率进行估计，如果知道了状态转移矩阵 $P$ 就可以很容易的进行采样。</p><p>先假设转移概率矩阵 $P$ 已知，这里模拟一个状态转移矩阵作为示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">36</span>).reshape([<span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">p = p/p.sum(axis=<span class="number">1</span>).reshape([<span class="number">-1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>$$<br>p = \left[\begin{matrix}<br>0.18206229 &amp; 0.1764297  &amp; 0.23015706 &amp; 0.13247823 &amp; 0.23143627 &amp;0.04743645 \\<br>0.03751516 &amp; 0.33564335 &amp; 0.39400589 &amp; 0.12847041 &amp; 0.07526389 &amp;0.0291013  \\<br>0.12921795 &amp; 0.25957537 &amp; 0.01825006 &amp; 0.32088546 &amp; 0.26899888 &amp;0.00307228 \\<br>0.22883623 &amp; 0.07873173 &amp; 0.23422034 &amp; 0.23744235 &amp; 0.08045652 &amp;0.14031283 \\<br>0.14770889 &amp; 0.20742323 &amp; 0.19634175 &amp; 0.07048638 &amp; 0.16482596 &amp;0.21321379 \\<br>0.07080479 &amp; 0.24460837 &amp; 0.22450135 &amp; 0.21595409 &amp; 0.11542076 &amp;0.12871064<br>\end{matrix}\right]<br>$$<br><strong>&gt; 1. 指定初始分布</strong></p><p>因为马尔可夫链的平稳分布只与状态转移矩阵相关，而与初始状态分布无关。</p><p>所以我们可以从一个从任意初始化状态分布出发进行采样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">6</span>)</span><br><span class="line">pi = pi / pi.sum()</span><br></pre></td></tr></table></figure><p>$$<br>\pi_0 = [0.22081522,0.11290264,0.23593329,0.0524546,0.1917839,0.18610888]<br>$$</p><p><strong>&gt; 2. 指定记录采样值时的状态转移次数 $n$ 和需要记录的采样数 $m$</strong></p><p>整个采样过程中需要进行的状态转移次数为<br>$$<br>N= n+m-1<br>$$<br>将要记录下的采样值集合为<br>$$<br>X = \lbrace \underbrace{x_n,\;x_{n+1},\;\cdots,\;x_{n+m-1}}_{\text{共 $$m 项}} \rbrace<br>$$<br>采样集合 $X$ 即为平稳分布 $\pi(x)$ 对应的样本集。</p><p>实际应用中，$n$ 凭经验确定。</p><p><strong>&gt; 3. 从初始分布采样</strong></p><p>从初始分布采样的意思是：从简单分布（例如均匀分布）采样，以初始分布的确定采样值（常见的方法是以初始分布的累积分布函数确定采样值）。</p><p>计算累积分布函数（python中调用 <code>np.cumsum(arr)</code>）：<br>$$<br>F_0 = [0.22081522,0.33371785,0.56965314,0.62210774,0.81389112,1]<br>$$<br>从[0,1]均匀分布采样一次（<code>np.random.uniform(0, 1)</code>）得 $p_0 = 0.27364499172190815​$</p><p>因为 $F_0^{(1)}&lt;p_0&lt;F_0^{(2)}​$，我们认为本次采样值 $x_1=2​$，即本次骰子之出来的点数是2。</p><p><strong>&gt; 4. 基于 $P(x|x_1)​$ 进行第二次采样</strong></p><p>$P(x|x_1=2)$ 即从状态转移矩阵 $P$ 的第二行采样<br>$$<br>P(x|x_1) = [ 0.03751516\;0.33564335\;0.39400589\;0.12847041\;0.07526389\;0.0291013 ]<br>$$<br>从[0,1]均匀分布采样一次得 $p_1 = 0.23181961317728317$，$x_2=2$。</p><p><strong>&gt; 5. 基于 $P(x|x_2)​$ 进行第三次采样</strong></p><p>$P(x|x_2=2)$ 即从状态转移矩阵 $P$ 的第二行采样<br>$$<br>P(x|x_2) = [ 0.03751516\;0.33564335\;0.39400589\;0.12847041\;0.07526389\;0.0291013 ]<br>$$<br>从[0,1]均匀分布采样一次得 $p_2= 0.5880393198555685​$，$x_3=3​$。</p><p><strong>&gt; 基于 $P(x|x_{n-1})$ 进行第 $n$ 次采样</strong> </p><p>$P(x|x_{n-1})$ 即从状态转移矩阵 $P$ 的第 $x_{n-1}$ 行采样，得到第 $n$ 个采样值 $x_n$，这个采样值将作为我们第一个目标样本。也就是说前面的 $n-1$ 个采样会被舍弃掉。</p><p>继续采样，直到获取第 $n+m-1$ 个采样值。</p><h1 id="挠头"><a href="#挠头" class="headerlink" title="挠头"></a>挠头</h1><p><strong>Q1 由上知是从矩阵 $P$ 而不是每个状态分布 $\pi$ 中采样，因为不论状态转移多少次，矩阵 $P$ 总是不变的，为什么不直接从矩阵 $P$ 中采样，而是从初始分布采样舍弃 $n-1$ 个样本？</strong></p><p>这个问题看似复杂，其实很简单：因为总是选取矩阵 $P$ 的某一行采样，至于要选取哪一行取决于上一次的采样结果。那么，<strong>第一次使用矩阵 $P$ 进行采样</strong>（区别于<strong>第一次采样</strong>）应该选取哪一行呢？这是不确定的。因此第一次采样我们从指定的初始分布采样，第二次采样（即第一次使用矩阵 $P$ 进行采样）基于第一次采样结果进行。</p><p><strong>Q2 为什么要舍弃前面的 $n-1$ 个采样值？</strong></p><p>因为初始分布是我们自己定义的，而采样值服从的分布应该是平稳分布而不是初始分布或者达到平稳分布前的任何一个分布。</p><p>$n$ 一般是人为设定的阈值，代表第 $n$ 次转移时已经达到平稳分布，显然这不是一个十分精确的阈值，但是在实际应用过程中影响不大。</p><p>状态的分布伴随着采样过程而改变，这是一个隐藏的过程。当状态分布收敛时的采样值集为平稳分布的采样值。（这句话很玄学，暂时没太理解！）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的马尔可夫链采样的基础是状态概率矩阵 $P$ 已知，但是实际上 $P$ 是很难求出来的，即我们知道的只有平稳分布 $\pi(x)$。这似乎是一个死循环~</p><p>MCMC采样巧妙地解决了这个问题。</p><p>M-H采样和Gibbs采样是MCMC采样地改进版。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果我们的目标分布是&lt;strong&gt;简单&lt;/strong&gt;、&lt;strong&gt;离散&lt;/strong&gt;的分布，这个目标分布可以当作某个马尔可夫链的&lt;strong&gt;平稳分布&lt;/strong&gt;，这个平稳分布对应着一个&lt;strong&gt;状态转移矩阵&lt;/strong&gt;。如果这个状态转移矩阵已知，我们就可以十分容易的得到目标分布的采样集。&lt;/p&gt;
&lt;p&gt;离散马尔可夫链采样只是理论基础，实用价值不大。&lt;/p&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
      <category term="采样" scheme="http://chenyin.top/tags/%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>采样2 - 离散马尔可夫链的几个性质</title>
    <link href="http://chenyin.top/stat/20190416-ea6c.html"/>
    <id>http://chenyin.top/stat/20190416-ea6c.html</id>
    <published>2019-04-16T03:05:25.000Z</published>
    <updated>2019-07-09T01:12:19.268Z</updated>
    
    <content type="html"><![CDATA[<p>互通、可约、周期、常返、遍历<br><a id="more"></a></p><h1 id="状态间的互通性"><a href="#状态间的互通性" class="headerlink" title="状态间的互通性"></a>状态间的互通性</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/15.jpg" alt=""></p><p>互通性的三个性质：</p><ol><li>自返律（假设状态有<strong>自环</strong>）：$\mathbf{i} \leftrightarrow \mathbf{i}​$</li><li>对称律：$\mathbf{i} \leftrightarrow \mathbf{j}​$当且仅当$\mathbf{j} \leftrightarrow \mathbf{i}​$</li><li>传递律：如果$\mathbf{i} \leftrightarrow \mathbf{k}$且$\mathbf{k} \leftrightarrow \mathbf{j}$，那么$\mathbf{i} \leftrightarrow \mathbf{j}$ </li></ol><h1 id="链的可约性"><a href="#链的可约性" class="headerlink" title="链的可约性"></a>链的可约性</h1><p><strong>不可约性</strong>：如果一个马氏链的任意两个状态都互通，则这个马氏链不可约；否则可约。</p><p>不可约的马氏链：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/16.jpg" alt=""></p><p>可约的马氏链：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/17.jpg" alt=""></p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/18.jpg" alt=""></p><h1 id="状态的周期性"><a href="#状态的周期性" class="headerlink" title="状态的周期性"></a>状态的周期性</h1><p>状态的周期性有个挠头的定义（$from$ 张波《应用随机过程》）：</p><blockquote><p>记$d_i$为数集$\lbrace{n : n \geq 1, p_{i i}^{(n)}&gt;0}\rbrace$的最大公约数，则称它为状态$i$的周期。</p><p>若对一切$n{\ge}1$有$p_{i i}^{(n)}=0$，则约定$d_{i}=\infty$。</p><p>当$d_i&gt;1​$时，称$i​$是有周期的状态；当$d_i=1​$时，称$i​$是非周期的状态。</p></blockquote><p>数集$\lbrace{n : n \geq 1, p_{i i}^{(n)}&gt;0}\rbrace$指的是从状态$i$出发再次回到状态$i​$的<strong>步数</strong>的集合。</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/19.jpg" alt=""></p><p>上图状态1再次回到状态1的方式有：</p><ol><li>$1{\to}1$：步数为1</li><li>$1\to2\to1$：步数为2</li><li>重复方式1，或者重复方式2，或者方式1和方式2的组合，例如$1\to1\to1$，$1\to2\to1\to1$</li></ol><p>因此状态1回到状态1的步数集合是{1, 2, 3, 4, 5, …}，$d_i=1$，状态1是非周期的；</p><p>状态2回到状态2的基本方式是{$2\to1\to2$：2步，$2\to1\to1\to2$：3步}，步数集合是{2，3，4，5，…}，最大公约数$d_i=1$，因此状态2是非周期的。</p><p>再看下图：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/21.jpg" alt=""></p><p>状态1自返的基本方式是：</p><ul><li>$1\to2\to3\to4\to1$，步数为4</li><li>$1\to5\to6\to7\to8\to9\to1$，步数为6</li></ul><p>状态1自返的步数集合是{4，6，8，10，…}，最大公约数$d_i=2$，所以状态1是周期的。</p><p>状态2，3，4的步数集合是{4，8，10，12，14，…}，都是周期的。</p><p>状态5，6，7，8，9的步数集合是{6，10，12，18，…}，都是周期的。</p><p>如何简单判断一个状态是<strong>周期/非周期</strong>的？</p><ul><li>带有<strong>自环</strong>的状态一定是非周期的（因为$d_i=1$），但不是所有非周期的状态都有自环，如下条</li><li>与非周期状态互通的状态一定是非周期的</li></ul><h1 id="状态的常返性"><a href="#状态的常返性" class="headerlink" title="状态的常返性"></a>状态的常返性</h1><p><strong>常返性</strong>即：马氏链由一个状态出发之后能否再次回归到本状态的特性。</p><p>常返性分为三种：</p><ul><li><strong>正</strong>常返（必定会返回，平均返回时间为有限值）</li><li><strong>零</strong>常返（必定会返回，平均返回时间为 $\infty​$ ）</li><li><strong>非</strong>常返（可能不再返回）</li></ul><p>定义略</p><p><strong>不可约马氏链的状态一致性</strong>定理：不可约马氏链的状态集全为正常返，或者全为零常返，或者全为非常返，并且每个状态的周期相同。</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/20.jpg" alt=""></p><p>上图不可约马氏链中：</p><ul><li>如果 $p&lt;q$，那么全为正常返；</li><li>如果 $p=q$，那么全为零常返；</li><li>如果 $p&gt;q$，那么全为非常返。</li></ul><h1 id="状态-链的遍历性"><a href="#状态-链的遍历性" class="headerlink" title="状态/链的遍历性"></a>状态/链的遍历性</h1><p>如果齐次马氏链中的某个状态是非周期、正常返状态，称这个状态是<strong>可遍历</strong>的。</p><p>如果马氏链所有状态全互通（不可约）、可遍历（非周期、正常返），称这个马氏链为<strong>遍历链</strong>。</p><p>遍历链存在一个<strong>平稳分布</strong>：</p><ul><li>平稳分布与初始状态无关</li><li>平稳分布是唯一的</li><li>平稳分布全部大于0</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互通、可约、周期、常返、遍历&lt;br&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
      <category term="采样" scheme="http://chenyin.top/tags/%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>采样1 - 逆变换采样和拒绝采样</title>
    <link href="http://chenyin.top/stat/20190415-a232.html"/>
    <id>http://chenyin.top/stat/20190415-a232.html</id>
    <published>2019-04-15T09:27:14.000Z</published>
    <updated>2019-04-22T01:40:45.196Z</updated>
    
    <content type="html"><![CDATA[<p><strong>蒙特卡洛方法（Monte Carlo Method）</strong>尝试利用计算机模拟随机数（伪随机数）解决一类问题，这类问题通常是：1. 所求解的问题本身具有内在随机性，例如中子与原子核的相互作用受量子力学规律的制约；2. 所求解问题可以转化为某种随机分布的特征数，例如通过撒豆子的方式计算不规则图形的面积。蒙特卡洛法是一种以概率统计理论为指导的数值计算方法。</p><p><strong>抽样</strong>（<strong>采样</strong>）指从总体中抽取一部分作为样本。计算机模拟中，抽样意味着从一个概率分布中生成一个观察值，这涉及到一个随机的过程。一般认为计算机只能进行均匀分布的采样，对于复杂的概率分布，需要进行采样方法设计。</p><a id="more"></a><h1 id="逆变换采样"><a href="#逆变换采样" class="headerlink" title="逆变换采样"></a>逆变换采样</h1><p>从图像上理解连续型随机变量的采样是个什么玩意儿十分形象：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/10.jpg" alt=""><br>左图是正态分布的<strong>概率密度函数（Probability Density Function，PDF）</strong>记为$f(x)​$，右图是正态分布的<strong>累积分布函数（Cumulative Distribute Function，CDF）</strong>记为$F(x)​$。随机变量的采样就是在$[0,1]​$均匀分布采样的基础上，选取尽可能分散的点，使这些点尽可能地拟合CDF曲线。</p><!-- 当$F(x)$的反函数$F^{-1}(u)$的定义域始终是$[0,1]$。如果我们在$F^{-1}(u)$的定义域上多次均匀采样，此时可以认为相邻采样点的横坐标之差相同，反函数曲线变化趋势只与相邻点的纵坐标相关。这样，我们基于$[0,1]$的均匀采样产生了一组数（或者说一组点），这组点很好的拟合了反函数$F^{-1}(u)$，这就意味着这组点也能很好拟合$F(x)$。相应的，这组点的纵坐标取值集合就是我们针对$F(x)$的一组采样。--><h1 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h1><p>逆变换采样虽然简单有效，但是其应用场景十分有限：当累积分布函数或者反函数难求时，而实际情况往往是这样。</p><p>下图中的$f(x)$是我们采样的目标PDF，当其CDF或者CDF的反函数不容易求的时就不能直接对$f(x)$进行采样。<strong>拒绝采样（Rejection Sampling）</strong>的基本思想是借助这样一个参考概率密度函数$f_r(x)$即下图中的$Mg(x)$：</p><ul><li>$f_r(x)$十分容易进行采样，例如取均匀分布意味着参考PDF可以直接进行逆变换采样</li><li>$f_r(x)$位于$f(x)$上方，即对任意$x$有$f_r(x){\ge}f(x)$</li><li>$Mg(x)$表示将均匀分布$g(x)$向上移动，此时以$f(x)$的极大值确定$M$的值效果比较好</li></ul><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/11.jpg" width="50%"></p><p>从图上来看，参考PDF“罩住”了目标PDF：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/12.jpg" width="50%"></p><p>拒绝采样的过程如下：</p><ol><li><p>从$f_r(x)$进行一次采样$x_i$</p></li><li><p>计算$x_i$的<strong>接受概率</strong>$\alpha$（Acceptance Probability）：<br>$$<br>\alpha=\frac{f\left(x_{i}\right)}{f_r\left(x_{i}\right)}<br>$$</p></li><li><p>从$(0,1)$均匀分布中进行一次采样$u$</p></li><li>如果$\alpha{\ge}u$，接受$x_i$作为一个来自$f(x)$的采样；否则，重复第1步</li></ol><p>显然对于特定的目标PDF，参考PDF不止一个，不同PDF的$\max(\alpha)$不同。以均匀分布采样为例，当参考PDF从上面越靠近目标PDF采样效率越高，相应的寻找这样的参考PDF的难度就越大。采样效率高意味着对于那些概率密度较小的区域有更大的几率能够采样到。</p><p>为了平衡采样效率和参考PDF的确定难度，提出了<strong>自适应拒绝采样</strong>。</p><h1 id="自适应拒绝采样"><a href="#自适应拒绝采样" class="headerlink" title="自适应拒绝采样"></a>自适应拒绝采样</h1><p>当参考PDF不能很好的“罩住”目标PDF时，那些未罩住区域内的采样点被拒绝的概率就会很大，采样效率低。所以如果能够找到一个跟目标PDF非常接近的参考PDF，即参考PDF计划能够完全从上面贴合目标PDF，此时能够达到较好的采样效率。</p><p>当目标PDF是<strong>log-concave函数</strong>时可以采用<strong>自适应拒绝采样（Adaptive Rejection Sampling，ARS）</strong>。</p><blockquote><p><strong>log-concave函数</strong>：当概率密度函数$f(x)$是凹函数（concave）且$\log{f(x)}$仍然是凹函数时，$f(x)$称之为log-concave函数：<br>$$<br>f(\theta x+(1-\theta) y) \geq \theta f(x)+(1-\theta) f(y) \<br>\log f(\theta x+(1-\theta) y) \geq \theta \log f(x)+(1-\theta) \log f(y)<br>$$</p></blockquote><p>在log-concave函数上随机选取一些点做切线：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/13.jpg" width="50%"></p><p>将log-concave函数变换回原来的PDF，此时上图的切线将变成曲线（取指数），它！们！弯！了！</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/14.jpg" width="50%"></p><p>将这组弯了的“切线”组成成一个分段函数，这个分段函数将会很好的贴合目标PDF。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;蒙特卡洛方法（Monte Carlo Method）&lt;/strong&gt;尝试利用计算机模拟随机数（伪随机数）解决一类问题，这类问题通常是：1. 所求解的问题本身具有内在随机性，例如中子与原子核的相互作用受量子力学规律的制约；2. 所求解问题可以转化为某种随机分布的特征数，例如通过撒豆子的方式计算不规则图形的面积。蒙特卡洛法是一种以概率统计理论为指导的数值计算方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽样&lt;/strong&gt;（&lt;strong&gt;采样&lt;/strong&gt;）指从总体中抽取一部分作为样本。计算机模拟中，抽样意味着从一个概率分布中生成一个观察值，这涉及到一个随机的过程。一般认为计算机只能进行均匀分布的采样，对于复杂的概率分布，需要进行采样方法设计。&lt;/p&gt;
    
    </summary>
    
      <category term="stat" scheme="http://chenyin.top/categories/stat/"/>
    
    
      <category term="采样" scheme="http://chenyin.top/tags/%E9%87%87%E6%A0%B7/"/>
    
  </entry>
  
  <entry>
    <title>git疑难杂症</title>
    <link href="http://chenyin.top/bug/20190415-bb05.html"/>
    <id>http://chenyin.top/bug/20190415-bb05.html</id>
    <published>2019-04-15T08:14:20.000Z</published>
    <updated>2019-04-15T08:18:08.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/09.jpg" alt=""></p><p><strong>报错关键词</strong>：Updates were rejected because a pushed branch tip is behind its remote counterpart.</p><p><strong>原因分析</strong>：直接在远程master分支进行修改或者有其他人修改后已经提交到了远程master，而本地使用test（非本地master分支）分支进行再次修改后直接push到远程master分支，此时本地master分支的版本还是远程master分支修改之前的版本，即本地master的版本落后于远程master的版本，因此导致push失败。</p><p><strong>解决办法</strong>：先 <code>git checkout master</code> 到本地master分支，再 <code>git pull 远程仓库 master</code> 拉取最新版本，再 <code>git checkout test</code> 回到本地工作分支，再 <code>git push 远程仓库 master</code> 推送最新版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/09.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报错关键词&lt;/strong&gt;：Updates were rejected b
      
    
    </summary>
    
      <category term="bug" scheme="http://chenyin.top/categories/bug/"/>
    
    
  </entry>
  
  <entry>
    <title>python3中的字符串与编码问题</title>
    <link href="http://chenyin.top/python/20190411-d7e5.html"/>
    <id>http://chenyin.top/python/20190411-d7e5.html</id>
    <published>2019-04-11T06:33:52.000Z</published>
    <updated>2019-09-15T02:22:19.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/05.jpg" alt=""></p><p>python3的编码方式比python2已经简单很多了，不过还是让我等菜鸟头疼。廖老师的教程写的着实通俗易懂，恍然大悟。</p><a id="more"></a><h1 id="ASCII、Unicode和UTF-8"><a href="#ASCII、Unicode和UTF-8" class="headerlink" title="ASCII、Unicode和UTF-8"></a>ASCII、Unicode和UTF-8</h1><p>所有的字符串都会拆分成单个字符进行传输和存储。对字符串编码不仅要考虑字符集的完整性、不同语言字符集的兼容性，还要考虑传输存储空间大小。</p><p><strong>ASCII</strong></p><p>ASCII全称是American Standard Code for Information Interchange (美国信息交换标准代码)。</p><p>计算机是美国人发明的，因此早期的ASCII编码只考虑到26个英文字母和一些简单的字符。由于数量较少，我们只需要用<strong>一个字节</strong>就可以完成编码，所以ASCII编码对应的整数值从0到255。</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/ascii.png" alt=""></p><p><strong>Unicode</strong></p><p>ASCII编码不能用来编码中文字符，当然也不能用来编码日文字符、韩文字符和阿拉伯文字符等等等等。如果每个国家都为了是计算机能识别自己特有的字符而使用自己的编码方式，当处理多国语言文本时就会出现许多问题。所以大家统一规定了Unicode编码。换句话说，Unicode编码兼容地球上所有国家的语言符号！真是一个令人振奋的消息~</p><p>一般情况下，Unicode使用<strong>两个字节</strong>对字符进行编码（对于某些十分偏僻的字符可能要用到更多的字节）。对于原来的ASCII编码的字符，在它们的ASCII编码（二进制编码）前加上一个字节的0（即8个0）即可完美转化为Unicode编码。</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">ASCII编码</th><th style="text-align:center">Unicode编码</th><th style="text-align:center">UTF-8编码</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center"><code>01000001</code></td><td style="text-align:center"><code>00000000 01000001</code></td><td style="text-align:center"><code>01000001</code></td></tr><tr><td style="text-align:center">中</td><td style="text-align:center">不能编码</td><td style="text-align:center"><code>01001110 00101101</code></td><td style="text-align:center"><code>11100100 10111000 10101101</code></td></tr></tbody></table><p>好了，现在通过Unicode能够兼容所有语言的字符集了。但是又出现了新的问题：当我的文本（几乎）是全英文是，如果直接使用Unicode编码文件，其传输的字节数量和占用的磁盘空间都是ASCII编码的两倍，显然十分多余。为了解决这个问题，又出现了UTF-8编码。</p><p><strong>UTF-8</strong></p><p>UTF-8编码是不定长的编码方式：那些可以用ASCII编码的字符转化成UTF-8编码时仍然只有一个字节，UTF-8编码的汉字一般是三个字节，少数特殊字符所用的字节数更多。所以，UTF-8是完美兼容ASCII编码的，只支持ASCII编码的应用仍然可以在UTF-8编码上运行。</p><p><strong>总结</strong></p><p>总结以下：</p><ol><li>ASCII编码只适用于英文字符，固定单字节；</li><li>Unicode编码是内存中的编码方式，固定多字节；</li><li>UTF-8编码优化了Unicode编码，不定字节；</li></ol><h1 id="计算机编码工作方式"><a href="#计算机编码工作方式" class="headerlink" title="计算机编码工作方式"></a>计算机编码工作方式</h1><p>字符串所在的场景不外乎两种：</p><ol><li>当我们在python程序中处理字符串时，它们存储在内存中，此时使用Unicode编码字符串；</li><li>当我们存储字符串时往往使用UTF-8等编码方式（建议只适用UTF-8编码存储文件）。</li></ol><p><strong>场景1：记事本编辑文件</strong></p><p>文本文件通常以UTF-8编码存储在磁盘上，记事本应用读取文件到内存中，此时字符串改用Unicode编码，当我们编辑完成之后需要使用UTF-8编码文件保存到磁盘。</p><p><strong>场景2：网页浏览</strong></p><p>当我们浏览某些网页的时候，服务器会自动生成信息，这些字符串是Unicode编码；服务器使用UTF-8编码这些字符串传输至浏览器并显示。</p><h1 id="python3中的字符串"><a href="#python3中的字符串" class="headerlink" title="python3中的字符串"></a>python3中的字符串</h1><p>python中字符串类型是<code>str</code>，它们以Unicode方式编码。</p><p><strong>字符</strong>通过Unicode编码可以与数字（二进制、十进制、十六进制…）进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 获取字符的Unicode编码的十进制整数值</span></span><br><span class="line">ord(<span class="string">'A'</span>) <span class="comment"># 65</span></span><br><span class="line">ord(<span class="string">'中'</span>) <span class="comment"># 20013</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将十进制整数通过Unicode编码方式转化为字符</span></span><br><span class="line">chr(<span class="number">65</span>) <span class="comment"># 'A'</span></span><br><span class="line">chr(<span class="number">20013</span>) <span class="comment"># '中'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 注意：</span></span><br><span class="line"><span class="comment"># ord()只能转换单个字符，传递字符串会报错</span></span><br><span class="line"><span class="comment"># 传入chr()接收的整数如果超过Unicode编码的范围也会报错</span></span><br></pre></td></tr></table></figure><p>我们在程序中处理的字符串都是Unicode编码的，一个字符占据了多个字节。</p><p>当进行网络传输或者本地存储时，<code>str类型</code>的字符串需要被转换为字节数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单单一个'中'是Unicode编码的，直观上就没有反映出字节信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad'</span></span><br><span class="line"><span class="comment"># 从encode结果我们可以看到'中'包含了三个字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="string">b'\xd6\xd0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两种方式军会报错LookupError</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中'</span>.encode(<span class="string">'unicode'</span>) <span class="comment"># 因为'中'本来就是Unicode编码了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中'</span>.encode(<span class="string">'ascii'</span>) <span class="comment"># ASCII不能编码汉字字符</span></span><br></pre></td></tr></table></figure><p>python中</p><ol><li><p><code>str.encode(CODING_TYPE)</code>方法可以将Unicode字符串转换成CODING_TYPE编码的字符串；</p></li><li><p><code>bytes.decode(ORIGIN_TYPE)</code>方法将ORIGIN_TYPE编码的字节串解码成Unicode字符串。</p></li><li><p>encode的参数是目标编码方式，decode的参数是源字节串的编码方式。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xd6\xd0'</span>.decode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="string">'中'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## .decode(..., errors='ignore')可忽略掉部分不能正确解码的字节</span></span><br><span class="line"><span class="comment"># \xe4\xb8\xad 被忽略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xd6\xd0'</span>.decode(<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="comment"># \xd6\xd0 被忽略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xd6\xd0'</span>.decode(<span class="string">'gbk'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下面两种是错误的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad'</span>.decode(<span class="string">'gbk'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xd6\xd0'</span>.decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p><code>len(...)</code>函数接收<strong>字符串</strong>时计算的是字符串的<strong>字符数目</strong>，接收<strong>字节串</strong>时计算的是字节串的<strong>字节数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'中国'</span>) <span class="comment">#=&gt; 2</span></span><br><span class="line">len(<span class="string">'中国'</span>.encode(<span class="string">'utf-8'</span>)) <span class="comment">#=&gt; 6，等价于 len(b'\xe4\xb8\xad\xe5\x9b\xbd')</span></span><br><span class="line">len(<span class="string">'中国'</span>.encode(<span class="string">'gbk'</span>)) <span class="comment">#=&gt; 4，等价于 len(b'\xd6\xd0\xb9\xfa')</span></span><br></pre></td></tr></table></figure><p><strong>.py源文件</strong>也是文本，我们在保存是应该保存为UTF-8编码。为了使python解释器能正确读取源文件，我们需要指定解释器读取源文件的编码方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>notepad++应该选择 <strong>Encoding in UTF-8 without BOM</strong> 编码文件！</p><h1 id="中文文件的读写"><a href="#中文文件的读写" class="headerlink" title="中文文件的读写"></a>中文文件的读写</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding参数指定原文件的编码格式，可设置errors='ignore'</span></span><br><span class="line"><span class="keyword">with</span> open(INPUT_FP, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> reader:</span><br><span class="line">    OUTPUT_STRING = ...</span><br><span class="line">    </span><br><span class="line"><span class="comment"># encoding指定新文件的编码格式</span></span><br><span class="line"><span class="keyword">with</span> open(OUPUT_FP, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    writer.write(OUTPUT_STRING)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不要将这里的encoding参数和上面的.encode/.decode混淆：</span></span><br><span class="line"><span class="comment"># |- encoding参数指定输入文件/输出文件的编码类型，一般在读文件（本地/网络）的时候才用到</span></span><br><span class="line"><span class="comment"># |- .encode/.decode方法指定unicode编码字符串与其它编码字符串间的转换方式</span></span><br></pre></td></tr></table></figure><p>参考自<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">廖雪峰的python教程-python基础-字符串和编码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/05.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;python3的编码方式比python2已经简单很多了，不过还是让我等菜鸟头疼。廖老师的教程写的着实通俗易懂，恍然大悟。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>灵感源自macaron让人十分舒适的十种颜色</title>
    <link href="http://chenyin.top/cargo/20190410-3bf3.html"/>
    <id>http://chenyin.top/cargo/20190410-3bf3.html</id>
    <published>2019-04-10T03:09:17.000Z</published>
    <updated>2019-04-14T16:02:20.846Z</updated>
    
    <content type="html"><![CDATA[<p>Macaron是一种用蛋白、杏仁粉、白砂糖和糖霜制作，并夹有水果酱或奶油的法式甜点。口感丰富，外脆内柔，外观五彩缤纷，精致小巧。Macaron 10 色因为它们的视觉舒适而广为流传。</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/01.jpg" alt=""></p><a id="more"></a><table><thead><tr><th style="text-align:center">英文名</th><th style="text-align:center">代码</th><th style="text-align:center">视觉改释</th></tr></thead><tbody><tr><td style="text-align:center">bewitched tree</td><td style="text-align:center"><code>#19CAAD</code> 或 <code>rgb(19,202,173)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#19CAAD"></div></td></tr><tr><td style="text-align:center">mystical green</td><td style="text-align:center"><code>#8CC7B5</code> 或 <code>rgb(140,199,181)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#8CC7B5"></div></td></tr><tr><td style="text-align:center">light heart blue</td><td style="text-align:center"><code>#A0EEE1</code> 或 <code>rgb(160,238,225)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#A0EEE1"></div></td></tr><tr><td style="text-align:center">glass gall</td><td style="text-align:center"><code>#BEE7E9</code> 或 <code>rgb(190,231,233)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#BEE7E9"></div></td></tr><tr><td style="text-align:center">silly fizz</td><td style="text-align:center"><code>#BEEDC7</code> 或 <code>rgb(190,237,199)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#BEEDC7"></div></td></tr><tr><td style="text-align:center">brain sand</td><td style="text-align:center"><code>#D6D5B7</code> 或 <code>rgb(214,213,183)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#D6D5B7"></div></td></tr><tr><td style="text-align:center">mustard addicted</td><td style="text-align:center"><code>#D1BA74</code> 或 <code>rgb(209,186,116)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#D1BA74"></div></td></tr><tr><td style="text-align:center">magic powder</td><td style="text-align:center"><code>#E6CEAC</code> 或 <code>rgb(230,206,172)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#E6CEAC"></div></td></tr><tr><td style="text-align:center">true blush</td><td style="text-align:center"><code>#ECAD9E</code> 或 <code>rgb(236,173,158)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#ECAD9E"></div></td></tr><tr><td style="text-align:center">merry cranesbill</td><td style="text-align:center"><code>#F4606C</code> 或 <code>rgb(244,96,108)</code></td><td style="text-align:center"><div style="display:inline-block;width:208px;height:30px;background:#F4606C"></div></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Macaron是一种用蛋白、杏仁粉、白砂糖和糖霜制作，并夹有水果酱或奶油的法式甜点。口感丰富，外脆内柔，外观五彩缤纷，精致小巧。Macaron 10 色因为它们的视觉舒适而广为流传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/04/01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="cargo" scheme="http://chenyin.top/categories/cargo/"/>
    
    
  </entry>
  
  <entry>
    <title>降维04 - TSNE引领时尚</title>
    <link href="http://chenyin.top/ml/20190328-acd8.html"/>
    <id>http://chenyin.top/ml/20190328-acd8.html</id>
    <published>2019-03-28T03:12:08.000Z</published>
    <updated>2019-04-23T07:23:06.304Z</updated>
    
    <content type="html"><![CDATA[<div style="display: inline-block; width: 670px; height: 456px; overflow: hidden; border: 1px solid #ddd"><br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/01.gif" style="margin-top: -114px !important; border: none"><br></div><p><strong>t-SNE</strong> (<strong>t-distributed Stochastic Neighbor Embedding</strong>) 是目前来说效果较好的数据降维与可视化方法，但是大量占用内存、计算时间长的缺点也很突出。</p><a id="more"></a><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/02.png" alt=""></p><p>相比于SNE，t-SNE的主要优化有：联合概率替代条件概率、低维空间下使用t分布代替高斯分布。<a href="#ref1">[1]</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>早期的<strong>可视化 (Visualization)</strong> 工具<u>不负责解释数据</u>，这就限制了这些工具在真实世界数据上的应用，因为我们要想解释数据，我们还是只能靠人眼看。相比于能解释数据的监督学习而言，可视化只需要展示训练数据，而不需要训练模型使它能够拟合到测试数据集。可视化的任务简单许多。<a href="#ref2">[2]</a></p><h2 id="线性降维"><a href="#线性降维" class="headerlink" title="线性降维"></a>线性降维</h2><p> 将数据从高位空间映射到低维空间的过程我们称之为 <strong>map</strong>，相应的，低维空间中的映射点被称之为 <strong>map points</strong>。降维算法已经注意到，要将高维空间中的数据结构问题尽可能的保留到低维空间。</p><p> 但是传统的<strong>线性降维 (Linear dimentionality reduction)</strong>  算法，例如PCA、MDS，更加侧重<u>在低维空间中保持高维空间中的<strong>差异性</strong></u>，即尽可能地分开数据。同时它们更加关注数据地<strong>全局特征</strong>，这点与非线性降维算法显著不同。</p><h2 id="非线性降维"><a href="#非线性降维" class="headerlink" title="非线性降维"></a>非线性降维</h2><p>大部分<strong>非线性降维 (non-linear dimentionality reduction)</strong> 算法关注的是 <u>在低维空间中保持高维空间地<strong>局部特征</strong></u>。这就意味着，它们不能同时关注数据的全局特征和局部特征。全局特征就是基于所有数据进行的解释，比如聚类结果就是基于所有数据进行的，理想情况下每个数据点都能找到它自己所属的类；局部特征只是基于部分数据点进行的推导，比如在SNE算法中，总是计算离中心点欧式距离小的部分点进行下降，它关注的是以中心点为圆心，以有限长度为半径的（超）球体内的点。</p><p>下面7个常见的非线性降维算法，它们在局部特征提取上都是很优秀的：Sammon mapping <a href="#ref3">[3]</a>, CCA <a href="#ref4">[4]</a>, SNE <a href="#ref5">[5]</a>, Isomap <a href="#ref6">[6]</a>, MVU <a href="#ref7">[7]</a>, LLE <a href="#ref8">[8]</a>, Laplacian Eigenmaps <a href="#ref9">[9]</a>。</p><h2 id="t-SNE"><a href="#t-SNE" class="headerlink" title="t-SNE"></a>t-SNE</h2><p>t-SNE继承自SNE算法，同样是非线性降维，它的优势在于：能够保持大部分局部特征到低维空间，同时不丢失全局特征（例如聚类）。</p><p>与SNE一样，t-SNE的思想还是计算两个点间的<strong>相似度</strong> (similarity)。</p><h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>SNE尽管能得到比较好的可视化结果，但是它的损失函数难以优化，并且还存在 <strong>crowding problem (拥挤问题)</strong> 。相比之下，t-SNE能缓和上面提到的所有问题（优化问题和拥挤问题），与SNE相比，t-SNE主要在两个方面进行改进：<br>1.使用<strong>对称</strong>的损失函数，新的损失函数求导会更加容易。<a href="#ref10">[10]</a><br>2.计算低维空间中两点的相似度使用<strong>t分布</strong>而不是高斯分布，t分布是一种<a href="https://en.wikipedia.org/wiki/Heavy-tailed_distribution" target="_blank" rel="noopener"><strong>重尾分布 (heavy-tailed distribution)</strong></a>，它能够有效缓解拥挤问题和优化问题，后面将会详细介绍。</p><h2 id="优化SNE成对称结构"><a href="#优化SNE成对称结构" class="headerlink" title="优化SNE成对称结构"></a>优化SNE成对称结构</h2><p><strong>联合概率替换条件概率</strong></p><p>在SNE中我们通过<strong>条件概率</strong>分别计算高维空间和低维空间中<strong>点对</strong>间的相似度：<br>$$\begin{cases}<br>&amp; p_{ij}=p(x_j|x_i)=\frac{\exp(-||x_i-x_j||^2)}{\sum_{k{\ne}i}{\exp(-||x_i-x_k||^2)}} \\<br>&amp; q_{ij}=q(y_j|y_i) = \frac {\exp{(-||y_i-y_j||^2)}} {\sum_{k{\ne}i}{\exp{(-||y_i-y_k||^2)}}}<br>\end{cases}$$</p><p>然后在t-SNE中我们将条件概率换成<strong>联合概率</strong>：<br>$$\begin{cases}<br>&amp; p_{ij}=p(x_j,x_i)=\frac{\exp(-||x_i-x_j||^2)}{\sum_{m{\ne}n}{\exp(-||x_m-x_n||^2)}} \\<br>&amp; q_{ij}=q(y_j,y_i) = \frac {\exp{(-||y_i-y_j||^2)}} {\sum_{m{\ne}n}{\exp{(-||y_m-y_n||^2)}}}<br>\end{cases}$$</p><p>注意上面两种表述方式的分母的差异：</p><ul><li>条件概率的分母是中心点 $x_i$ 与其它所有点的相似度之和;</li><li>联合概率的分母没有中心点一说，计算的是所有点对（n个数据点有 $C_n^2$ 个点对）的相似度之和。</li><li>条件概率中 $p_{ij}{\ne}p_{ji}$，而联合概率中 $p_{ij}=p_{ji}$（q同理），这正好也与分母的这种差异吻合。</li></ul><p><strong>注意到联合概率算法会产生一个条件概率算法不会遇到的问题：离群点。</strong></p><p>观察上面的联合概率公式，对于离群点 $x_i$，所有与它配对计算出来的 $p_{ij}$ 或者 $p_{ji}$ 的 $||x_i-x_j||^2$ 将会特别大，这导致 $p_{ij}$ 或者 $p_{ji}$ 总是特别的小，即与 $x_i$ 相关的 $p_{ij}$ 或者 $p_{ji}$ 在对损失函数的贡献总是特别小。这相当于自动减小了那些低密度区域的点在损失函数中的权重，使得通过相似性确定离群点在低维空间中的位置更加困难。<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/03.png" alt=""></p><p>所以呢，必须想办法消除这种效应，增大离群点在损失函数中的比重，文中用用条件概率公式代替上述 $p_{ij}$ 的定义，即：<br>$$\begin{cases}<br>&amp; p_{ij}=\frac{p(x_j|x_i)+p(x_i|x_j)}{2n}  \\<br>&amp; q_{ij}=q(y_j|y_i) = \frac {\exp{(-||y_i-y_j||^2)}} {\sum_{m{\ne}n}{\exp{(-||y_m-y_n||^2)}}}<br>\end{cases}$$</p><p>这样每个点 $x_i$ 对损失函数的贡献度 $p(x_i)=\sum_jp_{ij}&gt;\frac1{2n}$，这就保证了离群点的贡献不会太少。</p><p><strong>KL散度作为损失函数</strong></p><p>t-SNE仍然使用KL散度作为损失函数，所不同的是，这里求的是两个联合概率分布之间的散度：<br>$$C=KL(P||Q)=\sum_i\sum_jp_{ij}\log{\frac{p_{ij}}{q_{ij}}}$$</p><p>此时KL损失函数求导的结果更加简洁：<br>$$\frac{\partial{C}}{\partial{y_i}}=4\sum_k(p_{ik}-q_{ik})(y_i-y_k)$$</p><p>SNE求导结果为：<br>$$\frac{\partial{C}}{\partial{y_i}}=2\sum_k{(y_i-y_k)[(p_{ik}-q_{ik})+(p_{ki}-q_{ki})]}$$</p><h2 id="解决SNE的拥挤问题"><a href="#解决SNE的拥挤问题" class="headerlink" title="解决SNE的拥挤问题"></a>解决SNE的拥挤问题</h2><h3 id="什么是拥挤问题"><a href="#什么是拥挤问题" class="headerlink" title="什么是拥挤问题"></a>什么是拥挤问题</h3><h4 id="流形的直观理解"><a href="#流形的直观理解" class="headerlink" title="流形的直观理解"></a>流形的直观理解</h4><p>manifold的<a href="https://en.wikipedia.org/wiki/Manifold" target="_blank" rel="noopener">Wiki解释</a>：</p><blockquote><p>In mathematics, a manifold is a topological space that locally resembles Euclidean space near each point. </p></blockquote><p>而中文概念“流形”是由北大已故数学教授江泽涵先生提出来。江老的堂姐夫是胡适？… … 不过“流形：这个词真的很艺术，我初次见到时就感叹其形象而不能自已。流形的<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%BD%A2" target="_blank" rel="noopener">Wiki中文解释</a>：</p><blockquote><p>是局部具有欧几里得空间性质的空间，是欧几里得空间中的曲线、曲面等概念的推广。欧几里得空间就是最简单的流形的实例。地球表面这样的球面则是一个稍微复杂的例子。一般的流形可以通过把许多平直的片折弯并粘连而成。</p></blockquote><p><strong>为什么说二维流形面上的点距容易建模 (model)？</strong></p><p>这个问题直观上理解最是简单。首先对于欧几里得空间，我们普通人类最多能直观感受到三维。换算成黎曼空间，就意味着我们只能在三维空间中直观感不超过二维流形曲面的存在，二维流形曲面上的距离就是曲面内连接它们的最短曲线长度。经典的二维流形曲面如下（Swiss Roll 流形, <a href="http://people.cs.uchicago.edu/~dinoj/manifold/swissroll.html%29" target="_blank" rel="noopener">Swiss Roll dataset</a>）：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/04.png" alt=""></p><h4 id="为什么存在拥挤"><a href="#为什么存在拥挤" class="headerlink" title="为什么存在拥挤"></a>为什么存在拥挤</h4><p>为了便于可视化，我们会将高维流形上的点映射到二维空间，同时最大程度的保留它们的相对位置（这种每个点相对于整体数据点的定位就是一种全局特征）。然而这种映射是很难完美实现的，举个例子，十维空间（欧几里得空间或者黎曼空间）中可以很容易找到11个相互等距的点（就好比二维空间中能轻易找到三个相互等距的点一样），然而映射到二维空间是不可能找到11个相互等距的点的，势必会有一些点会相互靠近挤在一起，如下图所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/05.png" alt=""><br>以二维相互等距的三个点映射到一维空间为例，无论怎么努力，三点都不可能再等距。归根揭底，不同维度空间内的距离分布是不同的，降维映射难免尽如人意。</p><p>再以球内区域为例解释crowding现象：以数据点 $x_i$ 为中心的球的体积与 $r^m$ 直接相关（ $r$ 是半径，$m$ 是球所在空间的维度）。如果在十维流形曲面上数据点均匀分布在这个球中，我们试图在二维流形曲面上以 $y_i$ 为中心对与 $x_i$ 相关的两两距离进行建模。此时我们就会遇到传说中的拥挤问题：与容纳中心点附近数据点的区域相比，容纳适中距离数据点的区域显得不够用。</p><p>在均匀分布的条件下，等距点的数量与半径相关，距离越大数量越多，这意味着映射到低维空间就会越“挤”。因此如果我们想要较为准确的在二维流形曲面中对以 $x_i$ 为中心的两两距离建模，我们就必须把距离 $x_i$ 适中位置的那些点往更远的地方推置（因为太挤了）。</p><!--在SNE中，数据点 $y_i$ 与其它点之间存在一个微弱的引力，所有的力相互作用最终使所有的点**分散在**了自己的收敛位置，这使得点的分布具有连续性质，在聚类时也不会出现断层的现象。--><p>不只是SNE，其它局部特征提取算法例如Sammon mapping等也都面临着拥挤难题。</p><h3 id="怎么解决拥挤问题"><a href="#怎么解决拥挤问题" class="headerlink" title="怎么解决拥挤问题"></a>怎么解决拥挤问题</h3><p>一种叫做<strong>UNI-SNE</strong>的改良算法<a href="#ref10">[10]</a>提出了一种解决办法：给每一个两两相似度添加一个背景值，背景值采样自均匀分布并以一定的比例 $\rho$ 进行混合。由于每个点对之间都引进了背景值，因此不管低维空间中两个映射点离的多么远，$q_{ij}$ 永远不会小于 $\frac{\rho}{n(n-1)/2}$（n个数据点可组合成 $C_n^2$ 个点对）。</p><p>引进背景值导致对于高维空间中相距很远的两个数据点总有$q_{ij}&gt;p_{ij}$（$p_{ij}{\rightarrow}0$ 时 $q_{ij}{\rightarrow}\frac{\rho}{n(n-1)/2}$），这表示低维空间中点对并没有完全拟合高维空间的点对相似度，映射后相似度变小。</p><p>尽管UNI-SNE的效果比SNE好，但是其损失函数却很难优化。目前较好的优化UNI-SNE的方法是：开始的时候将背景值混合比例设为0，这实际上等效于运行SNE；当SNE开始使用<strong>模拟退火</strong>策略时增大背景值的混合比例，促进自然分类间的gaps形成。</p><p>直接优化UNI-SNE并不可行，因为低维空间中两个相距很远的映射点的 $q_{ij}$ 几乎全部来自于背景值，即高维空间中相应两点间（即使他们的 $p_{ij}$ 很大）的距离对 $q_{ij}$ 的影响很小，这使得映射后的两点间的 $q_{ij}$ 没有什么实际意义。这表示，如果一个自然类的两部分在优化早期就分开了，就再也不会再聚合在一起了。</p><h2 id="低维空间采用柯西分布表达联合概率"><a href="#低维空间采用柯西分布表达联合概率" class="headerlink" title="低维空间采用柯西分布表达联合概率"></a>低维空间采用柯西分布表达联合概率</h2><p>UNI-SNE通过添加背景值使低维空间中相距甚远的 $q_{ij}$ 不至于趋近于0。</p><p>本文提出了一种新的解决办法，采用与高斯分布性质极其相似的重尾分布计算联合概率。右重尾分布使得当随机变量取值很大时其对应的概率值高斯分布要大，典型的重尾分布是t分布，如下图所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/06.png" alt=""><br>t分布实际上是不同方差的高斯分布的混合分布，它的性质与高斯分布十分接近，而且更加容易计算：因为高斯分布涉及到指数运算，而t分布只需要求倒数。</p><p>这里采用的是自由度 $\nu=1$ 的t、分布，又叫做<strong>柯西分布</strong>，其概率密度函数如下：<br>$$f(x;x_0,\gamma)=\frac1{\pi\gamma[1+(\frac{x-x_o}{\gamma})]^2}$$</p><p>取 $x_0=0, \gamma=1$ 得标准柯西分布：<br>$$f(x;0,1)=\frac1{\pi[1+(x-x_0)]^2}$$</p><p>用标准柯西分布表示联合概率：<br>$$q_{ij}=\frac{(1+||y_i-y_j||^2)^{-1}}{\sum_{m{\ne}n}{(1+||y_m-y_n||^2)^{-1}}}=\frac{\sum_{m{\ne}n}(1+||y_m-y_n||^2)}{1+||y_i-y_j||^2}$$</p><p>求导结果如下：<br>$$\frac{\partial{C}}{\partial{y_i}}=4\sum_j{(p_{ij}-q_{ij})(y_i-y_j)(1+||y_i-y_j||^2)^{-1}}$$</p><h2 id="Pseudo-code"><a href="#Pseudo-code" class="headerlink" title="Pseudo code"></a>Pseudo code</h2><p>下面是<strong>精简版t-SNE算法</strong>伪代码，非常简洁：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/07.png" alt=""></p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>添加微小的动量项可以减少到达最优解的迭代次数</strong></p><p><strong>精简版的t-SNE算法采用适应性学习率加速训练</strong>：在梯度较稳定的方向上增大学习率。<a href="#ref11">[11]</a></p><p>尽管精简版算法已经可以吊打其它非参数降维技术了，还是可以继续优化，文中提出了两个技巧：</p><p><strong>1. early compression</strong>：优化起始的时候将所有的映射点初始化在原点附近，有利于映射点移动、形成自然类。early compression通过给损失函数加上一个L2惩罚项实现。<br><strong>2. early exaggeration</strong>：在优化的初始阶段将所有的 $p_{ij}$ 扩大指定倍数加快收敛速度。</p><p>总结一下模型优化的参数配置：</p><ul><li>起始的50次迭代中将所有的 $p_{ij}$ 乘以4（这个步骤在精简版算法的伪代码中没有写出来）；</li><li>梯度下降的迭代轮数T设为1000；</li><li>动量项 $\alpha^{(t)}$ 当 $t&lt;250$ 时设为0.5，当 $t{\ge}250$ 时设为0.8；</li><li>学习率初始值设为100，每次迭代都将进行适应性更新 <a href="#ref11">[11]</a>。</li></ul><p><a href="http://ticc. uvt.nl/˜lvdrmaaten/tsne" target="_blank" rel="noopener">算法的Matlab实现</a></p><h1 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h1><p>作者分析了三个不足之处。</p><p><strong>1. 不能用于低维空间超过三维的情况</strong></p><p>因为t-SNE算法在映射空间利用了<strong>柯西分布</strong>的重尾特性解决拥挤问题，柯西分布是自由度为1的t分布，这种特性在二维空间中表现十分优异。但如果需要降到三维以上的映射空间，1自由度的t分布不能很好的保留局部特征，我们可能需要使用更多自由度的t分布。</p><p><strong>2. 本征维度诅咒</strong></p><p>t-SNE虽然能够保留全局特征，但是总体上还是基于局部特征进行的降维，这表示t-SNE对原始数据的 <strong>本征维度 (intrinsic dimentionality)</strong> 十分敏感，因为本征维度过高，我们就不能再把流形曲面的局部区域当欧几里得空间处理了，数据点间的局部特征更加复杂 <a href="#ref12">[12]</a>。不仅t-SNE，其它主流的基于局部特征提取的降维算法（如Isomap，LLe）都面临着这个诅咒。</p><p>作者提出了一种可行的办法：先用 <strong>自编码器 (autoencoder)</strong><a href="#ref13">[13]</a> 对数据进行压缩，这类模型可以大大降低原始数据的维度，同时最大保留高维数据的特征。经过编码的数据再进行t-SNE降维。</p><p><strong>3. 损失函数不凸~</strong></p><p>不幸的是当前主流降维算法使用的损失函数都是凸函数，而t-SNE优化的超参更多，这使得其损失函数是非凸的。这意味着，不同的超参取值、不同的初始化都可能收敛到不同的（局部最优）解。但是作者表示，如果固定这些超参，t-SNE就可以应用于不同的可视化任务，优化结果不会随着不同批次而发生变化。</p><p>t-SNE降维结果中点间的距离是没有实际意义的。原始的t-SNE训练很慢，后面有许多改进，比如 </p><ul><li>multiple maps of t-SNE</li><li>parametric t-SNE</li><li>… …</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><span id="ref1">[1]</span> <a href="http://www.jmlr.org/papers/v9/vandermaaten08a.html" target="_blank" rel="noopener">Maaten, L. V. D., &amp; Hinton, G. (2008). <strong>Visualizing data using t-SNE</strong>. Journal of machine learning research, 9(Nov), 2579-2605.</a><br><span id="ref2">[2]</span> M.C. Ferreira de Oliveira and H. Levkowitz. <strong>From visual data exploration to visual data mining: A survey</strong>. IEEE Transactions on Visualization and Computer Graphics, 9(3):378–394, 2003.<br><span id="ref3">[3]</span> J.W. Sammon. <strong>A nonlinear mapping for data structure analysis</strong>. IEEE Transactions on Computers, 18(5):401–409, 1969.<br><span id="ref4">[4]</span> P. Demartines and J. Herault. <strong>´ Curvilinear component analysis: A self-organizing neural network for nonlinear mapping of data sets</strong>. IEEE Transactions on Neural Networks, 8(1):148–154, 1997<br><span id="ref5">[5]</span> G.E. Hinton and S.T. Roweis. <strong>Stochastic Neighbor Embedding</strong>. In Advances in Neural Information Processing Systems, volume 15, pages 833–840, Cambridge, MA, USA, 2002. The MIT Press.<br><span id="ref6">[6]</span> J.B. Tenenbaum, V. de Silva, and J.C. Langford. <strong>A global geometric framework for nonlinear dimensionality reduction</strong>. Science, 290(5500):2319–2323, 2000.<br><span id="ref7">[7]</span> K.Q. Weinberger, F. Sha, and L.K. Saul. <strong>Learning a kernel matrix for nonlinear dimensionality reduction</strong>. In Proceedings of the 21st International Confernence on Machine Learning, 2004.<br><span id="ref8">[8]</span> S.T. Roweis and L.K. Saul. <strong>Nonlinear dimensionality reduction by Locally Linear Embedding</strong>. Science, 290(5500):2323–2326, 2000.<br><span id="ref9">[9]</span> M. Belkin and P. Niyogi. <strong>Laplacian Eigenmaps and spectral techniques for embedding and clustering</strong>. In Advances in Neural Information Processing Systems, volume 14, pages 585–591, Cambridge, MA, USA, 2002. The MIT Press.<br><span id="ref10">[10]</span> J.A. Cook, I. Sutskever, A. Mnih, and G.E. Hinton. <strong>Visualizing similarity data with a mixture of maps</strong>. In Proceedings of the 11th International Conference on Artificial Intelligence and Statistics, volume 2, pages 67–74, 2007.<br><span id="ref11">[11]</span> R.A. Jacobs. <strong>Increased rates of convergence through learning rate adaptation</strong>. Neural Networks, 1: 295–307, 1988.<br><span id="ref12">[12]</span> Y. Bengio. <strong>Learning deep architectures for AI</strong>. Technical Report 1312, Universite´ de Montreal, ´ 2007.<br><span id="ref13">[13]</span> G.E. Hinton and R.R. Salakhutdinov. <strong>Reducing the dimensionality of data with neural networks</strong>. Science, 313(5786):504–507, 2006.</p>]]></content>
    
    <summary type="html">
    
      &lt;div style=&quot;display: inline-block; width: 670px; height: 456px; overflow: hidden; border: 1px solid #ddd&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/img/19/03/01.gif&quot; style=&quot;margin-top: -114px !important; border: none&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;t-SNE&lt;/strong&gt; (&lt;strong&gt;t-distributed Stochastic Neighbor Embedding&lt;/strong&gt;) 是目前来说效果较好的数据降维与可视化方法，但是大量占用内存、计算时间长的缺点也很突出。&lt;/p&gt;
    
    </summary>
    
      <category term="ml" scheme="http://chenyin.top/categories/ml/"/>
    
    
      <category term="paper" scheme="http://chenyin.top/tags/paper/"/>
    
      <category term="降维" scheme="http://chenyin.top/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="t-SNE" scheme="http://chenyin.top/tags/t-SNE/"/>
    
  </entry>
  
</feed>
