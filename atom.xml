<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阔落煮酒</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyin.top/"/>
  <updated>2020-09-27T07:17:02.747Z</updated>
  <id>http://chenyin.top/</id>
  
  <author>
    <name>Barwe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在线获取UserAgent</title>
    <link href="http://chenyin.top/spider/20200927-204d.html"/>
    <id>http://chenyin.top/spider/20200927-204d.html</id>
    <published>2020-09-27T06:56:39.000Z</published>
    <updated>2020-09-27T07:17:02.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>UserAgent</strong> 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。</p><p>更换 UserAgent 可以避免触发某些反爬机制。</p><p><code>fake-useragent</code> 是用来为爬虫提供 UserAgent 的第三方包。</p><a id="more"></a><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>使用 <code>pip install fake-useragent</code> 安装 <strong>fake-useragent</strong> 这个包，如果网络错误，就多试几次。</p><p>使用 <code>import fake_useragent</code> 导入。一般地，我们只需要 <code>from fake_useragent import UserAgent</code> 即可。</p><p>fake-useragent 的API 十分简单：</p><ul><li><code>UserAgent().random</code> 即可获取一个随机的 UserAgent（一般用这个就行了）</li><li>获取子项的值：<code>.ie</code>, <code>.msie</code>, <code>[&#39;Internet Explore&#39;]</code>, <code>opera</code>, <code>chrome</code>, <code>google</code>, <code>[&#39;google chrome&#39;]</code>, <code>firefox</code>, <code>ff</code>, <code>safari</code></li></ul><p>下面是一个典型的 UserAgent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36</span><br></pre></td></tr></table></figure><p>其每个字段的含义是：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200927115718838.png" alt="image-20200927115718838" style="zoom: 67%;"></p><p>这些信息可以通过在线网站 <a href="http://useragentstring.com/" target="_blank" rel="noopener">http://useragentstring.com/</a> 进行查询。</p><h1 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h1><p>fake-useragent 会将数据缓存在系统的临时目下，例如 Linux 的 <code>/tmp</code>。</p><p>可在 python 脚本中随时更新本地缓存的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line">ua.update()</span><br></pre></td></tr></table></figure><p>如果不想将数据缓存到本地，可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(cache = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>如果  <a href="http://useragentstring.com/" target="_blank" rel="noopener">useragentstring.com</a> 或者 <a href="https://www.w3schools.com/browsers/browsers_stats.asp" target="_blank" rel="noopener">w3schools.com</a> 改变或者关闭了它们的资源，fake-useragent 会使用备用的 <a href="https://fake-useragent.herokuapp.com/browsers/0.1.8" target="_blank" rel="noopener">heroku</a>。</p><p>如果你不想使用托管的缓存服务器（此设置在0.1.5版本添加），可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(use_cache_server = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>在极少数情况下，如果托管的缓存服务器和数据源都不可用，fake-useragent 将不会下载任何数据（版本0.1.3添加）。此时调用 <code>UserAgent()</code> 会抛出 <code>fake_useragent.errors.FakeUserAgentError</code> 错误，可再次尝试。</p><p>你可以自定义数据缓存的路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version = fake_useragent.VERSION</span></span><br><span class="line">ua = UserAgent(path = <span class="string">"/path/to/xxx.json"</span>)</span><br></pre></td></tr></table></figure><p>如遇报错可尝试更新 fake-useragent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U fake-useragent</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>项目地址：<a href="https://github.com/hellysmile/fake-useragent" target="_blank" rel="noopener">https://github.com/hellysmile/fake-useragent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;UserAgent&lt;/strong&gt; 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。&lt;/p&gt;
&lt;p&gt;更换 UserAgent 可以避免触发某些反爬机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fake-useragent&lt;/code&gt; 是用来为爬虫提供 UserAgent 的第三方包。&lt;/p&gt;
    
    </summary>
    
      <category term="spider" scheme="http://chenyin.top/categories/spider/"/>
    
    
  </entry>
  
  <entry>
    <title>在线获取UserAgent</title>
    <link href="http://chenyin.top/spider/20200927-204d.html"/>
    <id>http://chenyin.top/spider/20200927-204d.html</id>
    <published>2020-09-27T06:56:39.000Z</published>
    <updated>2020-09-27T07:17:02.750Z</updated>
    
    <content type="html"><![CDATA[<p><strong>UserAgent</strong> 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。</p><p>更换 UserAgent 可以避免触发某些反爬机制。</p><p><code>fake-useragent</code> 是用来为爬虫提供 UserAgent 的第三方包。</p><a id="more"></a><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>使用 <code>pip install fake-useragent</code> 安装 <strong>fake-useragent</strong> 这个包，如果网络错误，就多试几次。</p><p>使用 <code>import fake_useragent</code> 导入。一般地，我们只需要 <code>from fake_useragent import UserAgent</code> 即可。</p><p>fake-useragent 的API 十分简单：</p><ul><li><code>UserAgent().random</code> 即可获取一个随机的 UserAgent（一般用这个就行了）</li><li>获取子项的值：<code>.ie</code>, <code>.msie</code>, <code>[&#39;Internet Explore&#39;]</code>, <code>opera</code>, <code>chrome</code>, <code>google</code>, <code>[&#39;google chrome&#39;]</code>, <code>firefox</code>, <code>ff</code>, <code>safari</code></li></ul><p>下面是一个典型的 UserAgent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36</span><br></pre></td></tr></table></figure><p>其每个字段的含义是：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200927115718838.png" alt="image-20200927115718838" style="zoom: 67%;"></p><p>这些信息可以通过在线网站 <a href="http://useragentstring.com/" target="_blank" rel="noopener">http://useragentstring.com/</a> 进行查询。</p><h1 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h1><p>fake-useragent 会将数据缓存在系统的临时目下，例如 Linux 的 <code>/tmp</code>。</p><p>可在 python 脚本中随时更新本地缓存的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line">ua.update()</span><br></pre></td></tr></table></figure><p>如果不想将数据缓存到本地，可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(cache = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>如果  <a href="http://useragentstring.com/" target="_blank" rel="noopener">useragentstring.com</a> 或者 <a href="https://www.w3schools.com/browsers/browsers_stats.asp" target="_blank" rel="noopener">w3schools.com</a> 改变或者关闭了它们的资源，fake-useragent 会使用备用的 <a href="https://fake-useragent.herokuapp.com/browsers/0.1.8" target="_blank" rel="noopener">heroku</a>。</p><p>如果你不想使用托管的缓存服务器（此设置在0.1.5版本添加），可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(use_cache_server = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>在极少数情况下，如果托管的缓存服务器和数据源都不可用，fake-useragent 将不会下载任何数据（版本0.1.3添加）。此时调用 <code>UserAgent()</code> 会抛出 <code>fake_useragent.errors.FakeUserAgentError</code> 错误，可再次尝试。</p><p>你可以自定义数据缓存的路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version = fake_useragent.VERSION</span></span><br><span class="line">ua = UserAgent(path = <span class="string">"/path/to/xxx.json"</span>)</span><br></pre></td></tr></table></figure><p>如遇报错可尝试更新 fake-useragent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U fake-useragent</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>项目地址：<a href="https://github.com/hellysmile/fake-useragent" target="_blank" rel="noopener">https://github.com/hellysmile/fake-useragent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;UserAgent&lt;/strong&gt; 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。&lt;/p&gt;
&lt;p&gt;更换 UserAgent 可以避免触发某些反爬机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fake-useragent&lt;/code&gt; 是用来为爬虫提供 UserAgent 的第三方包。&lt;/p&gt;
    
    </summary>
    
      <category term="spider" scheme="http://chenyin.top/categories/spider/"/>
    
    
  </entry>
  
  <entry>
    <title>在线获取UserAgent</title>
    <link href="http://chenyin.top/spider/20200927-204d.html"/>
    <id>http://chenyin.top/spider/20200927-204d.html</id>
    <published>2020-09-27T06:56:39.000Z</published>
    <updated>2020-09-27T07:17:02.753Z</updated>
    
    <content type="html"><![CDATA[<p><strong>UserAgent</strong> 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。</p><p>更换 UserAgent 可以避免触发某些反爬机制。</p><p><code>fake-useragent</code> 是用来为爬虫提供 UserAgent 的第三方包。</p><a id="more"></a><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>使用 <code>pip install fake-useragent</code> 安装 <strong>fake-useragent</strong> 这个包，如果网络错误，就多试几次。</p><p>使用 <code>import fake_useragent</code> 导入。一般地，我们只需要 <code>from fake_useragent import UserAgent</code> 即可。</p><p>fake-useragent 的API 十分简单：</p><ul><li><code>UserAgent().random</code> 即可获取一个随机的 UserAgent（一般用这个就行了）</li><li>获取子项的值：<code>.ie</code>, <code>.msie</code>, <code>[&#39;Internet Explore&#39;]</code>, <code>opera</code>, <code>chrome</code>, <code>google</code>, <code>[&#39;google chrome&#39;]</code>, <code>firefox</code>, <code>ff</code>, <code>safari</code></li></ul><p>下面是一个典型的 UserAgent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36</span><br></pre></td></tr></table></figure><p>其每个字段的含义是：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200927115718838.png" alt="image-20200927115718838" style="zoom: 67%;"></p><p>这些信息可以通过在线网站 <a href="http://useragentstring.com/" target="_blank" rel="noopener">http://useragentstring.com/</a> 进行查询。</p><h1 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h1><p>fake-useragent 会将数据缓存在系统的临时目下，例如 Linux 的 <code>/tmp</code>。</p><p>可在 python 脚本中随时更新本地缓存的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line">ua.update()</span><br></pre></td></tr></table></figure><p>如果不想将数据缓存到本地，可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(cache = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>如果  <a href="http://useragentstring.com/" target="_blank" rel="noopener">useragentstring.com</a> 或者 <a href="https://www.w3schools.com/browsers/browsers_stats.asp" target="_blank" rel="noopener">w3schools.com</a> 改变或者关闭了它们的资源，fake-useragent 会使用备用的 <a href="https://fake-useragent.herokuapp.com/browsers/0.1.8" target="_blank" rel="noopener">heroku</a>。</p><p>如果你不想使用托管的缓存服务器（此设置在0.1.5版本添加），可设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua = UserAgent(use_cache_server = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>在极少数情况下，如果托管的缓存服务器和数据源都不可用，fake-useragent 将不会下载任何数据（版本0.1.3添加）。此时调用 <code>UserAgent()</code> 会抛出 <code>fake_useragent.errors.FakeUserAgentError</code> 错误，可再次尝试。</p><p>你可以自定义数据缓存的路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version = fake_useragent.VERSION</span></span><br><span class="line">ua = UserAgent(path = <span class="string">"/path/to/xxx.json"</span>)</span><br></pre></td></tr></table></figure><p>如遇报错可尝试更新 fake-useragent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U fake-useragent</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>项目地址：<a href="https://github.com/hellysmile/fake-useragent" target="_blank" rel="noopener">https://github.com/hellysmile/fake-useragent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;UserAgent&lt;/strong&gt; 让你的爬虫以（冒充）浏览器的身份向服务器请求数据。&lt;/p&gt;
&lt;p&gt;更换 UserAgent 可以避免触发某些反爬机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fake-useragent&lt;/code&gt; 是用来为爬虫提供 UserAgent 的第三方包。&lt;/p&gt;
    
    </summary>
    
      <category term="spider" scheme="http://chenyin.top/categories/spider/"/>
    
    
  </entry>
  
  <entry>
    <title>2G用户怎么装SnapATAC</title>
    <link href="http://chenyin.top/R/20200903-2dec.html"/>
    <id>http://chenyin.top/R/20200903-2dec.html</id>
    <published>2020-09-03T06:42:29.000Z</published>
    <updated>2020-09-16T15:19:45.657Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用<code>devtools::install_github</code>还是用<code>biocManager::install</code>都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~</p><a id="more"></a><p>首先SnapATAC为什么下载这么慢？</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903144834192.png" alt="image-20200903144834192"></p><p>看github上的源码结构我们可以发现作者其实是把代码和数据混在一起，下载数据时经常卡死。</p><p>所以解决方法很简单，我们只下源码，不下demo数据。故而，这里我们排除下载 <strong>data</strong>, <strong>examples</strong>, <strong>images</strong> 和 <strong>inst/extdata</strong> 这四个目录。怎么做呢？</p><p>安装一个叫做 <strong>GitZip</strong> 的chrome插件，这个插件实现了从github项目中下载部分文件或者目录的功能。</p><blockquote><p><a href="https://www.extfans.com/" target="_blank" rel="noopener">扩展迷</a> 上可下载插件：<a href="https://www.extfans.com/" target="_blank" rel="noopener">https://www.extfans.com/</a></p></blockquote><p>安装完成之后双击想要下载的目录或者文件名称后的空白部分标记想要下载的目录或者文件，点击右下角的下载按钮即可。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903145426408.png" alt="image-20200903145426408"></p><p>点击下载后会保存到本地，压缩包名为 <strong>SnapATAC-.zip</strong>，解压并重命名目录为 <strong>SnapATAC</strong>。</p><blockquote><p>已经整理好的源码：<a href="https://barwe.lanzous.com/insiGgbf7ba" target="_blank" rel="noopener">https://barwe.lanzous.com/insiGgbf7ba</a></p></blockquote><p>打开cmd并进入到解压目录所在的目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD build SnapATAC</span><br></pre></td></tr></table></figure><p>这一步编译SnapATAC并生成一个压缩包 <strong>SnapATAC_x.x.x.tar.gz</strong>，其中 x.x.x 是版本号。</p><p>然后继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD INSTALL SnapATAC_x.x.x.tar.gz</span><br></pre></td></tr></table></figure><p>如果提示缺少依赖就先装好依赖~</p><p>大功告成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用&lt;code&gt;devtools::install_github&lt;/code&gt;还是用&lt;code&gt;biocManager::install&lt;/code&gt;都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>2G用户怎么装SnapATAC</title>
    <link href="http://chenyin.top/R/20200903-2dec.html"/>
    <id>http://chenyin.top/R/20200903-2dec.html</id>
    <published>2020-09-03T06:42:29.000Z</published>
    <updated>2020-09-27T07:11:33.074Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用<code>devtools::install_github</code>还是用<code>biocManager::install</code>都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~</p><a id="more"></a><p>首先SnapATAC为什么下载这么慢？</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903144834192.png" alt="image-20200903144834192"></p><p>看github上的源码结构我们可以发现作者其实是把代码和数据混在一起，下载数据时经常卡死。</p><p>所以解决方法很简单，我们只下源码，不下demo数据。故而，这里我们排除下载 <strong>data</strong>, <strong>examples</strong>, <strong>images</strong> 和 <strong>inst/extdata</strong> 这四个目录。怎么做呢？</p><p>安装一个叫做 <strong>GitZip</strong> 的chrome插件，这个插件实现了从github项目中下载部分文件或者目录的功能。</p><blockquote><p><a href="https://www.extfans.com/" target="_blank" rel="noopener">扩展迷</a> 上可下载插件：<a href="https://www.extfans.com/" target="_blank" rel="noopener">https://www.extfans.com/</a></p></blockquote><p>安装完成之后双击想要下载的目录或者文件名称后的空白部分标记想要下载的目录或者文件，点击右下角的下载按钮即可。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903145426408.png" alt="image-20200903145426408"></p><p>点击下载后会保存到本地，压缩包名为 <strong>SnapATAC-.zip</strong>，解压并重命名目录为 <strong>SnapATAC</strong>。</p><blockquote><p>已经整理好的源码：<a href="https://barwe.lanzous.com/insiGgbf7ba" target="_blank" rel="noopener">https://barwe.lanzous.com/insiGgbf7ba</a></p></blockquote><p>打开cmd并进入到解压目录所在的目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD build SnapATAC</span><br></pre></td></tr></table></figure><p>这一步编译SnapATAC并生成一个压缩包 <strong>SnapATAC_x.x.x.tar.gz</strong>，其中 x.x.x 是版本号。</p><p>然后继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD INSTALL SnapATAC_x.x.x.tar.gz</span><br></pre></td></tr></table></figure><p>如果提示缺少依赖就先装好依赖~</p><p>大功告成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用&lt;code&gt;devtools::install_github&lt;/code&gt;还是用&lt;code&gt;biocManager::install&lt;/code&gt;都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>2G用户怎么装SnapATAC</title>
    <link href="http://chenyin.top/R/20200903-2dec.html"/>
    <id>http://chenyin.top/R/20200903-2dec.html</id>
    <published>2020-09-03T06:42:29.000Z</published>
    <updated>2020-09-27T07:12:29.613Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用<code>devtools::install_github</code>还是用<code>biocManager::install</code>都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~</p><a id="more"></a><p>首先SnapATAC为什么下载这么慢？</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903144834192.png" alt="image-20200903144834192"></p><p>看github上的源码结构我们可以发现作者其实是把代码和数据混在一起，下载数据时经常卡死。</p><p>所以解决方法很简单，我们只下源码，不下demo数据。故而，这里我们排除下载 <strong>data</strong>, <strong>examples</strong>, <strong>images</strong> 和 <strong>inst/extdata</strong> 这四个目录。怎么做呢？</p><p>安装一个叫做 <strong>GitZip</strong> 的chrome插件，这个插件实现了从github项目中下载部分文件或者目录的功能。</p><blockquote><p><a href="https://www.extfans.com/" target="_blank" rel="noopener">扩展迷</a> 上可下载插件：<a href="https://www.extfans.com/" target="_blank" rel="noopener">https://www.extfans.com/</a></p></blockquote><p>安装完成之后双击想要下载的目录或者文件名称后的空白部分标记想要下载的目录或者文件，点击右下角的下载按钮即可。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200903145426408.png" alt="image-20200903145426408"></p><p>点击下载后会保存到本地，压缩包名为 <strong>SnapATAC-.zip</strong>，解压并重命名目录为 <strong>SnapATAC</strong>。</p><blockquote><p>已经整理好的源码：<a href="https://barwe.lanzous.com/insiGgbf7ba" target="_blank" rel="noopener">https://barwe.lanzous.com/insiGgbf7ba</a></p></blockquote><p>打开cmd并进入到解压目录所在的目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD build SnapATAC</span><br></pre></td></tr></table></figure><p>这一步编译SnapATAC并生成一个压缩包 <strong>SnapATAC_x.x.x.tar.gz</strong>，其中 x.x.x 是版本号。</p><p>然后继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R CMD INSTALL SnapATAC_x.x.x.tar.gz</span><br></pre></td></tr></table></figure><p>如果提示缺少依赖就先装好依赖~</p><p>大功告成~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级R到4.0版本，遂重新安装分析需要的包。大部分包都很顺利，唯独这个SnapATAC，从Rstudio中不管是用&lt;code&gt;devtools::install_github&lt;/code&gt;还是用&lt;code&gt;biocManager::install&lt;/code&gt;都不响应，等一段时间就timeout了。经过挠头皮思考之后，找到了一种安装方法。适合访问github速度慢或者从github下载源码速度慢的小可爱。想想还是挺有意思的，遂记下来以供参考~&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>实用的conda换源教程</title>
    <link href="http://chenyin.top/python/20200827-862f.html"/>
    <id>http://chenyin.top/python/20200827-862f.html</id>
    <published>2020-08-27T01:36:57.000Z</published>
    <updated>2020-08-27T01:49:24.561Z</updated>
    
    <content type="html"><![CDATA[<p>官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。</p><p>因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。</p><a id="more"></a><p>这里推荐使用清华大学提供的conda源，亲测好使。</p><p>在用户目录（linux为<code>/home/USER/</code>，windows为<code>C:\Users\USER\</code>）下新建 <strong>.condarc</strong> 文件，并改成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show_channel_urls: true</span><br><span class="line">channel_priority: disabled</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">  - default</span><br></pre></td></tr></table></figure><blockquote><p>windows下不允许新建没有文件名的文件（即以点号开头的文件），有以下几种解决办法：</p><ul><li>在cmd中使用 <code>conda config --set show_channel_urls yes</code> 会自动生成.condarc文件</li><li>使用模拟bash环境（例如git-bash或者msys2等）新建：<code>touch .condarc</code></li><li>使用cmd下载：wget <a href="https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc" target="_blank" rel="noopener">https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc</a></li></ul></blockquote><p>换源后需要重启cmd或者terminal才能使用新的源。</p><p><strong>操作源的其它命令</strong></p><p>查看当前使用的源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br><span class="line">conda config --show-sources</span><br></pre></td></tr></table></figure><p>重置为默认源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><p>手动添加一个源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><hr><p>另外，中科大也提供了源，但是在我电脑上不咋好使，用清华源足矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。&lt;/p&gt;
&lt;p&gt;因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>实用的conda换源教程</title>
    <link href="http://chenyin.top/python/20200827-862f.html"/>
    <id>http://chenyin.top/python/20200827-862f.html</id>
    <published>2020-08-27T01:36:57.000Z</published>
    <updated>2020-09-27T07:11:33.059Z</updated>
    
    <content type="html"><![CDATA[<p>官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。</p><p>因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。</p><a id="more"></a><p>这里推荐使用清华大学提供的conda源，亲测好使。</p><p>在用户目录（linux为<code>/home/USER/</code>，windows为<code>C:\Users\USER\</code>）下新建 <strong>.condarc</strong> 文件，并改成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show_channel_urls: true</span><br><span class="line">channel_priority: disabled</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">  - default</span><br></pre></td></tr></table></figure><blockquote><p>windows下不允许新建没有文件名的文件（即以点号开头的文件），有以下几种解决办法：</p><ul><li>在cmd中使用 <code>conda config --set show_channel_urls yes</code> 会自动生成.condarc文件</li><li>使用模拟bash环境（例如git-bash或者msys2等）新建：<code>touch .condarc</code></li><li>使用cmd下载：wget <a href="https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc" target="_blank" rel="noopener">https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc</a></li></ul></blockquote><p>换源后需要重启cmd或者terminal才能使用新的源。</p><p><strong>操作源的其它命令</strong></p><p>查看当前使用的源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br><span class="line">conda config --show-sources</span><br></pre></td></tr></table></figure><p>重置为默认源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><p>手动添加一个源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><hr><p>另外，中科大也提供了源，但是在我电脑上不咋好使，用清华源足矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。&lt;/p&gt;
&lt;p&gt;因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>实用的conda换源教程</title>
    <link href="http://chenyin.top/python/20200827-862f.html"/>
    <id>http://chenyin.top/python/20200827-862f.html</id>
    <published>2020-08-27T01:36:57.000Z</published>
    <updated>2020-09-27T07:12:29.594Z</updated>
    
    <content type="html"><![CDATA[<p>官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。</p><p>因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。</p><a id="more"></a><p>这里推荐使用清华大学提供的conda源，亲测好使。</p><p>在用户目录（linux为<code>/home/USER/</code>，windows为<code>C:\Users\USER\</code>）下新建 <strong>.condarc</strong> 文件，并改成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show_channel_urls: true</span><br><span class="line">channel_priority: disabled</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">  - default</span><br></pre></td></tr></table></figure><blockquote><p>windows下不允许新建没有文件名的文件（即以点号开头的文件），有以下几种解决办法：</p><ul><li>在cmd中使用 <code>conda config --set show_channel_urls yes</code> 会自动生成.condarc文件</li><li>使用模拟bash环境（例如git-bash或者msys2等）新建：<code>touch .condarc</code></li><li>使用cmd下载：wget <a href="https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc" target="_blank" rel="noopener">https://barwe.oss-cn-shenzhen.aliyuncs.com/config/.condarc</a></li></ul></blockquote><p>换源后需要重启cmd或者terminal才能使用新的源。</p><p><strong>操作源的其它命令</strong></p><p>查看当前使用的源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br><span class="line">conda config --show-sources</span><br></pre></td></tr></table></figure><p>重置为默认源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><p>手动添加一个源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><hr><p>另外，中科大也提供了源，但是在我电脑上不咋好使，用清华源足矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方的默认源在下载某些包（例如pytorch）时实在是太慢了，建议在新建一个虚拟环境前就换源。&lt;/p&gt;
&lt;p&gt;因为不同源的包的默认版本可能不一致，如果中途换源可能会导致许多不必要的麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>将SpaceSniffer添加到右键菜单</title>
    <link href="http://chenyin.top/os/20200818-7e4.html"/>
    <id>http://chenyin.top/os/20200818-7e4.html</id>
    <published>2020-08-18T03:17:50.000Z</published>
    <updated>2020-08-18T03:47:41.683Z</updated>
    
    <content type="html"><![CDATA[<p>SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png" alt="image-20200818102942470"></p><a id="more"></a><p>这里介绍怎么把应用添加到目录的右键菜单，使得我们可以在任意目录上右键分析这个目录的磁盘空间。效果如下：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818103202292.png" alt="image-20200818103202292"></p><h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p>这是一个绿色包，所以不需要安装 ~</p><p>链接：<a href="https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ" target="_blank" rel="noopener">https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ</a>  提取码：83vc</p><h1 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h1><p>直接打开 <strong>SpaceSniffer.exe</strong> 即可。</p><p>需要注意的是，如果待分析的目录中包含需要管理员权限操作的子目录或者子文件，需要以管理员身份启动软件才能正常分析，否则会抛出警告。</p><p>启动后依次点击 <strong>Help &gt; command line help</strong> 可以查看命令行帮助文档：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818111934093.png" alt="image-20200818111934093"></p><p>我们的任意目录右键分析洗盘空间需要用到这个。</p><p>观察一下，<strong>scan</strong> 参数可以指定我们想要分析的目录，如果是在右键上，我们应该通过变量实时获取目标目录。</p><h1 id="添加右键入口"><a href="#添加右键入口" class="headerlink" title="添加右键入口"></a>添加右键入口</h1><ol><li><p>首先我们需要一个默认以管理员权限启动的 <strong>cmd.exe</strong>，cmd.exe 一般位于 <strong>C:\WINDOWS\system32</strong> 下，找到它然后复制一个新的程序并重命名为 cmda.exe<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104334121.png" alt="image-20200818104334121"></p></li><li><p>右键这个 <strong>cmda.exe</strong>，依次点击 <strong>属性 &gt; 兼容性</strong>，勾选 <strong>以管理员身份运行此程序</strong>，然后 <strong>确定</strong>，记下这个 cmda.exe 的路径 <strong>C:\WINDOWS\system32\cmda.exe</strong><br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104535249.png" alt="image-20200818104535249"></p></li><li><p>打开注册表编辑器（<strong>win + r</strong> 然后输入 <strong>regedit</strong> 确定），定位到 <strong>HKEY_CLASSES_ROOT\Directory\shell</strong>，这个文件夹代表了 <strong>一般目录的右键菜单</strong>：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104855632.png" alt="image-20200818104855632"><br> 可以看到我这里已经添加了四个入口，分别是 cmder, find, git bash 和将要添加的 SpaceSniffer</p></li><li>右键 <strong>shell</strong>，新建 <strong>项</strong>，取名为 SpaceSniffer</li><li><p>修改 SpaceSniffer 项的 <strong>(默认)</strong> 为 <strong>使用 SpaceSniffer 分析这个目录的磁盘空间</strong>，这个字符串将出现在你的右键菜单中，可个性化修改；在 <strong>(默认)</strong> 值的同级环境中右键依次点击 <strong>新建值 &gt; 字符串值</strong>，取名为 <strong>Icon</strong>。双击 Icon，修改其值为 SpaceSniffer.exe 程序的路径；最后再新建一个 <strong>项</strong>，取名为 <strong>command</strong>。最终效果如下：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818105751882.png" alt="image-20200818105751882"></p></li><li><p>双击 command 项，修改其默认值为 <strong>“C:\WINDOWS\system32\cmda.exe” “/C start D:\Portable\spacesniffer\SpaceSniffer.exe scan %1”</strong>：</p><ul><li><strong>/C</strong> 表示执行其它程序</li><li><strong>start</strong> 不会显示cmd的黑黢黢的窗口</li><li><strong>scan 路径</strong> 作为 SpaceSniffer.exe 的参数</li><li><strong>%1</strong> 变量动态获取当前目录路径</li></ul></li></ol><p>真香 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png&quot; alt=&quot;image-20200818102942470&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>将SpaceSniffer添加到右键菜单</title>
    <link href="http://chenyin.top/os/20200818-7e4.html"/>
    <id>http://chenyin.top/os/20200818-7e4.html</id>
    <published>2020-08-18T03:17:50.000Z</published>
    <updated>2020-09-27T07:11:33.012Z</updated>
    
    <content type="html"><![CDATA[<p>SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png" alt="image-20200818102942470"></p><a id="more"></a><p>这里介绍怎么把应用添加到目录的右键菜单，使得我们可以在任意目录上右键分析这个目录的磁盘空间。效果如下：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818103202292.png" alt="image-20200818103202292"></p><h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p>这是一个绿色包，所以不需要安装 ~</p><p>链接：<a href="https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ" target="_blank" rel="noopener">https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ</a>  提取码：83vc</p><h1 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h1><p>直接打开 <strong>SpaceSniffer.exe</strong> 即可。</p><p>需要注意的是，如果待分析的目录中包含需要管理员权限操作的子目录或者子文件，需要以管理员身份启动软件才能正常分析，否则会抛出警告。</p><p>启动后依次点击 <strong>Help &gt; command line help</strong> 可以查看命令行帮助文档：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818111934093.png" alt="image-20200818111934093"></p><p>我们的任意目录右键分析洗盘空间需要用到这个。</p><p>观察一下，<strong>scan</strong> 参数可以指定我们想要分析的目录，如果是在右键上，我们应该通过变量实时获取目标目录。</p><h1 id="添加右键入口"><a href="#添加右键入口" class="headerlink" title="添加右键入口"></a>添加右键入口</h1><ol><li><p>首先我们需要一个默认以管理员权限启动的 <strong>cmd.exe</strong>，cmd.exe 一般位于 <strong>C:\WINDOWS\system32</strong> 下，找到它然后复制一个新的程序并重命名为 cmda.exe<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104334121.png" alt="image-20200818104334121"></p></li><li><p>右键这个 <strong>cmda.exe</strong>，依次点击 <strong>属性 &gt; 兼容性</strong>，勾选 <strong>以管理员身份运行此程序</strong>，然后 <strong>确定</strong>，记下这个 cmda.exe 的路径 <strong>C:\WINDOWS\system32\cmda.exe</strong><br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104535249.png" alt="image-20200818104535249"></p></li><li><p>打开注册表编辑器（<strong>win + r</strong> 然后输入 <strong>regedit</strong> 确定），定位到 <strong>HKEY_CLASSES_ROOT\Directory\shell</strong>，这个文件夹代表了 <strong>一般目录的右键菜单</strong>：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104855632.png" alt="image-20200818104855632"><br> 可以看到我这里已经添加了四个入口，分别是 cmder, find, git bash 和将要添加的 SpaceSniffer</p></li><li>右键 <strong>shell</strong>，新建 <strong>项</strong>，取名为 SpaceSniffer</li><li><p>修改 SpaceSniffer 项的 <strong>(默认)</strong> 为 <strong>使用 SpaceSniffer 分析这个目录的磁盘空间</strong>，这个字符串将出现在你的右键菜单中，可个性化修改；在 <strong>(默认)</strong> 值的同级环境中右键依次点击 <strong>新建值 &gt; 字符串值</strong>，取名为 <strong>Icon</strong>。双击 Icon，修改其值为 SpaceSniffer.exe 程序的路径；最后再新建一个 <strong>项</strong>，取名为 <strong>command</strong>。最终效果如下：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818105751882.png" alt="image-20200818105751882"></p></li><li><p>双击 command 项，修改其默认值为 <strong>“C:\WINDOWS\system32\cmda.exe” “/C start D:\Portable\spacesniffer\SpaceSniffer.exe scan %1”</strong>：</p><ul><li><strong>/C</strong> 表示执行其它程序</li><li><strong>start</strong> 不会显示cmd的黑黢黢的窗口</li><li><strong>scan 路径</strong> 作为 SpaceSniffer.exe 的参数</li><li><strong>%1</strong> 变量动态获取当前目录路径</li></ul></li></ol><p>真香 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png&quot; alt=&quot;image-20200818102942470&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>将SpaceSniffer添加到右键菜单</title>
    <link href="http://chenyin.top/os/20200818-7e4.html"/>
    <id>http://chenyin.top/os/20200818-7e4.html</id>
    <published>2020-08-18T03:17:50.000Z</published>
    <updated>2020-09-27T07:12:29.541Z</updated>
    
    <content type="html"><![CDATA[<p>SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png" alt="image-20200818102942470"></p><a id="more"></a><p>这里介绍怎么把应用添加到目录的右键菜单，使得我们可以在任意目录上右键分析这个目录的磁盘空间。效果如下：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818103202292.png" alt="image-20200818103202292"></p><h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p>这是一个绿色包，所以不需要安装 ~</p><p>链接：<a href="https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ" target="_blank" rel="noopener">https://pan.baidu.com/s/186OKHlF_2IJ0VsnwDhvJnQ</a>  提取码：83vc</p><h1 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h1><p>直接打开 <strong>SpaceSniffer.exe</strong> 即可。</p><p>需要注意的是，如果待分析的目录中包含需要管理员权限操作的子目录或者子文件，需要以管理员身份启动软件才能正常分析，否则会抛出警告。</p><p>启动后依次点击 <strong>Help &gt; command line help</strong> 可以查看命令行帮助文档：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818111934093.png" alt="image-20200818111934093"></p><p>我们的任意目录右键分析洗盘空间需要用到这个。</p><p>观察一下，<strong>scan</strong> 参数可以指定我们想要分析的目录，如果是在右键上，我们应该通过变量实时获取目标目录。</p><h1 id="添加右键入口"><a href="#添加右键入口" class="headerlink" title="添加右键入口"></a>添加右键入口</h1><ol><li><p>首先我们需要一个默认以管理员权限启动的 <strong>cmd.exe</strong>，cmd.exe 一般位于 <strong>C:\WINDOWS\system32</strong> 下，找到它然后复制一个新的程序并重命名为 cmda.exe<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104334121.png" alt="image-20200818104334121"></p></li><li><p>右键这个 <strong>cmda.exe</strong>，依次点击 <strong>属性 &gt; 兼容性</strong>，勾选 <strong>以管理员身份运行此程序</strong>，然后 <strong>确定</strong>，记下这个 cmda.exe 的路径 <strong>C:\WINDOWS\system32\cmda.exe</strong><br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104535249.png" alt="image-20200818104535249"></p></li><li><p>打开注册表编辑器（<strong>win + r</strong> 然后输入 <strong>regedit</strong> 确定），定位到 <strong>HKEY_CLASSES_ROOT\Directory\shell</strong>，这个文件夹代表了 <strong>一般目录的右键菜单</strong>：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818104855632.png" alt="image-20200818104855632"><br> 可以看到我这里已经添加了四个入口，分别是 cmder, find, git bash 和将要添加的 SpaceSniffer</p></li><li>右键 <strong>shell</strong>，新建 <strong>项</strong>，取名为 SpaceSniffer</li><li><p>修改 SpaceSniffer 项的 <strong>(默认)</strong> 为 <strong>使用 SpaceSniffer 分析这个目录的磁盘空间</strong>，这个字符串将出现在你的右键菜单中，可个性化修改；在 <strong>(默认)</strong> 值的同级环境中右键依次点击 <strong>新建值 &gt; 字符串值</strong>，取名为 <strong>Icon</strong>。双击 Icon，修改其值为 SpaceSniffer.exe 程序的路径；最后再新建一个 <strong>项</strong>，取名为 <strong>command</strong>。最终效果如下：<br> <img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818105751882.png" alt="image-20200818105751882"></p></li><li><p>双击 command 项，修改其默认值为 <strong>“C:\WINDOWS\system32\cmda.exe” “/C start D:\Portable\spacesniffer\SpaceSniffer.exe scan %1”</strong>：</p><ul><li><strong>/C</strong> 表示执行其它程序</li><li><strong>start</strong> 不会显示cmd的黑黢黢的窗口</li><li><strong>scan 路径</strong> 作为 SpaceSniffer.exe 的参数</li><li><strong>%1</strong> 变量动态获取当前目录路径</li></ul></li></ol><p>真香 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpaceSniffer 能够以网格形式展示指定目录的结构层次以及它的子目录和子文件的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200818102942470.png&quot; alt=&quot;image-20200818102942470&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>R-下载github源码并离线安装</title>
    <link href="http://chenyin.top/R/20200804-fcaf.html"/>
    <id>http://chenyin.top/R/20200804-fcaf.html</id>
    <published>2020-08-04T06:21:52.000Z</published>
    <updated>2020-08-18T03:22:53.232Z</updated>
    
    <content type="html"><![CDATA[<p><code>devtools::install_github</code> 虽然好用，但是有时候R不能与github通讯时就很尴尬。</p><a id="more"></a><p>在jupyter中使用R时需要安装IRkernel包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><p>但是网络似乎出现了问题，but浏览器中还是可以访问这个repo的：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200804142630369.png" alt="image-20200804142630369"></p><p>这时候可以考虑把repo克隆到本地后再离线安装。过程如下：</p><ol><li><p>下载源码：</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/IRkernel/IRkernel.git</span><br><span class="line">Cloning into <span class="string">'IRkernel'</span><span class="keyword">...</span></span><br><span class="line">remote: Enumerating objects: <span class="number">12</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">12</span>/<span class="number">12</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span><br><span class="line">remote: Total <span class="number">2359</span> (delta <span class="number">3</span>), reused <span class="number">4</span> (delta <span class="number">1</span>), pack-reused <span class="number">2347</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">2359</span>/<span class="number">2359</span>), <span class="number">694.02</span> KiB | <span class="number">30.00</span> KiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">1401</span>/<span class="number">1401</span>), done.</span><br></pre></td></tr></table></figure></li><li><p>编译：需要用到命令行编译，如果git bash中能够检测到R可以直接在git bash中编译和安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which R</span><br><span class="line">/d/Program/R/R-4.0.2/bin/R</span><br></pre></td></tr></table></figure> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD build IRkernel</span><br><span class="line">* checking <span class="keyword">for</span> file <span class="string">'IRkernel/DESCRIPTION'</span> <span class="keyword">...</span> OK</span><br><span class="line">* preparing <span class="string">'IRkernel'</span>:</span><br><span class="line">* checking DESCRIPTION meta-information <span class="keyword">...</span> OK</span><br><span class="line">* checking <span class="keyword">for</span> LF line-endings <span class="keyword">in</span> <span class="keyword">source</span> and make files and shell scripts</span><br><span class="line">* checking <span class="keyword">for</span> empty or unneeded directories</span><br><span class="line">Removed empty directory <span class="string">'IRkernel/example-notebooks'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/jkt'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/njr'</span></span><br><span class="line">* building <span class="string">'IRkernel_1.1.1.9000.tar.gz'</span></span><br></pre></td></tr></table></figure><p> 编译会生成一个以 <strong>.tar.gz</strong> 结尾的压缩包，安装它即可。</p></li><li><p>安装：需要用到命令行</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD INSTALL IRkernel_1.1.1.9000.tar.gz</span><br><span class="line">* installing to <span class="keyword">library</span> <span class="string">'D:/Program/R/R-4.0.2/library'</span></span><br><span class="line">* installing *<span class="keyword">source</span>* package <span class="string">'IRkernel'</span> <span class="keyword">...</span></span><br><span class="line">** using staged installation</span><br><span class="line">** R</span><br><span class="line">** inst</span><br><span class="line">** byte-compile and prepare package <span class="keyword">for</span> lazy loading</span><br><span class="line">** help</span><br><span class="line">*** installing help indices</span><br><span class="line">  converting help <span class="keyword">for</span> package <span class="string">'IRkernel'</span></span><br><span class="line">    finding HTML links <span class="keyword">...</span> ▒▒▒▒</span><br><span class="line">    Comm-class                              html</span><br><span class="line">    CommManager-class                       html</span><br><span class="line">    IRkernel-package                        html</span><br><span class="line">    comm_manager                            html</span><br><span class="line">    installspec                             html</span><br><span class="line">    log                                     html</span><br><span class="line">    main                                    html</span><br><span class="line">** building package indices</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from temporary location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from final location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package keeps a record of temporary installation path</span><br><span class="line">* DONE (IRkernel)</span><br><span class="line">Making <span class="string">'packages.html'</span> <span class="keyword">...</span> ▒▒▒▒</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;devtools::install_github&lt;/code&gt; 虽然好用，但是有时候R不能与github通讯时就很尴尬。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R-下载github源码并离线安装</title>
    <link href="http://chenyin.top/R/20200804-fcaf.html"/>
    <id>http://chenyin.top/R/20200804-fcaf.html</id>
    <published>2020-08-04T06:21:52.000Z</published>
    <updated>2020-09-27T07:11:33.068Z</updated>
    
    <content type="html"><![CDATA[<p><code>devtools::install_github</code> 虽然好用，但是有时候R不能与github通讯时就很尴尬。</p><a id="more"></a><p>在jupyter中使用R时需要安装IRkernel包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><p>但是网络似乎出现了问题，but浏览器中还是可以访问这个repo的：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200804142630369.png" alt="image-20200804142630369"></p><p>这时候可以考虑把repo克隆到本地后再离线安装。过程如下：</p><ol><li><p>下载源码：</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/IRkernel/IRkernel.git</span><br><span class="line">Cloning into <span class="string">'IRkernel'</span><span class="keyword">...</span></span><br><span class="line">remote: Enumerating objects: <span class="number">12</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">12</span>/<span class="number">12</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span><br><span class="line">remote: Total <span class="number">2359</span> (delta <span class="number">3</span>), reused <span class="number">4</span> (delta <span class="number">1</span>), pack-reused <span class="number">2347</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">2359</span>/<span class="number">2359</span>), <span class="number">694.02</span> KiB | <span class="number">30.00</span> KiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">1401</span>/<span class="number">1401</span>), done.</span><br></pre></td></tr></table></figure></li><li><p>编译：需要用到命令行编译，如果git bash中能够检测到R可以直接在git bash中编译和安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which R</span><br><span class="line">/d/Program/R/R-4.0.2/bin/R</span><br></pre></td></tr></table></figure> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD build IRkernel</span><br><span class="line">* checking <span class="keyword">for</span> file <span class="string">'IRkernel/DESCRIPTION'</span> <span class="keyword">...</span> OK</span><br><span class="line">* preparing <span class="string">'IRkernel'</span>:</span><br><span class="line">* checking DESCRIPTION meta-information <span class="keyword">...</span> OK</span><br><span class="line">* checking <span class="keyword">for</span> LF line-endings <span class="keyword">in</span> <span class="keyword">source</span> and make files and shell scripts</span><br><span class="line">* checking <span class="keyword">for</span> empty or unneeded directories</span><br><span class="line">Removed empty directory <span class="string">'IRkernel/example-notebooks'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/jkt'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/njr'</span></span><br><span class="line">* building <span class="string">'IRkernel_1.1.1.9000.tar.gz'</span></span><br></pre></td></tr></table></figure><p> 编译会生成一个以 <strong>.tar.gz</strong> 结尾的压缩包，安装它即可。</p></li><li><p>安装：需要用到命令行</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD INSTALL IRkernel_1.1.1.9000.tar.gz</span><br><span class="line">* installing to <span class="keyword">library</span> <span class="string">'D:/Program/R/R-4.0.2/library'</span></span><br><span class="line">* installing *<span class="keyword">source</span>* package <span class="string">'IRkernel'</span> <span class="keyword">...</span></span><br><span class="line">** using staged installation</span><br><span class="line">** R</span><br><span class="line">** inst</span><br><span class="line">** byte-compile and prepare package <span class="keyword">for</span> lazy loading</span><br><span class="line">** help</span><br><span class="line">*** installing help indices</span><br><span class="line">  converting help <span class="keyword">for</span> package <span class="string">'IRkernel'</span></span><br><span class="line">    finding HTML links <span class="keyword">...</span> ▒▒▒▒</span><br><span class="line">    Comm-class                              html</span><br><span class="line">    CommManager-class                       html</span><br><span class="line">    IRkernel-package                        html</span><br><span class="line">    comm_manager                            html</span><br><span class="line">    installspec                             html</span><br><span class="line">    log                                     html</span><br><span class="line">    main                                    html</span><br><span class="line">** building package indices</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from temporary location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from final location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package keeps a record of temporary installation path</span><br><span class="line">* DONE (IRkernel)</span><br><span class="line">Making <span class="string">'packages.html'</span> <span class="keyword">...</span> ▒▒▒▒</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;devtools::install_github&lt;/code&gt; 虽然好用，但是有时候R不能与github通讯时就很尴尬。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R-下载github源码并离线安装</title>
    <link href="http://chenyin.top/R/20200804-fcaf.html"/>
    <id>http://chenyin.top/R/20200804-fcaf.html</id>
    <published>2020-08-04T06:21:52.000Z</published>
    <updated>2020-09-27T07:12:29.605Z</updated>
    
    <content type="html"><![CDATA[<p><code>devtools::install_github</code> 虽然好用，但是有时候R不能与github通讯时就很尴尬。</p><a id="more"></a><p>在jupyter中使用R时需要安装IRkernel包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><p>但是网络似乎出现了问题，but浏览器中还是可以访问这个repo的：</p><p><img src="https://barwe.oss-cn-shenzhen.aliyuncs.com/typora/image-20200804142630369.png" alt="image-20200804142630369"></p><p>这时候可以考虑把repo克隆到本地后再离线安装。过程如下：</p><ol><li><p>下载源码：</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/IRkernel/IRkernel.git</span><br><span class="line">Cloning into <span class="string">'IRkernel'</span><span class="keyword">...</span></span><br><span class="line">remote: Enumerating objects: <span class="number">12</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">12</span>/<span class="number">12</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">11</span>/<span class="number">11</span>), done.</span><br><span class="line">remote: Total <span class="number">2359</span> (delta <span class="number">3</span>), reused <span class="number">4</span> (delta <span class="number">1</span>), pack-reused <span class="number">2347</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">2359</span>/<span class="number">2359</span>), <span class="number">694.02</span> KiB | <span class="number">30.00</span> KiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">1401</span>/<span class="number">1401</span>), done.</span><br></pre></td></tr></table></figure></li><li><p>编译：需要用到命令行编译，如果git bash中能够检测到R可以直接在git bash中编译和安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which R</span><br><span class="line">/d/Program/R/R-4.0.2/bin/R</span><br></pre></td></tr></table></figure> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD build IRkernel</span><br><span class="line">* checking <span class="keyword">for</span> file <span class="string">'IRkernel/DESCRIPTION'</span> <span class="keyword">...</span> OK</span><br><span class="line">* preparing <span class="string">'IRkernel'</span>:</span><br><span class="line">* checking DESCRIPTION meta-information <span class="keyword">...</span> OK</span><br><span class="line">* checking <span class="keyword">for</span> LF line-endings <span class="keyword">in</span> <span class="keyword">source</span> and make files and shell scripts</span><br><span class="line">* checking <span class="keyword">for</span> empty or unneeded directories</span><br><span class="line">Removed empty directory <span class="string">'IRkernel/example-notebooks'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/jkt'</span></span><br><span class="line">Removed empty directory <span class="string">'IRkernel/tests/testthat/njr'</span></span><br><span class="line">* building <span class="string">'IRkernel_1.1.1.9000.tar.gz'</span></span><br></pre></td></tr></table></figure><p> 编译会生成一个以 <strong>.tar.gz</strong> 结尾的压缩包，安装它即可。</p></li><li><p>安装：需要用到命令行</p> <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ R CMD INSTALL IRkernel_1.1.1.9000.tar.gz</span><br><span class="line">* installing to <span class="keyword">library</span> <span class="string">'D:/Program/R/R-4.0.2/library'</span></span><br><span class="line">* installing *<span class="keyword">source</span>* package <span class="string">'IRkernel'</span> <span class="keyword">...</span></span><br><span class="line">** using staged installation</span><br><span class="line">** R</span><br><span class="line">** inst</span><br><span class="line">** byte-compile and prepare package <span class="keyword">for</span> lazy loading</span><br><span class="line">** help</span><br><span class="line">*** installing help indices</span><br><span class="line">  converting help <span class="keyword">for</span> package <span class="string">'IRkernel'</span></span><br><span class="line">    finding HTML links <span class="keyword">...</span> ▒▒▒▒</span><br><span class="line">    Comm-class                              html</span><br><span class="line">    CommManager-class                       html</span><br><span class="line">    IRkernel-package                        html</span><br><span class="line">    comm_manager                            html</span><br><span class="line">    installspec                             html</span><br><span class="line">    log                                     html</span><br><span class="line">    main                                    html</span><br><span class="line">** building package indices</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from temporary location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package can be loaded from final location</span><br><span class="line">*** arch - i386</span><br><span class="line">*** arch - x64</span><br><span class="line">** testing <span class="keyword">if</span> installed package keeps a record of temporary installation path</span><br><span class="line">* DONE (IRkernel)</span><br><span class="line">Making <span class="string">'packages.html'</span> <span class="keyword">...</span> ▒▒▒▒</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;devtools::install_github&lt;/code&gt; 虽然好用，但是有时候R不能与github通讯时就很尴尬。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>C++标准库-fstream文件流</title>
    <link href="http://chenyin.top/Cpp/20200710-111f.html"/>
    <id>http://chenyin.top/Cpp/20200710-111f.html</id>
    <published>2020-07-10T06:12:45.000Z</published>
    <updated>2020-07-10T06:23:36.945Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库 <strong>fstream</strong> 用来读写文件。</p><a id="more"></a><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>C++标准库头文件 <code>#include &lt;fstream&gt;</code> 中包含了三个重要的文件流类：</p><ul><li><strong>fstream</strong>：既可以读文件，也可以写文件</li><li><strong>ifstream</strong>：只能读文件</li><li><strong>ofstream</strong>：只能写文件</li></ul><p>文件读写的基本步骤是：</p><ol><li>初始化文件流对象：声明，例如 <code>fstream f</code> 声明了读写文件流对象f</li><li>打开文件：调用 <strong>open</strong> 方法，例如 <code>f.open(&quot;xxx.txt&quot;, ios::in)</code></li><li>读/写文件：读取内容或者写入内容</li><li>关闭文件：调用 <strong>close</strong> 方法，<code>f.close()</code></li></ol><h2 id="声明文件流对象"><a href="#声明文件流对象" class="headerlink" title="声明文件流对象"></a>声明文件流对象</h2><p>如果只是对文件进行 <strong>读</strong> 操作，请使用 <strong>ifstream</strong>；如果只是对文件进行写操作，请使用 <strong>ofstream</strong>。语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream in;</span><br><span class="line"><span class="built_in">std</span>::ofstream out;</span><br><span class="line"><span class="built_in">std</span>::fstream in_out;</span><br></pre></td></tr></table></figure><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h3 id="open-方法打开"><a href="#open-方法打开" class="headerlink" title="open 方法打开"></a>open 方法打开</h3><p><strong>open</strong> 是三个文件流类的成员方法，可被文件流对象调用以打开文件，实现文件流对象与具体文件的绑定。</p><p><strong>open</strong> 方法接收两个参数：文件路径，文件操纵模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.open(<span class="string">"xxx.txt"</span>, <span class="built_in">std</span>::ios::in);</span><br><span class="line">out.open(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">in_out.open(<span class="string">"zzz.txt"</span>, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out)</span><br></pre></td></tr></table></figure><p>读文件流对象的模式默认为 <code>ios::in</code>，可以缺省。</p><p><strong>ios标准库</strong> 内置了日常所需的文件操纵模式，包括：</p><ul><li><code>ios::in</code> 打开文件用于读取</li><li><code>ios::out</code> 打开文件用于写入</li><li><code>ios::ate</code> 文件打开后定位到末尾</li><li><code>ios::app</code> 追加模式，所有写入添加到文件末尾</li><li><code>ios::binary</code> 二进制方式</li><li><code>ios::trunc</code> 如果文件已存在则先删除文件</li></ul><p>常见的文件操纵模式组合：</p><ul><li>读取文本文件：<code>ios::in</code></li><li>读取二进制文件：<code>ios::in | ios::binary</code></li><li>写入为文本文件，文件存在时覆盖写入：<code>ios::out</code></li><li>写入为文本文件，文件存在时追加写入：<code>ios::out | ios::ate</code> 或者 <code>ios::app</code></li><li>写入为文本文件，文件存在时先删除再写入：<code>ios::out | ios::trunc</code></li><li>写入为二进制文件，文件存在时覆盖写入：<code>ios::out | ios::binary</code></li></ul><p>关于写入文件的三种情形，假设我有一个文件内容如下，想要写入的内容是 Fuzhou 和 Guangzhou：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nanjing</span><br><span class="line">Shanghai</span><br><span class="line">Shenzhen</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">文件写入方式</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:center">覆盖式</td><td><u>Fuzhou</u><br><u>Guangzhou</u><br>Shenzhen</td></tr><tr><td style="text-align:center">追加式</td><td>Nanjing<br>Shanghai<br>Shenzhen<br><u>Fuzhou</u><br><u>Guangzhou</u></td></tr><tr><td style="text-align:center">删除式</td><td><u>Fuzhou</u><br><u>Guangzhou</u></td></tr></tbody></table><h3 id="在声明时打开"><a href="#在声明时打开" class="headerlink" title="在声明时打开"></a>在声明时打开</h3><p>除了使用 <strong>open</strong> 方法，在声明文件流对象时可以直接打开文件，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"xxx.txt"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::out)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="检查文件打开是否成功"><a href="#检查文件打开是否成功" class="headerlink" title="检查文件打开是否成功"></a>检查文件打开是否成功</h3><p>通过 <code>if(in_out)</code> 来判断文件是否打开成功。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在某些编程语言中，文件流对象打开文件后又叫做 <strong>文件句柄</strong>。文件句柄本身不存储文件的内容，但我们可以从文件句柄访问整个文件的内容或者写入内容到文件。文件句柄相当于程序和文件之间的一个通道。</p><p>文件句柄的读取方法很多。</p><h3 id="逐个单词读取至string变量"><a href="#逐个单词读取至string变量" class="headerlink" title="逐个单词读取至string变量"></a>逐个单词读取至string变量</h3><p>流运算符的一个特点就是从空白符后的第一个非空白字符开始，读取到下一个空白符为止。所以只能一个单词一个单词的提取。</p><p>常见的空白符有空格、制表符、换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (in) <span class="keyword">while</span> (in &gt;&gt; x) vec.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : vec) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐行读取至string变量"><a href="#逐行读取至string变量" class="headerlink" title="逐行读取至string变量"></a>逐行读取至string变量</h3><p><strong>getline</strong> 函数可以按行（换行符分割）读取文件，并将每行的内容保存在字符串类型的变量var里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(文件句柄fh, 迭代变量var)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>🐖：var中的行字符串不包含末尾的换行符。</p><p><strong>这个getline函数从哪里来的？</strong> getline函数用于从 <strong>ifstream</strong> 中按行读取文件内容，<strong>ifstream</strong> 派生自 <strong>istream</strong>，<code>&lt;istream&gt;</code> 头文件中就定义了这个 <strong>getline</strong> 函数。</p><h3 id="逐行读取至char数组"><a href="#逐行读取至char数组" class="headerlink" title="逐行读取至char数组"></a>逐行读取至char数组</h3><p>此外，文件输入流本身也提供了一个 <strong>getline</strong> 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINE_LENGTH = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> var[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span> (in.getline(var, LINE_LENGTH)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这个 getline 方法就显得笨重了许多，我们需要先预设一个 LINE_LENGTH，这个值要比文件最长的那一行的长度还要长（假设最长行的长度为99，则这个值最小应该设置为100）。然后我们需要声明一个迭代变量var，它是一个长为 LINE_LENGTH 的 <strong>字符数组</strong>。</p><p>getline 方法的第一个参数是迭代变量，第二个参数是 LINE_LENGTH。</p><p>所以这个 getline 方法实际上是将文件的每一行读进了一个等长的字符数组里面。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="流运算符"><a href="#流运算符" class="headerlink" title="流运算符"></a>流运算符</h3><p>流运算符可以用于写入文本文件，用于二进制文件可能会产生错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line">out &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; setfill(<span class="string">'#'</span>) &lt;&lt; setiosflags(ios::left) &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="string">"barwe"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>尽管程序结束时会自动关闭打开的文件，但为了安全起见，建议手动关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">in_out.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库 &lt;strong&gt;fstream&lt;/strong&gt; 用来读写文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://chenyin.top/categories/Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++标准库-fstream文件流</title>
    <link href="http://chenyin.top/Cpp/20200710-111f.html"/>
    <id>http://chenyin.top/Cpp/20200710-111f.html</id>
    <published>2020-07-10T06:12:45.000Z</published>
    <updated>2020-09-27T07:11:32.937Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库 <strong>fstream</strong> 用来读写文件。</p><a id="more"></a><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>C++标准库头文件 <code>#include &lt;fstream&gt;</code> 中包含了三个重要的文件流类：</p><ul><li><strong>fstream</strong>：既可以读文件，也可以写文件</li><li><strong>ifstream</strong>：只能读文件</li><li><strong>ofstream</strong>：只能写文件</li></ul><p>文件读写的基本步骤是：</p><ol><li>初始化文件流对象：声明，例如 <code>fstream f</code> 声明了读写文件流对象f</li><li>打开文件：调用 <strong>open</strong> 方法，例如 <code>f.open(&quot;xxx.txt&quot;, ios::in)</code></li><li>读/写文件：读取内容或者写入内容</li><li>关闭文件：调用 <strong>close</strong> 方法，<code>f.close()</code></li></ol><h2 id="声明文件流对象"><a href="#声明文件流对象" class="headerlink" title="声明文件流对象"></a>声明文件流对象</h2><p>如果只是对文件进行 <strong>读</strong> 操作，请使用 <strong>ifstream</strong>；如果只是对文件进行写操作，请使用 <strong>ofstream</strong>。语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream in;</span><br><span class="line"><span class="built_in">std</span>::ofstream out;</span><br><span class="line"><span class="built_in">std</span>::fstream in_out;</span><br></pre></td></tr></table></figure><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h3 id="open-方法打开"><a href="#open-方法打开" class="headerlink" title="open 方法打开"></a>open 方法打开</h3><p><strong>open</strong> 是三个文件流类的成员方法，可被文件流对象调用以打开文件，实现文件流对象与具体文件的绑定。</p><p><strong>open</strong> 方法接收两个参数：文件路径，文件操纵模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.open(<span class="string">"xxx.txt"</span>, <span class="built_in">std</span>::ios::in);</span><br><span class="line">out.open(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">in_out.open(<span class="string">"zzz.txt"</span>, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out)</span><br></pre></td></tr></table></figure><p>读文件流对象的模式默认为 <code>ios::in</code>，可以缺省。</p><p><strong>ios标准库</strong> 内置了日常所需的文件操纵模式，包括：</p><ul><li><code>ios::in</code> 打开文件用于读取</li><li><code>ios::out</code> 打开文件用于写入</li><li><code>ios::ate</code> 文件打开后定位到末尾</li><li><code>ios::app</code> 追加模式，所有写入添加到文件末尾</li><li><code>ios::binary</code> 二进制方式</li><li><code>ios::trunc</code> 如果文件已存在则先删除文件</li></ul><p>常见的文件操纵模式组合：</p><ul><li>读取文本文件：<code>ios::in</code></li><li>读取二进制文件：<code>ios::in | ios::binary</code></li><li>写入为文本文件，文件存在时覆盖写入：<code>ios::out</code></li><li>写入为文本文件，文件存在时追加写入：<code>ios::out | ios::ate</code> 或者 <code>ios::app</code></li><li>写入为文本文件，文件存在时先删除再写入：<code>ios::out | ios::trunc</code></li><li>写入为二进制文件，文件存在时覆盖写入：<code>ios::out | ios::binary</code></li></ul><p>关于写入文件的三种情形，假设我有一个文件内容如下，想要写入的内容是 Fuzhou 和 Guangzhou：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nanjing</span><br><span class="line">Shanghai</span><br><span class="line">Shenzhen</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">文件写入方式</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:center">覆盖式</td><td><u>Fuzhou</u><br><u>Guangzhou</u><br>Shenzhen</td></tr><tr><td style="text-align:center">追加式</td><td>Nanjing<br>Shanghai<br>Shenzhen<br><u>Fuzhou</u><br><u>Guangzhou</u></td></tr><tr><td style="text-align:center">删除式</td><td><u>Fuzhou</u><br><u>Guangzhou</u></td></tr></tbody></table><h3 id="在声明时打开"><a href="#在声明时打开" class="headerlink" title="在声明时打开"></a>在声明时打开</h3><p>除了使用 <strong>open</strong> 方法，在声明文件流对象时可以直接打开文件，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"xxx.txt"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::out)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="检查文件打开是否成功"><a href="#检查文件打开是否成功" class="headerlink" title="检查文件打开是否成功"></a>检查文件打开是否成功</h3><p>通过 <code>if(in_out)</code> 来判断文件是否打开成功。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在某些编程语言中，文件流对象打开文件后又叫做 <strong>文件句柄</strong>。文件句柄本身不存储文件的内容，但我们可以从文件句柄访问整个文件的内容或者写入内容到文件。文件句柄相当于程序和文件之间的一个通道。</p><p>文件句柄的读取方法很多。</p><h3 id="逐个单词读取至string变量"><a href="#逐个单词读取至string变量" class="headerlink" title="逐个单词读取至string变量"></a>逐个单词读取至string变量</h3><p>流运算符的一个特点就是从空白符后的第一个非空白字符开始，读取到下一个空白符为止。所以只能一个单词一个单词的提取。</p><p>常见的空白符有空格、制表符、换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (in) <span class="keyword">while</span> (in &gt;&gt; x) vec.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : vec) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐行读取至string变量"><a href="#逐行读取至string变量" class="headerlink" title="逐行读取至string变量"></a>逐行读取至string变量</h3><p><strong>getline</strong> 函数可以按行（换行符分割）读取文件，并将每行的内容保存在字符串类型的变量var里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(文件句柄fh, 迭代变量var)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>🐖：var中的行字符串不包含末尾的换行符。</p><p><strong>这个getline函数从哪里来的？</strong> getline函数用于从 <strong>ifstream</strong> 中按行读取文件内容，<strong>ifstream</strong> 派生自 <strong>istream</strong>，<code>&lt;istream&gt;</code> 头文件中就定义了这个 <strong>getline</strong> 函数。</p><h3 id="逐行读取至char数组"><a href="#逐行读取至char数组" class="headerlink" title="逐行读取至char数组"></a>逐行读取至char数组</h3><p>此外，文件输入流本身也提供了一个 <strong>getline</strong> 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINE_LENGTH = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> var[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span> (in.getline(var, LINE_LENGTH)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这个 getline 方法就显得笨重了许多，我们需要先预设一个 LINE_LENGTH，这个值要比文件最长的那一行的长度还要长（假设最长行的长度为99，则这个值最小应该设置为100）。然后我们需要声明一个迭代变量var，它是一个长为 LINE_LENGTH 的 <strong>字符数组</strong>。</p><p>getline 方法的第一个参数是迭代变量，第二个参数是 LINE_LENGTH。</p><p>所以这个 getline 方法实际上是将文件的每一行读进了一个等长的字符数组里面。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="流运算符"><a href="#流运算符" class="headerlink" title="流运算符"></a>流运算符</h3><p>流运算符可以用于写入文本文件，用于二进制文件可能会产生错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line">out &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; setfill(<span class="string">'#'</span>) &lt;&lt; setiosflags(ios::left) &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="string">"barwe"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>尽管程序结束时会自动关闭打开的文件，但为了安全起见，建议手动关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">in_out.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库 &lt;strong&gt;fstream&lt;/strong&gt; 用来读写文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://chenyin.top/categories/Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++标准库-fstream文件流</title>
    <link href="http://chenyin.top/Cpp/20200710-111f.html"/>
    <id>http://chenyin.top/Cpp/20200710-111f.html</id>
    <published>2020-07-10T06:12:45.000Z</published>
    <updated>2020-09-27T07:12:29.476Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库 <strong>fstream</strong> 用来读写文件。</p><a id="more"></a><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>C++标准库头文件 <code>#include &lt;fstream&gt;</code> 中包含了三个重要的文件流类：</p><ul><li><strong>fstream</strong>：既可以读文件，也可以写文件</li><li><strong>ifstream</strong>：只能读文件</li><li><strong>ofstream</strong>：只能写文件</li></ul><p>文件读写的基本步骤是：</p><ol><li>初始化文件流对象：声明，例如 <code>fstream f</code> 声明了读写文件流对象f</li><li>打开文件：调用 <strong>open</strong> 方法，例如 <code>f.open(&quot;xxx.txt&quot;, ios::in)</code></li><li>读/写文件：读取内容或者写入内容</li><li>关闭文件：调用 <strong>close</strong> 方法，<code>f.close()</code></li></ol><h2 id="声明文件流对象"><a href="#声明文件流对象" class="headerlink" title="声明文件流对象"></a>声明文件流对象</h2><p>如果只是对文件进行 <strong>读</strong> 操作，请使用 <strong>ifstream</strong>；如果只是对文件进行写操作，请使用 <strong>ofstream</strong>。语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream in;</span><br><span class="line"><span class="built_in">std</span>::ofstream out;</span><br><span class="line"><span class="built_in">std</span>::fstream in_out;</span><br></pre></td></tr></table></figure><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h3 id="open-方法打开"><a href="#open-方法打开" class="headerlink" title="open 方法打开"></a>open 方法打开</h3><p><strong>open</strong> 是三个文件流类的成员方法，可被文件流对象调用以打开文件，实现文件流对象与具体文件的绑定。</p><p><strong>open</strong> 方法接收两个参数：文件路径，文件操纵模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.open(<span class="string">"xxx.txt"</span>, <span class="built_in">std</span>::ios::in);</span><br><span class="line">out.open(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::app);</span><br><span class="line">in_out.open(<span class="string">"zzz.txt"</span>, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out)</span><br></pre></td></tr></table></figure><p>读文件流对象的模式默认为 <code>ios::in</code>，可以缺省。</p><p><strong>ios标准库</strong> 内置了日常所需的文件操纵模式，包括：</p><ul><li><code>ios::in</code> 打开文件用于读取</li><li><code>ios::out</code> 打开文件用于写入</li><li><code>ios::ate</code> 文件打开后定位到末尾</li><li><code>ios::app</code> 追加模式，所有写入添加到文件末尾</li><li><code>ios::binary</code> 二进制方式</li><li><code>ios::trunc</code> 如果文件已存在则先删除文件</li></ul><p>常见的文件操纵模式组合：</p><ul><li>读取文本文件：<code>ios::in</code></li><li>读取二进制文件：<code>ios::in | ios::binary</code></li><li>写入为文本文件，文件存在时覆盖写入：<code>ios::out</code></li><li>写入为文本文件，文件存在时追加写入：<code>ios::out | ios::ate</code> 或者 <code>ios::app</code></li><li>写入为文本文件，文件存在时先删除再写入：<code>ios::out | ios::trunc</code></li><li>写入为二进制文件，文件存在时覆盖写入：<code>ios::out | ios::binary</code></li></ul><p>关于写入文件的三种情形，假设我有一个文件内容如下，想要写入的内容是 Fuzhou 和 Guangzhou：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nanjing</span><br><span class="line">Shanghai</span><br><span class="line">Shenzhen</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">文件写入方式</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:center">覆盖式</td><td><u>Fuzhou</u><br><u>Guangzhou</u><br>Shenzhen</td></tr><tr><td style="text-align:center">追加式</td><td>Nanjing<br>Shanghai<br>Shenzhen<br><u>Fuzhou</u><br><u>Guangzhou</u></td></tr><tr><td style="text-align:center">删除式</td><td><u>Fuzhou</u><br><u>Guangzhou</u></td></tr></tbody></table><h3 id="在声明时打开"><a href="#在声明时打开" class="headerlink" title="在声明时打开"></a>在声明时打开</h3><p>除了使用 <strong>open</strong> 方法，在声明文件流对象时可以直接打开文件，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"xxx.txt"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"yyy.txt"</span>, <span class="built_in">std</span>::ios::out)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="检查文件打开是否成功"><a href="#检查文件打开是否成功" class="headerlink" title="检查文件打开是否成功"></a>检查文件打开是否成功</h3><p>通过 <code>if(in_out)</code> 来判断文件是否打开成功。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在某些编程语言中，文件流对象打开文件后又叫做 <strong>文件句柄</strong>。文件句柄本身不存储文件的内容，但我们可以从文件句柄访问整个文件的内容或者写入内容到文件。文件句柄相当于程序和文件之间的一个通道。</p><p>文件句柄的读取方法很多。</p><h3 id="逐个单词读取至string变量"><a href="#逐个单词读取至string变量" class="headerlink" title="逐个单词读取至string变量"></a>逐个单词读取至string变量</h3><p>流运算符的一个特点就是从空白符后的第一个非空白字符开始，读取到下一个空白符为止。所以只能一个单词一个单词的提取。</p><p>常见的空白符有空格、制表符、换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (in) <span class="keyword">while</span> (in &gt;&gt; x) vec.push_back(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : vec) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐行读取至string变量"><a href="#逐行读取至string变量" class="headerlink" title="逐行读取至string变量"></a>逐行读取至string变量</h3><p><strong>getline</strong> 函数可以按行（换行符分割）读取文件，并将每行的内容保存在字符串类型的变量var里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(文件句柄fh, 迭代变量var)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>🐖：var中的行字符串不包含末尾的换行符。</p><p><strong>这个getline函数从哪里来的？</strong> getline函数用于从 <strong>ifstream</strong> 中按行读取文件内容，<strong>ifstream</strong> 派生自 <strong>istream</strong>，<code>&lt;istream&gt;</code> 头文件中就定义了这个 <strong>getline</strong> 函数。</p><h3 id="逐行读取至char数组"><a href="#逐行读取至char数组" class="headerlink" title="逐行读取至char数组"></a>逐行读取至char数组</h3><p>此外，文件输入流本身也提供了一个 <strong>getline</strong> 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINE_LENGTH = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> var[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span> (in.getline(var, LINE_LENGTH)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这个 getline 方法就显得笨重了许多，我们需要先预设一个 LINE_LENGTH，这个值要比文件最长的那一行的长度还要长（假设最长行的长度为99，则这个值最小应该设置为100）。然后我们需要声明一个迭代变量var，它是一个长为 LINE_LENGTH 的 <strong>字符数组</strong>。</p><p>getline 方法的第一个参数是迭代变量，第二个参数是 LINE_LENGTH。</p><p>所以这个 getline 方法实际上是将文件的每一行读进了一个等长的字符数组里面。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="流运算符"><a href="#流运算符" class="headerlink" title="流运算符"></a>流运算符</h3><p>流运算符可以用于写入文本文件，用于二进制文件可能会产生错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line">out &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; setfill(<span class="string">'#'</span>) &lt;&lt; setiosflags(ios::left) &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="string">"barwe"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>尽管程序结束时会自动关闭打开的文件，但为了安全起见，建议手动关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">in_out.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库 &lt;strong&gt;fstream&lt;/strong&gt; 用来读写文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://chenyin.top/categories/Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++标准库索引</title>
    <link href="http://chenyin.top/Cpp/20200710-e3c6.html"/>
    <id>http://chenyin.top/Cpp/20200710-e3c6.html</id>
    <published>2020-07-10T01:27:17.000Z</published>
    <updated>2020-07-10T07:51:41.425Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库总共51个头文件，按照内容可分为10个类，按照来源可分为3个类。</p><a id="more"></a><table><thead><tr><th style="text-align:center">51</th><th style="text-align:left">C++ （20）</th><th style="text-align:left">C (18)</th><th style="text-align:left">STL (13)</th></tr></thead><tbody><tr><td style="text-align:center">语言支持 (11)</td><td style="text-align:left">limits：C++数值类型特性<br>new：动态内存管理<br>typeinfo：运行时内存信息<br>exception：异常处理</td><td style="text-align:left">cstddef：C标准定义<br>climits：整型大小<br>cfloat：浮点型特性<br>cstdlib：C标准实用工具<br>cstdarg：可变参数<br>csetjmp：非局部跳转<br>csignal：C中断处理</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">输入输出 (10)</td><td style="text-align:left">iostream：标准输入输出流<br>istream：标准输入流<br>ostream：标准输出流<br>sstream：字符串流<br><a href="/Cpp/20200710-111f.html">fstream</a>：文件流<br><a href="https://baike.baidu.com/item/iomanip/3319954" target="_blank" rel="noopener">iomanip</a>：输入输出操纵器<br>ios：iostream的基类<br>iosfwd：输入输出前向声明<br>streambuf：流缓存</td><td style="text-align:left">cstdio：C标准输入输出</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">诊断功能 (3)</td><td style="text-align:left">stdexcept：异常类</td><td style="text-align:left">cassert：C断言验证<br>cerrno：C出错码</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">通用工具(4)</td><td style="text-align:left">-</td><td style="text-align:left">ctime：C时间日期</td><td style="text-align:left">utility：实用元件<br>functional：函数对象<br>memory：内存管理器</td></tr><tr><td style="text-align:center">字符串 (6)</td><td style="text-align:left">string：字符串类<br>strstream：C字符串流类</td><td style="text-align:left">cstring：C字符串<br>cctype：单字节字符类型<br>cwctype：多字节字符类型<br>cwchar：扩展多字节宽字符</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">容器 (8)</td><td style="text-align:left">bitset：位集</td><td style="text-align:left">-</td><td style="text-align:left"><a href="https://chenyin-rss.online" target="_blank" rel="noopener">vector</a>：向量<br>list：列表<br>queue：队列<br>deque：双队<br>stack：堆栈<br>map：映射<br>set：集合</td></tr><tr><td style="text-align:center">迭代器 (1)</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">iterator：迭代器</td></tr><tr><td style="text-align:center">算法 (2)</td><td style="text-align:left">-</td><td style="text-align:left">cios646：ISO646字符集替换</td><td style="text-align:left">algorithm：算法</td></tr><tr><td style="text-align:center">数值操作 (4)</td><td style="text-align:left">complex：复数<br>valarray：数值矢量</td><td style="text-align:left">cmath：C数学库</td><td style="text-align:left">numeric：数学运算</td></tr><tr><td style="text-align:center">本地化 (2)</td><td style="text-align:left">locale：本地化</td><td style="text-align:left">clocale：C本地化</td><td style="text-align:left">-</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库总共51个头文件，按照内容可分为10个类，按照来源可分为3个类。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://chenyin.top/categories/Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++标准库索引</title>
    <link href="http://chenyin.top/Cpp/20200710-e3c6.html"/>
    <id>http://chenyin.top/Cpp/20200710-e3c6.html</id>
    <published>2020-07-10T01:27:17.000Z</published>
    <updated>2020-09-27T07:11:32.943Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库总共51个头文件，按照内容可分为10个类，按照来源可分为3个类。</p><a id="more"></a><table><thead><tr><th style="text-align:center">51</th><th style="text-align:left">C++ （20）</th><th style="text-align:left">C (18)</th><th style="text-align:left">STL (13)</th></tr></thead><tbody><tr><td style="text-align:center">语言支持 (11)</td><td style="text-align:left">limits：C++数值类型特性<br>new：动态内存管理<br>typeinfo：运行时内存信息<br>exception：异常处理</td><td style="text-align:left">cstddef：C标准定义<br>climits：整型大小<br>cfloat：浮点型特性<br>cstdlib：C标准实用工具<br>cstdarg：可变参数<br>csetjmp：非局部跳转<br>csignal：C中断处理</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">输入输出 (10)</td><td style="text-align:left">iostream：标准输入输出流<br>istream：标准输入流<br>ostream：标准输出流<br>sstream：字符串流<br><a href="/Cpp/20200710-111f.html">fstream</a>：文件流<br><a href="https://baike.baidu.com/item/iomanip/3319954" target="_blank" rel="noopener">iomanip</a>：输入输出操纵器<br>ios：iostream的基类<br>iosfwd：输入输出前向声明<br>streambuf：流缓存</td><td style="text-align:left">cstdio：C标准输入输出</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">诊断功能 (3)</td><td style="text-align:left">stdexcept：异常类</td><td style="text-align:left">cassert：C断言验证<br>cerrno：C出错码</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">通用工具(4)</td><td style="text-align:left">-</td><td style="text-align:left">ctime：C时间日期</td><td style="text-align:left">utility：实用元件<br>functional：函数对象<br>memory：内存管理器</td></tr><tr><td style="text-align:center">字符串 (6)</td><td style="text-align:left">string：字符串类<br>strstream：C字符串流类</td><td style="text-align:left">cstring：C字符串<br>cctype：单字节字符类型<br>cwctype：多字节字符类型<br>cwchar：扩展多字节宽字符</td><td style="text-align:left">-</td></tr><tr><td style="text-align:center">容器 (8)</td><td style="text-align:left">bitset：位集</td><td style="text-align:left">-</td><td style="text-align:left"><a href="https://chenyin-rss.online" target="_blank" rel="noopener">vector</a>：向量<br>list：列表<br>queue：队列<br>deque：双队<br>stack：堆栈<br>map：映射<br>set：集合</td></tr><tr><td style="text-align:center">迭代器 (1)</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">iterator：迭代器</td></tr><tr><td style="text-align:center">算法 (2)</td><td style="text-align:left">-</td><td style="text-align:left">cios646：ISO646字符集替换</td><td style="text-align:left">algorithm：算法</td></tr><tr><td style="text-align:center">数值操作 (4)</td><td style="text-align:left">complex：复数<br>valarray：数值矢量</td><td style="text-align:left">cmath：C数学库</td><td style="text-align:left">numeric：数学运算</td></tr><tr><td style="text-align:center">本地化 (2)</td><td style="text-align:left">locale：本地化</td><td style="text-align:left">clocale：C本地化</td><td style="text-align:left">-</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库总共51个头文件，按照内容可分为10个类，按照来源可分为3个类。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://chenyin.top/categories/Cpp/"/>
    
    
  </entry>
  
</feed>
