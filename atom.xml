<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Barwe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyin.top/"/>
  <updated>2019-03-22T02:49:35.743Z</updated>
  <id>http://chenyin.top/</id>
  
  <author>
    <name>阔落煮酒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>paper3 - RUV算法移除批次效应 (Davide Risso, 20140824)</title>
    <link href="http://chenyin.top/Bioinformatics/20190322-afa7.html"/>
    <id>http://chenyin.top/Bioinformatics/20190322-afa7.html</id>
    <published>2019-03-22T01:37:34.000Z</published>
    <updated>2019-03-22T02:49:35.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p> Gagnon-Bartsch et al.提出了RUV-2用来标准化<strong>连续的</strong>微阵列数据，移除不需要的变异。这里基于前面的方法进行扩展，用以标准化<strong>离散的</strong>RNA测序数据。</p><p> 对于表达矩阵（样本数 $n{\times}J$ 基因数）,构建<strong>泛化线性模型</strong> (Generalized Linear Model, GLM):<br>$$ \log{E[Y|W,X,O]}=W\alpha+X\beta+O $$<br>参数意义如下：</p><ul><li>$Y$ 是 $n{\times}J$ 的表达矩阵；</li><li>$W$ 是 $n{\times}k$ 与<strong>不需要的变异</strong>相关的<strong>多余变异相关矩阵</strong>（k是不需要的变异相关的变量的个数），$\alpha$ 是 $k{\times}J$ 的多余变异相关矩阵的系数（参数）；</li><li>$X$ 是 $n{\times}p$ 与<strong>感兴趣的变异</strong>相关的<strong>期望变异相关矩阵</strong>（p是感兴趣的变异相关的变量的个数），$\beta$ 是 $p{\times}J$ 的期望变异相关矩阵的系数（参数）；</li><li>$O$ 是一个 $n{\times}J$ 的矩阵，它可以置零，也可以包含其它的标准化过程（如<a href="https://en.wikipedia.org/wiki/Quantile_normalization" target="_blank" rel="noopener">UQ标准化</a>）。</li><li>矩阵 $X$ 是一个随机变量，是我们实验的测量值，是已知的（先验）。</li><li>矩阵 $W$ 是未观测的随机变量；$\alpha$、$\beta$、$k$ 都是未知参数。</li></ul><p>不同于先前的标准化方法，RUV可以使用GLM标准化技术同时标准化reads计数（$W\alpha$）和推断差异表达（$X\beta$）。标准化的计数也可以通过由原始计数对不需要的因子进行回归分析后求残差得到，但是直接从原始计数中移除不需要的因子（$W\alpha$）可能会损失掉 $X$ 的一部分。[<a href="">reference</a>]</p><p>同时估计 $W$, $\alpha$, $\beta$ 和 $k$ 是很难的。对于一个给定的 $k$ 值，我们尝试着用下面三种方法对$W$ 进行估计：</p><h2 id="1-基于阴性对照基因的RUVg"><a href="#1-基于阴性对照基因的RUVg" class="headerlink" title="1. 基于阴性对照基因的RUVg"></a>1. 基于阴性对照基因的RUVg</h2><ol><li>假设我们鉴定出了一个阴性对照基因 (negative control genes) 的集合（大小为 $J_c$），例如不差异表达的基因，对这个基因集合来说 $\beta_c=0$ 即 $\log{E[Y_c|W,X,O]}=W\alpha_c+O_c$，公式中的下标c将矩阵限制在了大小为 $J_c$ 的基因集合里。</li><li>定义 $Z=\log{Y}-O$，$Z^\ast$ 是 $Z$ 列向量中心化（$Z$ 的各个列向量均值都为0）的结果。</li><li>对 $Z_c^\ast$ 进行奇异值分解 (singular value decomposition, SVD) 即 $Z_c^\ast=U{\Lambda}V^T$。矩阵 $U$ 是 $n{\times}n$ 列正交矩阵，它的列向量是 $Z^\ast$ 的左奇异向量集；矩阵 $V$ 是 $J_c{\times}J_c$ 的列正交矩阵，它的列向量是 $Z^\ast$ 的右奇异向量集；$\Lambda$ 矩阵是由 $Z^\ast$ 的奇异值组成的非方形对角矩阵，大小为 $n{\times}J_c$。$Z^\ast$ 最少有 $\min{(n,J_c)}$ 个奇异值。对于一个给定的 $k$，通过 $\widehat{W\alpha_c}=U\Lambda_kV^T$ 估计 $W\alpha_c$，通过 $\hat{W}=U\Lambda_k$ 估计 $W$。$|lambda_k$ 是由 $\Lambda$ 导出的大小为 $n{\times}J_c$ 的非方形对角矩阵，保留 $\Lambda$ 中最大的 $k$ 个奇异值，将其它的奇异值置为0。</li><li>将 $\hat{W}$ 带入上面基于 $J$ 个基因构建的公式中，通过GLM回归估计 $\alpha$ 和 $\beta$。</li><li>（可选）将标准化的读段计数定义为 $Z$ 对 $\hat{W}$ 的普通最小二乘回归 (ordinary least squares, OLS) 的残差。 </li></ol><p>这是最基础的RUV-2的离散版本。其中的关键假设是我们能够找到这个阴性对照基因集合。然而，RUV-2已被证实对对照基因的选择十分敏感。我们因此考虑下面的两种方法：RUVr不需要阴性对照基因，RUVs对阴性对照基因选择的鲁棒性更强。</p><h2 id="2-基于残差的RUVr"><a href="#2-基于残差的RUVr" class="headerlink" title="2. 基于残差的RUVr"></a>2. 基于残差的RUVr</h2><ol><li>计算残差矩阵 $E(n{\times}J)$: 计数矩阵 $Y(n{\times}J)$ 关于感兴趣的协变量矩阵 $X(n{\times}J)$ 的初步GLM回归，例如异常值残差。这里用于回归计算的计数矩阵可以是未标准化的原始数据，也可以是经过其它标准化工具（例如UQ）处理过的数据。</li><li>对残差进行奇异值分解，即 $E=U{\Lambda}V^T$，通过 $\hat{W}=U\Lambda_k$ 估计 $w$。接下来的步骤与 <code>RUVg</code> 的第4、5步相同。</li></ol><h2 id="3-基于重复-阴性对照样本的RUVs"><a href="#3-基于重复-阴性对照样本的RUVs" class="headerlink" title="3. 基于重复/阴性对照样本的RUVs"></a>3. 基于重复/阴性对照样本的RUVs</h2><ol><li>假设在多个复制样本中具有生物学特征的（我们感兴趣的）某些协变量的表达量可看作恒定的，它们的计数差异与<code>RUVg</code>中的阴性对照基因一样，对我们后续的研究没有影响。现在假设有 $R$ 个复制组，$r(i){\in}{1,…,R}$ 表示样本 $i$ 所属的复制组；如果样本 $i$ 不属于任何一个复制组，则 $r(i)=0$。例如，对于SEQC数据集，样本A和样本B各自的64个<strong>复制本</strong>（$=4[\text{libraries}]{\times}2[\text{flow-cell}]{\times}8[\text{lanes}]$）分别组成了一个<strong>复制组</strong>。</li><li>对每一个复制本对应的计数矩阵进行<strong>列中心化</strong>处理，即矩阵各个列向量的均值都为0。去掉不属于预期复制组的样本，即筛选出 $n_d=\sum_i{I(r(i)\ne0)}$ 个样本对应的列中心化后的计数子矩阵 $Y_d(n_d{\times}J)$。 此时 $\log{E[Y_d|W,X,O]}=W_d\alpha+O_d$，对应的矩阵大小是 $(n_d{\times}J){\leftarrow}({n_d\times}k)({k\times}J)+(n_d{\times}J)$。</li><li>定义 $Z_d=\log{Y_d}-O_d$，$Z_d^\ast$ 是 $Z_d$ 列中心化的结果，$Z_d^\ast=U{\Lambda}V^T$。通过 $\hat{\alpha}=\Lambda_kV^T$（保留最大的 $k$ 个奇异值，$k{\le}\min{(n_d,J)}$）来估计 $\alpha$。</li><li>在所有 $n$ 个原始数据和 $J_c$ 个阴性对照基因上对 $Z_c$ 进行最小二乘回归（OLS）。估计讨厌因子 $W$：$\hat{W}=Z_c\hat\alpha_c^T(\hat\alpha_c\hat\alpha_c^T)^{-1}$。接下来的步骤与 <code>RUVg</code>的第4、5步相同。</li></ol><hr><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="两个数据集"><a href="#两个数据集" class="headerlink" title="两个数据集"></a>两个数据集</h2><ol><li><strong>SEQC data set</strong>: The third phase of the MicroArray Quality Control (MAQC) project, also known as the Sequencing Quality Control17 (SEQC) project, aims to assess the technical performance of high-throughput sequencing platforms by generating benchmarking data sets.</li><li><strong>Zebrafish (斑马鱼) data set</strong>: All procedures were conducted in compliance with US federal guidelines in an AAALAC-accredited facility and were approved by the UC Berkeley Office of Animal Care and Use. </li></ol><h2 id="两种讨厌因子"><a href="#两种讨厌因子" class="headerlink" title="两种讨厌因子"></a>两种讨厌因子</h2><p>本文分析了两种讨厌因子：<strong>library preparation</strong> &amp; <strong>flow-cell effects</strong>。</p><p><strong>flowcell</strong>：流动室，别称鞘流池、流动池，是流式细胞技术的基础关键部件。大概长这个样子：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/flowcell-350x2332.jpg" width="100%"></p><p>作者用<strong>正交的主成分图</strong>展示了这两种讨厌因子：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-22_101808.jpg" width="100%"><span style="font-size:16px;color:gray">Scatterplot matrix of first three principal components (PC) for unnormalized counts (log scale, centered). The principal components are orthogonal linear combinations of the original 21,559-dimensional gene expression profiles, with successively maximal variance across the 128 samples, that is, the first principal component is the weighted average of the 21,559 gene expression measures that provides the most separation between the 128 samples. Each point corresponds to one of the 128 samples. The four sample A and the four sample B libraries are represented by different shades of blue and red, respectively (16 replicates per library). Circles and triangles represent samples sequenced in the first and second flow-cells, respectively. As expected for the SEQC data set, the first principal component is driven by the extreme biological difference between sample A and sample B. The second and third principal components clearly show library preparation effects (the samples cluster by shade) and, to a lesser extent, flow-cell effects reflecting differences in sequencing depths (within each shade, the samples cluster by shape).</span></p><h2 id="算法横向对比"><a href="#算法横向对比" class="headerlink" title="算法横向对比"></a>算法横向对比</h2><p><strong>上分位数标准化</strong> (Upper-quartile normalization, UQ)，UQ只能消除流细胞效应而对文库效应束手无策，RUV算法解决的就是如何消除不同文库的影响。</p><p><strong>局部加权回归散点平滑法</strong> (Locally Weighted Scatterplot Smoothing, LOWESS/LOESS)不能消除文库效应。</p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="ERCC-spike-in-controls"><a href="#ERCC-spike-in-controls" class="headerlink" title="ERCC spike-in controls"></a>ERCC spike-in controls</h2><p>ERCC 即 External RNA Controls Consortium，是斯坦福大学为了定制一套spike-in RNA而成立的专门性组织，主要的工作是设计了好用的spike-in RNA，方便microarray以及RNA-Seq进行内参定量。[<a href="https://jimb.stanford.edu/ercc/" target="_blank" rel="noopener">官方首页</a>]</p><p>RNA spike-in是一种数量和序列都已知的RNA转录本，用于校准RNA杂交实验（例如DNA微阵列实验、RT-qPCR、RNA测序等）的测量值。RNA spike-in作为对照组（控制组）探针，被设计成能与具有相应匹配序列的DNA分子结合，这个特异性结合的过程我们称之为<strong>杂交</strong>。在制备的过程中，已知数量的spike-in将与实验样本进行混合。spike-ins的杂交程度可以用来标准化样本RNA的测量值。[<a href="https://en.wikipedia.org/wiki/RNA_spike-in" target="_blank" rel="noopener">wiki</a>] [<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1797020" target="_blank" rel="noopener">reference</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h1&gt;&lt;p&gt; Gagnon-Bartsch et al.提出了RUV-2用来标准化&lt;strong&gt;连续的&lt;/strong&gt;微阵列数据，移除不需要的变异。
      
    
    </summary>
    
      <category term="Bioinformatics" scheme="http://chenyin.top/categories/Bioinformatics/"/>
    
    
  </entry>
  
  <entry>
    <title>批次效应（batch effect）</title>
    <link href="http://chenyin.top/Bioinformatics/20190319-cca5.html"/>
    <id>http://chenyin.top/Bioinformatics/20190319-cca5.html</id>
    <published>2019-03-19T06:38:32.000Z</published>
    <updated>2019-03-22T02:51:28.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a><span id="def">一、定义</span></h1><p>下面是大佬给出来的关于<strong>批次效应</strong>(batch effect)的定义：</p><blockquote><p>Batch effects are sub-groups of measurements that have qualitatively different behaviour across conditions and are unrelated to the biological or scientific variables in a study. For example, batch effects may occur if a subset of experiments was run on Monday and another set on Tuesday, if two technicians were responsible for different subsets of the experiments, or if two different lots of reagents, chips or instruments were used. <a href="https://www.nature.com/articles/nrg2825" target="_blank" rel="noopener">Leek et. al (2010)</a></p></blockquote><p>批次效应是测量结果中的一部分，它们因为实验条件的不同而具有不同的表现形式，并且与我们研究的变量没有半毛钱关系。一般批次效应可能在下述情形中出现：</p><ul><li>一个实验的不同部分在<strong>不同时间</strong>完成；</li><li>一个实验的不同部分由<strong>不同的人</strong>完成；</li><li>试剂用量不同、芯片不同、实验仪器不同；</li><li>将自己测的数据与从网上下载的数据混合使用；</li><li>……</li></ul><hr><h1 id="二、检测"><a href="#二、检测" class="headerlink" title="二、检测"></a>二、检测</h1><p>批次效应相关协变量已知时，直接聚类观察结果是否和相应协变量相关。<br>混合数据因为实验条件迥异，一般批次效应都很大。</p><p>以R为例，通过聚类检验是否存在批次效应。请先查看下面的<a href="#dataset">示例数据集</a>。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t() 转置函数</span></span><br><span class="line"><span class="comment"># dist() 距离函数：按照指定规则求行向量间的距离，因此要转置</span></span><br><span class="line">&gt; dist_mat &lt;- dist(t(edata))</span><br><span class="line">&gt; clustering &lt;- hclust(dist_mat) <span class="comment"># hclust 的输入结构与 dist 相同！</span></span><br><span class="line"><span class="comment"># 按照批次信息聚类</span></span><br><span class="line">&gt; plot(clustering, labels = pheno$batch)</span><br><span class="line"><span class="comment"># 按照是否是正常细胞聚类</span></span><br><span class="line">&gt; plot(clustering, labels = pheno$cancer)</span><br></pre></td></tr></table></figure></p><p>聚类结果如下：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-result1.png" width="50%"><br>左边的红色框框是正常细胞中混入的癌细胞，右边蓝色框框中是癌细胞中混入的正常细胞。</p><p>还有许多检验批次效应的的方法，这篇<a href="https://www.itl.nist.gov/div898/handbook/eda/section4/eda42a3.htm" target="_blank" rel="noopener">文章</a>给出了多种检验方式：</p><ul><li>图分析：双柱状图、QQ图、箱线图、块图、…</li><li>定量分析：F检验、双样本t检验、…</li></ul><hr><h1 id="三、处理"><a href="#三、处理" class="headerlink" title="三、处理"></a>三、处理</h1><p>实验条件允许的条件下，应该优化实验设计，将引起批次效应的协变量采样<strong>分散</strong>开来。例如，对于时间批次效应，实验的不同部分应该在各个时间内均匀采样。这叫“治病就治本”。</p><p>但是大多数情况下实验条件不允许，如果够幸运的话批次效应相关的协变量已经被记录下来了，此时对批次效应进行验证，然后使用统计模型过滤；如果十分不幸，批次效应相关的协变量没有被记录或者不明显，我们就需要借助相关工具猜一下哪个变量可能造成了批次效应，然后使用统计模型过滤。前者叫<strong>参数化方法</strong>，后者叫<strong>非参数化方法</strong>。</p><h2 id="1-导入示例数据集"><a href="#1-导入示例数据集" class="headerlink" title="1.导入示例数据集"></a><span id="dataset">1.导入示例数据集</span></h2><h3 id="bladderbatch包"><a href="#bladderbatch包" class="headerlink" title="bladderbatch包"></a>bladderbatch包</h3><p><code>bladderbatch</code>包包含了一项<a href="https://www.ncbi.nlm.nih.gov/pubmed/15173019" target="_blank" rel="noopener">膀胱癌研究</a>中相关的57个样本的基因表达数据，这些数据已经使用RMA标准化，并且已经按照<a href="https://www.ncbi.nlm.nih.gov/pubmed/20838408" target="_blank" rel="noopener">相关协议</a>进行了预处理。</p><p>另外阅读R文档我们发现：</p><ul><li><code>eSet</code>是一个包含高通量实验元数据的一个类，它不能直接被实例化。</li><li><code>pData</code>方法在类<code>eSet</code>中被定义，它的作用是访问数据的元数据（注释信息）。</li><li><code>ExpressionSet</code>继承自<code>eSet</code>，同样是一个高通量测序数据的容器，由&gt; * <code>biobase</code>包引入，封装了<strong>表达矩阵</strong>和<strong>样本分组信息</strong>。表达矩阵存储在<code>exprs</code>中。</li></ul><p><code>bladderbatch</code>数据集是（类似）<code>ExpressionSet</code>类型，我们可以使用<code>pData()</code>加载元数据，使用<code>exprs()</code>加载表达谱数据。<br><code>bladderbatch</code>数据集用来演示如何校正批次效应。</p><h3 id="下载和加载数据集"><a href="#下载和加载数据集" class="headerlink" title="下载和加载数据集"></a>下载和加载数据集</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.安装并加载数据集</span></span><br><span class="line">&gt; BiocInstaller::biocLite(<span class="string">"bladderbatch"</span>)</span><br><span class="line">&gt; <span class="keyword">library</span>(bladderbatch) <span class="comment"># 或者 library("bladderbatch", character.only=TRUE)</span></span><br><span class="line"><span class="comment">## 2.查看当前可用数据集</span></span><br><span class="line">&gt; data()</span><br><span class="line"><span class="comment">## 3.检查是否有如下信息</span></span><br><span class="line">Data sets <span class="keyword">in</span> package ‘bladderbatch’:</span><br><span class="line">bladderEset (bladderdata)           Bladder Gene Expression Data Illustrating Batch Effects</span><br><span class="line"><span class="comment">## 加载数据集</span></span><br><span class="line">&gt; data(bladderdata) <span class="comment"># 实际加载进来的数据集名字叫做 bladderEset !</span></span><br><span class="line">&gt; pheno &lt;- pData(bladderEset) <span class="comment"># 使用 pData 加载元数据/注释信息</span></span><br><span class="line">&gt; edata &lt;- exprs(bladderEset) <span class="comment"># 使用 exprs 加载数据</span></span><br></pre></td></tr></table></figure><p><code>pheno</code>如下所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-pheno.png" width="20%"><br>样本的批次信息存储作为元数据存储在<code>pheno$batch</code>中（R中使用<code>$</code>访问对象的属性）。</p><p><code>edata</code>如下所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-edata.png" width="50%"><br>一列表示一个样本（细胞），后面求距离需要转置。</p><hr><h2 id="2-R中的sva包"><a href="#2-R中的sva包" class="headerlink" title="2.R中的sva包"></a>2.R中的sva包</h2><p><code>sva</code>用于移除高通量测序数据中的<a href="#def"><strong>批次效应</strong></a>以及其它无关变量的影响。</p><p><code>sva</code>包含用于标识和构建高维数据集（例如基因表达、RNA测序/甲基化/脑成像数据等可以直接进行后续分析的数据）<strong>代理变量</strong>的函数。代理变量是直接从高维数据构建的协变量，可以在后续分析中用于调整未知的、未建模的或潜在的噪音源。</p><blockquote><p><strong>代理变量（surrogate/proxy variable）</strong>: A variable that can be measured (or is easy to measure) that is used in place of one that cannot be measured (or is difficult to measure). For example, whereas it may be difficult to assess the wealth of a household, it is relatively easy to assess the value of a house. See also proxy variable. (from <a href="http://www.oxfordreference.com/view/10.1093/oi/authority.20110803100544210" target="_blank" rel="noopener">Oxford Reference</a>)<br><strong>代理变量分析（Surrogate Variable Analysis）</strong>：<a href="https://digital.lib.washington.edu/researchworks/handle/1773/9586" target="_blank" rel="noopener">Click here</a></p></blockquote><p><code>sva</code>从三个方面消除人为设计造成的影响：</p><ol><li>为未知变异源构造代理变量；(Leek and Storey <a href="https://www.ncbi.nlm.nih.gov/pubmed/17907809" target="_blank" rel="noopener">2007 PLoS Genetics</a>, <a href="https://www.ncbi.nlm.nih.gov/pubmed/20941797" target="_blank" rel="noopener">2011 Pharm Stat.</a>)</li><li>使用ComBat直接移除已知的批次效应；<a href="https://academic.oup.com/biostatistics/article/8/1/118/252073" target="_blank" rel="noopener">(Johnson et al. 2007 Biostatistics)</a></li><li>使用已知的控制探针(known control probes)移除批次效应；<a href="https://www.biorxiv.org/content/10.1101/006585v2" target="_blank" rel="noopener">(Leek 2014 biorXiv)</a><br>移除批次效应和使用代理变量可以减少依赖性，稳定错误率估计值，提高重现性。</li></ol><p>查看<code>sva</code><a href="http://127.0.0.1:28090/library/sva/doc/sva.pdf" target="_blank" rel="noopener">在线文档</a>。</p><h3 id="gt-已记录批次信息"><a href="#gt-已记录批次信息" class="headerlink" title="&gt; 已记录批次信息"></a>&gt; 已记录批次信息</h3><p>当<strong>批次协变量</strong>已知时（即每个样本分属于哪一个批次记录在数据集的元数据中），可以使用<code>sva</code>的<code>ComBat</code>校正<strong>批次效应</strong>。<br><code>ComBat</code>使用参数（parametric）或者非参数（non-parametric）的<strong>经验贝叶斯框架</strong>（Empirical Bayes Frameworks）进行批次效应的校正。</p><p>先看<code>ComBat</code>的用法：摘自<a href="https://www.rdocumentation.org/packages/sva/versions/3.20.0/topics/ComBat" target="_blank" rel="noopener">官方文档</a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ComBat(dat, batch, mod=<span class="literal">NULL</span>, par.prior = <span class="literal">TRUE</span>, prior.plots = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># dat: 基因组测量矩阵（探针维度 X 样本数），探针维度例如marker数、基因数.....，例如表达谱矩阵</span></span><br><span class="line"><span class="comment"># batch: 批次协变量，只能传入一个批次协变量！</span></span><br><span class="line"><span class="comment"># mod: 这是一个模式矩阵，里面包含了我们感兴趣的变量！</span></span><br><span class="line"><span class="comment"># par.prior: 基于参数/非参数，默认为基于参数</span></span><br></pre></td></tr></table></figure></p><p>有了背景知识我们就可以进行膀胱癌数据的批次校正：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; pheno$hasCancer &lt;- pheno$cancer == <span class="string">"Cancer"</span></span><br><span class="line"><span class="comment"># 或者 &gt; pheno$hasCancer &lt;- as.numeric(pheno$cancer == "Cancer")</span></span><br><span class="line">&gt; model &lt;- model.matrix(~hasCancer, data=pheno)</span><br><span class="line">&gt; combat_edata &lt;- ComBat(dat = edata, batch = pheno$batch, mod = model)</span><br><span class="line"><span class="comment"># 这里的 mod 参数就比较有意思了，它记录的是我们感兴趣的变量。因为初次接触R只能肤浅理解一下。</span></span><br><span class="line"><span class="comment"># 它应该是一个我们期望样本能被正确聚类所依据的协变量，它总是数值型变量</span></span><br></pre></td></tr></table></figure></p><p><code>model.matrix(...)</code>的详细解释见<a href="/R/20190319-1548.html">这里</a>。</p><p>画图：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; dist_mat_combat &lt;- dist(t(combat_edata))</span><br><span class="line">&gt; clustering_combat &lt;- hclust(dist_mat_combat, method = <span class="string">"complete"</span>)</span><br><span class="line">&gt; plot(clustering, labels = pheno$batch)</span><br><span class="line">&gt; plot(clustering, labels = pheno$cancer))</span><br></pre></td></tr></table></figure></p><p>我们发现批次效应被移除了：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-result2.png" width="50%"></p><h3 id="gt-没有记录批次信息"><a href="#gt-没有记录批次信息" class="headerlink" title="&gt; 没有记录批次信息"></a>&gt; 没有记录批次信息</h3><p><a href="http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#removing-hidden-batch-effects" target="_blank" rel="noopener">看这里</a></p><hr><h2 id="3-R中的ber包"><a href="#3-R中的ber包" class="headerlink" title="3.R中的ber包"></a>3.R中的ber包</h2><p>ber的全称就是batch effects removal，使用<code>&gt; install.packages(&quot;ber&quot;)</code>安装ber包，查看<a href="https://cran.r-project.org/web/packages/ber/ber.pdf" target="_blank" rel="noopener">用户手册</a>。</p><p>这个包里有6个函数，它们的作用就是校正<strong>微阵列标准数据</strong>中的批次效应。标准数据指的是：输入矩阵每一行代表独立的样本，每一列代表基因；批次信息作为已知的<strong>分类变量</strong>；期望变量可以大大提高批次效应校正的效率。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>berr(Y, b, covariates = NULL)</code></td><td>using a two-stage regression approach <a href="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019031901.pdf" target="_blank" rel="noopener">(M. Giordan. February 2013)</a></td></tr><tr><td><code>ber_bg(Y, b, covariates = NULL,partial=TRUE,nSim=150)</code></td><td>using a two-stage regression approach and bagging <a href="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019031901.pdf" target="_blank" rel="noopener">(M. Giordan. February 2013)</a></td></tr><tr><td><code>combat_p(Y, b, covariates = NULL, prior.plots=T)</code></td><td>using a parametric empirical Bayes approach <a href="https://www.ncbi.nlm.nih.gov/pubmed/16632515" target="_blank" rel="noopener">(n Johnson et al. 2007)</a></td></tr><tr><td><code>combat_np(Y, b, covariates = NULL)</code></td><td>using a non-parametric empirical Bayes approach <a href="https://www.ncbi.nlm.nih.gov/pubmed/16632515" target="_blank" rel="noopener">(n Johnson et al. 2007)</a></td></tr><tr><td><code>mean_centering(Y, b)</code></td><td>using the means of the batches</td></tr><tr><td><code>standardization(Y, b)</code></td><td>using the means and the standard deviations of the batches</td></tr></tbody></table><p>上表中的：</p><ul><li><code>Y</code>是输入矩阵（样本数 $n{\times}g$ 探针数）</li><li><code>b</code>是 $n$ 维<strong>分类1向量</strong>，每个分量对应着每个样本的批次信息</li><li><code>covariates</code>是一个 $n$ 行的<code>data.frame</code>实例</li></ul><p>上面的6个函数都需要指定<code>b</code>，所以它们都是用来处理<strong>批次信息被记录</strong>的情形的，对于启发性的校正貌似没提出解决方案。</p><hr><h2 id="4-R中的RUVSeq包"><a href="#4-R中的RUVSeq包" class="headerlink" title="4.R中的RUVSeq包"></a>4.R中的RUVSeq包</h2><p>RUVSeq means <em>Remove Unwanted Variation from RNA-Seq Data</em>, which shows us how to conduct a differential expression (DE) analysis that controls for “unwanted variation”, e.g., batch, library preparation, and other nuisance effects, using the between-sample normalization methods proposed in <a href="https://www.nature.com/articles/nbt.2931" target="_blank" rel="noopener">Risso et al. (2014)</a>.</p><p>RUV算法基本原理参考<a href="/Bioinformatics/20190322-afa7.html">这里</a>，原文在<a href="https://www.nature.com/articles/nbt.2931" target="_blank" rel="noopener">这里</a>。</p><hr><h2 id="5-R中的BatchQC包"><a href="#5-R中的BatchQC包" class="headerlink" title="5. R中的BatchQC包"></a>5. R中的BatchQC包</h2><p><a href="https://bioconductor.org/packages/release/bioc/html/BatchQC.html" target="_blank" rel="noopener">BatchQC工具</a></p><hr><h1 id="四、FAQ"><a href="#四、FAQ" class="headerlink" title="四、FAQ"></a>四、FAQ</h1><ol><li><strong>标准化（normalization）可以消除批次效应吗？</strong> 只能缓解，不能消除。</li></ol><hr><h1 id="五、其它资料"><a href="#五、其它资料" class="headerlink" title="五、其它资料"></a>五、其它资料</h1><p>Stanford大学MOOC公开课讲义：<a href="http://genomicsclass.github.io/book/" target="_blank" rel="noopener">PH525x series - Biomedical Data Science</a></p><p><a href="https://bioinformatics.mdanderson.org/public-software/tcga-batch-effects/" target="_blank" rel="noopener">TCGA Batch Effects Viewer</a></p><p>From BioMedSearch: <a href="http://www.biomedsearch.com/nih/Removing-batch-effects-in-analysis/21386892.html" target="_blank" rel="noopener">Removing batch effects in analysis of expression microarray data: an evaluation of six batch adjustment methods.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;&lt;span id=&quot;def&quot;&gt;一、定义&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;下面是大佬给出来的关于&lt;strong&gt;批次效应&lt;/strong&gt;(batch e
      
    
    </summary>
    
      <category term="Bioinformatics" scheme="http://chenyin.top/categories/Bioinformatics/"/>
    
    
  </entry>
  
  <entry>
    <title>model.matrix(...)</title>
    <link href="http://chenyin.top/R/20190319-1548.html"/>
    <id>http://chenyin.top/R/20190319-1548.html</id>
    <published>2019-03-19T03:34:18.000Z</published>
    <updated>2019-03-19T03:41:16.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类变量"><a href="#分类变量" class="headerlink" title="分类变量"></a>分类变量</h1><p><strong>分类变量</strong>（Factors）：R中用来存储分类数据的类别信息。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; f = factor(c(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>))</span><br><span class="line"><span class="comment"># 检查变量是否是分类变量（因子）</span></span><br><span class="line">&gt; class(f)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"factor"</span></span><br><span class="line"><span class="comment"># 查看分类变量中有哪些类别</span></span><br><span class="line">&gt; levels(f)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line"><span class="comment"># 查看分类变量中有几类</span></span><br><span class="line">&gt; nlevels(f)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="哑变量"><a href="#哑变量" class="headerlink" title="哑变量"></a>哑变量</h1><p><strong>虚拟变量</strong>/<strong>哑变量</strong>（dummy variable）：量化非数值类型的变量，通常取0/1。例如，衡量一个人的性别：男 -&gt; 1，女 -&gt; 0。</p><h1 id="解释变量"><a href="#解释变量" class="headerlink" title="解释变量"></a>解释变量</h1><p><strong>解释变量</strong>（explanatory variable）：单纯从数理角度来看，解释变量等同于控制变量/自变量，与之相对的是<strong>被解释变量</strong>（反应变量/因变量）。<a href="http://blog.sciencenet.cn/blog-334577-426759.html" target="_blank" rel="noopener">REF</a></p><h1 id="设计矩阵"><a href="#设计矩阵" class="headerlink" title="设计矩阵"></a>设计矩阵</h1><p><strong>设计矩阵</strong>（design matrix）：又叫<strong>模型矩阵</strong>（model matrix）或者<strong>回归矩阵</strong>（regressor matrix）。由解释变量值组成的矩阵：一行代表一个独立的观测对象（样本），一列代表对应的变量（特征值、元数据），通常记为$X$。简单理解，就是我们所说的<strong>输入矩阵</strong>，可以是元数据的，也可以是数据的。</p><h1 id="model-matrix-…"><a href="#model-matrix-…" class="headerlink" title="model.matrix(…)"></a>model.matrix(…)</h1><p>定义：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># S3 method for default </span></span><br><span class="line">model.matrix(object, data = environment(object), contrasts.arg = <span class="literal">NULL</span>, xlev = <span class="literal">NULL</span>, …)</span><br><span class="line"><span class="comment"># 函数依据 object 创建设计矩阵，矩阵的创建必须借助于数据集 data</span></span><br><span class="line"><span class="comment"># data 必须能提供与 object 相同名字的变量！</span></span><br></pre></td></tr></table></figure></p><p>以膀胱癌去批次效应为例，元数据形式如下<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/model.matrix.pheno.png" alt="model.matrix.pheno"></p><p>下面是部分列处理后的结果：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; model &lt;- model.matrix(~batch, data = pheno)</span><br><span class="line">                  (Intercept)batch</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="comment"># pheno$batch 是数值型变量，相当于提取列</span></span><br><span class="line"><span class="comment"># 此时新的变量名仍然是 batch</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">&gt;model &lt;-  model.matrix(~cancer, data = pheno)</span><br><span class="line">             (Intercept) cancerCancer cancerNormal</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line"><span class="comment"># pheno$cancer 被处理成分类变量，每一类将单独作为列（哑变量），取值为0/1</span></span><br><span class="line"><span class="comment"># 此时新的变量名为 cancerCancer 和 cancerNormal</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">&gt; model &lt;- model.matrix(~cancer==<span class="string">"Cancer"</span>, data = pheno)</span><br><span class="line">             (Intercept) cancer == <span class="string">"Cancer"</span><span class="literal">TRUE</span></span><br><span class="line">GSM71019.CEL           <span class="number">1</span>                            <span class="number">0</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>                            <span class="number">0</span></span><br><span class="line"><span class="comment"># cancer=="Cancer" 是一个 logical 类型</span></span><br><span class="line"><span class="comment"># 这种写法极不优雅！我们应该先定好名字</span></span><br><span class="line">&gt; pheno$hasCancer &lt;- pheno$cancer == <span class="string">"Cancer"</span></span><br><span class="line">&gt; model &lt;- model.matrix(~hasCancer, data=pheno)</span><br><span class="line">             (Intercept) hasCancer</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>         <span class="number">0</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>         <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分类变量&quot;&gt;&lt;a href=&quot;#分类变量&quot; class=&quot;headerlink&quot; title=&quot;分类变量&quot;&gt;&lt;/a&gt;分类变量&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分类变量&lt;/strong&gt;（Factors）：R中用来存储分类数据的类别信息。&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="R" scheme="http://chenyin.top/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>生信分析工具-SCENIC</title>
    <link href="http://chenyin.top/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/20190315-94a8.html"/>
    <id>http://chenyin.top/生物信息学/20190315-94a8.html</id>
    <published>2019-03-15T10:53:18.000Z</published>
    <updated>2019-03-15T11:07:48.338Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SCENIC: Single-cell regulatory network inference and clustering</strong></p><p>基于regulon(TF-&gt;targets)构建GRNs，基于GRNs可以进行细胞聚类。</p><p>与其说是算法，不如说SCENIC是组合算法的一个流程。如下图所示：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/scenic-01.png" alt=""></p><h1 id="1-基因数据过滤"><a href="#1-基因数据过滤" class="headerlink" title="1. 基因数据过滤"></a>1. 基因数据过滤</h1><p>共表达分析之前需要对基因数据进行过滤，本文使用如下两个方法：</p><p>1.根据每个基因的reads数目移除可信度低或者将产生较大噪声的基因。reads数目的阈值与数据集的大小有关，以下是原文表述：3 UMI counts (slightly over the median of the nonzero values) multiplied by 1% of the number of cells in the dataset (e.g. in mouse brain: 3 UMI counts x 30 (1% of cells) = minimum 90 counts per gene).</p><p>2.根据可检测到某个基因的细胞数目过滤掉只在一个细胞或者极少量细胞中表达的基因，细胞数目的阈值设定参考原文：set a percentage lower than the smallest population of cells to be detected. For example, since microglia cells represent approximately 3% of the total cells in the dataset, we used a detection threshold of at least 1% of the cells.</p><h1 id="2-共表达分析"><a href="#2-共表达分析" class="headerlink" title="2. 共表达分析"></a>2. 共表达分析</h1><p>仅仅借助<strong>共表达分析</strong>(co-expression analysis)(GENIE3或者GRNBoost)得到regulons的表达情况（GRNs）。一个regulon由一个TF和它调控的靶基因组成。当数据集非常大时GENIE3的运行速度将会变得非常慢，此时使用GRNBoost替换GENIE3能大大加快计算速度。</p><p>但是，共表达分析存在许多假阳性结果，我们需要找到这些实际上不存在的TF-靶基因配对，因此需要下一步的基序富集分析。</p><h2 id="GENIE3"><a href="#GENIE3" class="headerlink" title="GENIE3"></a>GENIE3</h2><p>GENIE3的核心算法是<strong>随机森林回归模型</strong>。随机森林能够处理非线性共表达关系。针对不同的TF训练不同的模型，这些模型用于计算相应TF的权重，这些权重可以用来衡量它与靶基因共表达的强度。</p><p>输入：一个基因表达矩阵，矩阵的每一列代表一个细胞的不同基因，每一行代表一个基因在不同细胞里的表达量。矩阵的元素可以是UMI计数，也可以是其它指标，例如TPM (Transcripts Per Million)、FPKM/RPKM等等。输入矩阵应避免进行标准化或归一化处理，这样会人为的引入多余的协方差。</p><p>输出：一张三列表，分别代表TF、靶基因、权重（TF靶向目标基因的可信度）</p><h2 id="GRNBoost"><a href="#GRNBoost" class="headerlink" title="GRNBoost"></a>GRNBoost</h2><blockquote><p>Spark <strong>RDD</strong>：Risilient Distributed Datasets 弹性分布式数据库<br><strong>广播变量</strong>(Broadcast Variable)：将只读变量广播到各个节点以供读取，避免变量在任务间进行传递。变量被广播之后应避免被修改。</p></blockquote><p>GRNBoost作为GENIE3在大数据集下的替代方案，它仍然接受GENIE3的基本思想：仅从基因表达数据中推断GRNs。</p><p>算法方面，GRNBoost使用了XGBoost库中的GBM (Gradient Boosting Machines)。GBM是一种结合多种弱学习器、以提升学习作为基本策略的集成学习方法。相对于随机森林，GBM使用了bagging自助聚合进行模型的平均以提高回归准确度。</p><p>然而，GRNBoost的主要贡献是基于Spark实现了多回归并行计算。<br>软件输入是<strong>基因表达向量</strong>（一系列基因和一个转录因子表达量组成的向量？）。<br>GRNBoost首先将基因表达向量分发给集群的各个节点，然后构建一个基于表达数据全集的预测矩阵。<br>然后使用<strong>广播变量</strong>（Broadcast Variable）将这个预测矩阵广播到各个节点，接下来进行Map/Reduce分布式计算。</p><p><strong>Map阶段</strong>：基于基因表达向量使用预测器训练XGBoost回归模型。基于训练的模型，TF和靶基因的靶向强度将以网络的边的形式呈现出来。</p><p><strong>Reduce阶段</strong>：整合所有的边形成最终的GRNs。</p><h1 id="3-基序富集分析"><a href="#3-基序富集分析" class="headerlink" title="3. 基序富集分析"></a>3. 基序富集分析</h1><p><strong>基序富集分析</strong>(motif enrichment analysis)使用的工具是RcisTarget，它能找到共表达分析的假阳性结果。删除这些假阳性结果就能得到正确的GRNs (Gene Regulatory Networks)。</p><p>RcisTarget 是 i-cisTarget 和 iRegulon 基序富集框架的 R/Bioconductor 实现。</p><p>主要分为两个步骤：</p><ol><li>选择在基因的转录起始位点（TSS）附近明显高表达的DNA基序<br>This is achieved by applying a recovery-based method on a database that contains genome-wide cross-species rankings for each motif. 实现方法：在基序全基因组跨物种排名数据库上使用recovery方法<br>保留那些可以注释到TF并且标准富集分数(Normalized Enrichment Score, NES)大于3.0的基序<br>2.对于每个基序和基因集，RcisTarget预测候选靶基因（如在基因集中排列在前缘以上的基因）<br>方法详情见引用[32]，此方法在i-cisTarget&amp;iRegulon中均有实现，因此使用RcisTarget得到的结果与i-cisTarget&amp;iRegulon的结果一致</li></ol><p>为了构建最终的调控子，我们将每个有基序富集的TF模块预测的靶基因进行归并。<br>上面针对的是正调控，对于抑制，仍然可以对负相关的TF模块做相同的处理；但是我们的分析中，这类模块较少。<br>基于上述事实，本实验之研究正相关，不研究负相关<br>本文使用的数据集：the “18k motif collection” from iRegulon (gene-based motif rankings) for human and mouse<br>TSS搜索空间：10kb around the TSS or 500bp upstream the TSS</p><h1 id="4-AUCell打分"><a href="#4-AUCell打分" class="headerlink" title="4. AUCell打分"></a>4. AUCell打分</h1><p>The relative scores of each regulon across the cells allow identifying which cells have a significantly high sub-network activity<br>细胞的调节子打分容许我们识别哪些细胞具有明显的高子网络活性？？？结果是一个二进制的活性矩阵，可用于下游分析<br>——对此矩阵的聚类可用于细胞类型或者细胞状态的识别，基于调控子网络的活性共享。<br>对抗dropouts增强鲁棒性：对调节子整体进行打分，而不是针对特定的转录因子或者单个基因。</p><p>基于单细胞测序数据，从活化的GRNs中鉴定细胞<br>输入是一个基因集，输出为每个细胞中基因集的活性（AUC指标）<br>在SCENIC中，这些基因集表现为regulons，每个调控子由一个TF和它对应的靶基因组成<br>AUCell calculates the enrichment of the regulon as an area under the recovery curve (AUC) across the ranking of all genes in a particular cell, whereby genes are ranked by their expression value.<br>将AUC区域面积作为regulon的富集量，该区域包含了特定细胞中所有基因的排序。<br>This method is therefore independent of the gene expression units and the normalization procedure.<br>因为是在单个细胞上进行检验，因此很容易可以应用到大数据集</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/scenic-02.png" alt=""></p><p>——AUCell用来估计每个细胞中每个regulon的活性，通过计算恢复曲线下的面积，整合了每个regulon里所有排列的基因的信息<br>——AUC打分（上面计算出来的）通过设定阈值构建Regulon Activity Matrix，用来判定哪些细胞里的regulon处于on状态<br>——左图横坐标是一个regulon的靶基因的排列，纵坐标是从输入数据集中数出来的基因数目<br>然后，AUCell使用“曲线下面积”(AUC)计算输入基因集中的一个关键子集是否在每个细胞的排名顶部富集。<br>AUC表示表达基因在特征中的比例以及相对于细胞内其他基因的相对表达值<br>这一部的输出是一个矩阵：每一个细胞的每一个基因集的AUC分数<br>使用细胞中的一系列regulon的AUC值进行细胞的聚类，或者使用处理过的二值矩阵<br>——二值矩阵：自动 or 手动<br>——下图是AUC分布的几个例子</p><h1 id="5-基于GRNs的细胞聚类"><a href="#5-基于GRNs的细胞聚类" class="headerlink" title="5. 基于GRNs的细胞聚类"></a>5. 基于GRNs的细胞聚类</h1><p>AUC activity matrix：每个细胞中每个regulon的AUC值，连续值<br>regulon activity matrix：上面矩阵二值化的结果，01矩阵<br>可视化：主要用t-SNE、层次聚类的热图<br>探究结果的其他可选项<br>—— t-SNE的高密度区域 =&gt; 最可能的稳定状态<br>—— 鉴定key regulators<br>—— 基于数据库注释了解细胞属性<br>—— GO terms (regulon内的基因富集分析)</p><blockquote><p>操纵子（operon）：包含了操纵基因的核苷酸序列，被某个启动子控制，对应一组受操纵基因调控的基因<br>调节子（regulon）：对应受某个起调节作用的蛋白质调节的一组基因<br>刺激子（stimulon）：对应某类起调节作用的细胞调节的一组基因</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Nat Methods. 2017 Nov;14(11):1083-1086. doi: 10.1038/nmeth.4463. Epub 2017 Oct 9.<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5937676" target="_blank" rel="noopener">SCENIC: Single-cell regulatory network inference and clustering</a><br>Aibar S1,2, González-Blas CB1,2, Moerman T3,4, Huynh-Thu VA5, Imrichova H1,2, Hulselmans G1,2, Rambow F6,7, Marine JC6,7, Geurts P5, Aerts J3,4, van den Oord J8, Atak ZK1,2, Wouters J1,2,8, Aerts S1,2.</p><p><a href="http://scenic.aertslab.org" target="_blank" rel="noopener">&gt;&gt;&gt; SCENIC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;SCENIC: Single-cell regulatory network inference and clustering&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于regulon(TF-&amp;gt;targets)构建GRNs，基于GRNs可以进行细胞聚类。&lt;/
      
    
    </summary>
    
      <category term="生物信息学" scheme="http://chenyin.top/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>生信分析工具-RaceID2+StemID</title>
    <link href="http://chenyin.top/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/20190315-98e6.html"/>
    <id>http://chenyin.top/生物信息学/20190315-98e6.html</id>
    <published>2019-03-15T08:17:11.000Z</published>
    <updated>2019-03-15T09:28:08.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>数据分析时要处理的噪声不仅来自实验误差和测量误差，基因表达和少量mRNA的扩增都会产生一定的噪声。其中来自生物过程的噪声可以通过大量测序来缓和。</p><p>如果根据某一时刻的转录表达情况推断细胞系谱结构一直是一个严峻的挑战。作者肯定了<a href="/生物信息学/20190315-643b.html">Wanderlust算法</a>的设计思想，但是同时对其设计的拓扑结构的合理性表示怀疑，并提出了自己的解决方案。</p><p>RaceID2算法旨在：基于单细胞转录组数据，通过聚类鉴定出干细胞</p><p>StemID算法旨在：利用RaceID2的聚类结果，构建系谱树</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法在小肠的Lgr5+细胞、骨髓造血干细胞上学习，在人类胰腺多能干细胞上测试。Lgr5+小鼠肠道干细胞群的分化过程研究已经发表，作为算法学习的基础数据集。</p><h2 id="RaceID"><a href="#RaceID" class="headerlink" title="RaceID"></a>RaceID</h2><p><a href="https://www.nature.com/articles/nature14966" target="_blank" rel="noopener">此处嘀向作者2015年发表的论文</a></p><h2 id="RaceID2"><a href="#RaceID2" class="headerlink" title="RaceID2"></a>RaceID2</h2><p>作者对自己已经发表的RaceID算法进行优化：RaceID使用K-means进行聚类，因此求所有样本平均值的做法使得RaceID对异常值十分敏感，同时RaceID使用<strong>间隔统计量</strong>（Gap Statistics, GS）确定分类个数；但是作者认为这种方法并不理想，因此在RaceID2中改用K-medoids方法聚类，并且依据类内散布饱和临界值为依据确定分类个数。K-medoids聚类方法使用类似于中位数的方法确定聚类中心，与K-means不同，它的聚类中心始终产生在样本点上。</p><p>RaceID2是一种改进的聚类算法，能够将大量细胞进行聚类，从而确定不同细胞群/亚群的分界线。</p><h2 id="StemID"><a href="#StemID" class="headerlink" title="StemID"></a>StemID</h2><p>StemID是一种系谱图推导方法，StemID的系谱图推导基于RaceID2的聚类结果。</p><p>下面是从原文摘录的算法流程图：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-15-000000.jpg" alt=""></p><p>图A是RaceID2的聚类结果，其聚类中心都在样本点上。</p><p>这里先介绍作者给出的一个<strong>感性假设</strong>：每个节点 $k$ (一个细胞)除了属于自身的第 $i$ 类外，它还将连接到一个其它的某个类 $j$ ，这个类 $j$ 实际意义等同于另一个的细胞群/亚群，细胞 $k$ 将倾向于朝细胞群 $j$ 分化。</p><p>如图A所示，Cluster 1的聚类中心是 $m_i$，这里 $i=1$，将 $m_i$ 与其它所有聚类中进行连接（如图A黑色矢量）。第 $i$ 类中的节点 $k$（蓝色矢量箭头处）与类中心 $m_i$ 组成了一个向量（如图A蓝色矢量）。蓝色矢量将在所有黑色矢量上产生一个 <strong>投影</strong>。我们取与 <strong>最大投影长度</strong> 相对应的那个外类作为 <strong>感性假设</strong> 中陈述的潜在分化方向。</p><p>如图B2所示，将所有节点转换成到之相对应的投影位置，此时所有节点都将落到由聚类中心组成的网络上。</p><p>此网络就是StenID算法所构建的系谱树框架。</p><p>给网络的边打分：映射后不同边上点的分布是不同的，对于某条边 $L$ 上的任意两点 $r_i$ 和 $r_j$，定义打分公式：</p><p>$$score=1-\max_{i,j{\in}L}{||r_i-r_j||}$$ </p><p>当 $score{\to}0$ 时说明该边上所有点非常紧密的靠近聚类中心。</p><p>p值计算：重复采样，略</p><p>细胞的熵得计算：略</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>作者自己分析了一下，在下面两种情况出现时算法可能不太灵光：</p><ol><li>出现中间过渡态细胞的样本缺失；</li><li>出现不直接关联的细胞。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Cell Stem Cell. 2016 Aug 4;19(2):266-277. doi: 10.1016/j.stem.2016.05.010. Epub 2016 Jun 23.<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4985539/" target="_blank" rel="noopener">De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome Data</a><br>Grün D1, Muraro MJ2, Boisset JC2, Wiebrands K2, Lyubimova A2, Dharmadhikari G3, van den Born M2, van Es J2, Jansen E2, Clevers H4, de Koning EJP3, van Oudenaarden A5.</p><p>github：<a href="https://github.com/dgrun/StemID" target="_blank" rel="noopener">StemID</a><br>omicX：<a href="https://omictools.com/stemid-tool" target="_blank" rel="noopener">stemid-tool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;数据分析时要处理的噪声不仅来自实验误差和测量误差，基因表达和少量mRNA的扩增都会产生一定的噪声。其中来自生物过程的噪声可以通过大量测序来缓
      
    
    </summary>
    
      <category term="生物信息学" scheme="http://chenyin.top/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>生信分析工具-Wanderlust</title>
    <link href="http://chenyin.top/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/20190315-643b.html"/>
    <id>http://chenyin.top/生物信息学/20190315-643b.html</id>
    <published>2019-03-15T06:57:30.000Z</published>
    <updated>2019-03-15T08:15:35.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以人类B细胞为例，确定每个细胞在相应细胞过程（例如细胞分化）中的先后顺序。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>输入</strong>：算法的输入是一个 $M{\times}N$ 的矩阵，其中 $M$ 是细胞数量，$N$ 是选取的marker数量。每个marker的丰度由<strong>质谱流式细胞技术</strong>(Mass Cytometry)测定。</p><p><strong>输出</strong>：每个细胞的路径打分。此打分值介于0~1之间：0表示路径起点细胞，1代表路径终点细胞。</p><p>Wanderlust实际上就是<strong>最近邻图</strong>(Nearest Neighbour Graph)与<strong>EM算法</strong>的组合。</p><p>下图是摘自原文的算法流程：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-15_153512.jpg" alt=""></p><p>图A是输入数据的形象表示。</p><p>1.凭先验知识确定一个<strong>起始节点</strong>（图B红色节点），<strong>随机</strong>确定 $nl$ 个<strong>路标节点</strong>（图B紫色节点）</p><p>为什么设置路标节点？路标节点起到缓冲噪声干扰的作用。相对于起始点，具有更小的<strong>最短路径距离</strong>（Shortest Path Distance）。而随机选取可以排除了先验知识的影响。</p><p>2.构建<strong>k-NNG</strong>，该图以<strong>邻接矩阵</strong>的方式进行存储，计算相连节点间的距离，可选的距离定义有欧式距离、余弦距离、……</p><p>3.NNG下采样：从这个k-NNG构造出 $l$ 个l-k-NNG。算法只在子图上迭代运行，最后取均值作为最终结果。</p><p>为什么采样成子图进行计算？前面构造的k-NNG实际上包含了许多与实际情况不符的连接，即“假边”。进一步的随机下采样使得这些“假边”在子图中出现一定程度的缺失，这将增强模型的适应能力（鲁棒性）。</p><p>对于每个子图进行迭代优化：</p><p>4.初始化每个节点（细胞）的路径打分；起始节点为0，终止节点为1，中间节点的初始打分为该节点到起始节点的最短路径距离。最短路径距离通过Dijkstra算法计算。</p><p>初始化两节点连接的方向：距离起始节点<strong>路径打分</strong>小的节点作为上游节点。</p><p>5.对每个目标节点 $t$ 和每个路标节点 $l$ 间的距离进行打分：</p><p>$$w_{l,t}=\frac{d(l,t)^2}{\sum_m{d(l,m)^2}}$$</p><p>这个打分有什么意义？尚未知晓</p><p>6.计算每个目标节点 $t$ 的路径打分，即该目标节点到所有路标节点距离的加权平均：</p><p>$$traj_t=\frac1{nl}\sum_l{w_{l,t}d(l,t)}$$</p><p>7.根据计算出来的路径打分计算新的方向。</p><p>8.重复步骤567直到路径打分收敛。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Cell. 2014 Apr 24;157(3):714-25. doi: 10.1016/j.cell.2014.04.005.<br><a href="https://www.ncbi.nlm.nih.gov/pubmed/24766814" target="_blank" rel="noopener">Single-cell trajectory detection uncovers progression and regulatory coordination in human B cell development.</a><br>Bendall SC1, Davis KL2, Amir el-AD3, Tadmor MD3, Simonds EF4, Chen TJ5, Shenfeld DK3, Nolan GP6, Pe’er D7.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;以人类B细胞为例，确定每个细胞在相应细胞过程（例如细胞分化）中的先后顺序。&lt;/p&gt;
&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; cl
      
    
    </summary>
    
      <category term="生物信息学" scheme="http://chenyin.top/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>监督学习-广义线性模型01-普通最小二乘法</title>
    <link href="http://chenyin.top/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20190225-724a.html"/>
    <id>http://chenyin.top/统计与机器学习/20190225-724a.html</id>
    <published>2019-02-25T02:53:41.000Z</published>
    <updated>2019-03-15T06:41:50.229Z</updated>
    
    <content type="html"><![CDATA[<p>线性模型：输出是输入的线性组合，即：</p><p>$$y(w,x)=w_0+w_1x_1+\cdots+w_px_p$$</p><p>在sklearn中，变量 <code>coef_</code> 存储向量 $w=(w_1,\cdots,w_p)$，变量 <code>intercept_</code> 存储 $w_0$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br></pre></td></tr></table></figure><hr><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p><strong>普通最小二乘法</strong>(Ordinary Least Squares)就是简单的计算残差和：</p><p>$$min_w{||Xw-y||_2}^2$$</p><p>这个算法叫做 <strong>线性回归</strong>(Linear Regression):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">estimator = linear_model.LineaRegression(...)</span><br></pre></td></tr></table></figure><p>简单的线性回归只在输入X数据集的各特征之间线性不相关时表现良好。</p><p>当X的特征线性相关时，估计结果受随机误差影响大，此时就需要进行模型的矫正。</p><hr><h1 id="脊回归-岭回归"><a href="#脊回归-岭回归" class="headerlink" title="脊回归/岭回归"></a>脊回归/岭回归</h1><p>当特征间 <strong>共线性</strong>（Collinearity）关系较强时，<strong>脊回归</strong>（Ridge Regression）可以使模型具有收缩能力。</p><p>这通过给线性回归添加L2正则项实现：</p><p>$$min_w{||Xw-y||_2}^2+\alpha{||w||_2}^2，其中\alpha\le0$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定关键超参数α的值</span></span><br><span class="line">estimator = linear_model.Ridge(alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>对于α，可以使用交叉验证进行最优解搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定α的取值范围，默认值如下</span></span><br><span class="line"><span class="comment"># cv指定交叉验证的折数，默认如下，默认使用留一交叉验证（Leave-One-Out CV）</span></span><br><span class="line">estimator = linear_model.RidgeCV(alpha=[<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>], cv=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="Lasso"><a href="#Lasso" class="headerlink" title="Lasso"></a>Lasso</h1><p>Lasso是用来估计稀疏系数的线性模型，和其变异体广泛用于语义压缩领域？</p><p>$$min_w\frac1{2n_{samples}}{||Xw-y||_2}^2+\alpha||w||_1，其中\alpha\le0$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># α默认值如下</span></span><br><span class="line">estimator = linear_model.Lasso(alpha=<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线性模型：输出是输入的线性组合，即：&lt;/p&gt;
&lt;p&gt;$$y(w,x)=w_0+w_1x_1+\cdots+w_px_p$$&lt;/p&gt;
&lt;p&gt;在sklearn中，变量 &lt;code&gt;coef_&lt;/code&gt; 存储向量 $w=(w_1,\cdots,w_p)$，变量 &lt;code&gt;i
      
    
    </summary>
    
      <category term="统计与机器学习" scheme="http://chenyin.top/categories/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>获得一组数的全排列</title>
    <link href="http://chenyin.top/python/20190221-9924.html"/>
    <id>http://chenyin.top/python/20190221-9924.html</id>
    <published>2019-02-21T08:24:14.000Z</published>
    <updated>2019-02-21T08:25:43.836Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(xs)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(xs,str):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">str2charArray</span><span class="params">(str)</span>:</span></span><br><span class="line">            charArray = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">                charArray.append(i)</span><br><span class="line">            <span class="keyword">return</span> charArray</span><br><span class="line">        xs = str2charArray(xs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(xs) == <span class="number">0</span> <span class="keyword">or</span> len(xs) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [xs]</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(xs)):</span><br><span class="line">        temp_list = xs[:]</span><br><span class="line">        temp_list.pop(i)</span><br><span class="line">        temp = permutation(temp_list)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">            j.insert(<span class="number">0</span>,xs[i])</span><br><span class="line">            result.append(j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>glob内建模块</title>
    <link href="http://chenyin.top/python/20190221-3133.html"/>
    <id>http://chenyin.top/python/20190221-3133.html</id>
    <published>2019-02-21T07:28:59.000Z</published>
    <updated>2019-02-21T08:14:07.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong>glob模块</strong> 是python的一个很基础、很简单的模块，用于匹配文件路径。</p><p>glob这个单词本身有“通配符”的意思，通配的一个很关键的应用就是筛选出符合条件的文件。</p><p>与python的另一个专门用于正则匹配的 <strong>re模块</strong> 不同，glob只需要三个通配符：<code>*</code>、<code>？</code>、<code>[]</code>。</p><p>以下是常见的匹配情形：</p><ol><li><code>glob.glob(&#39;/a/b/*.txt&#39;)</code>: 匹配目录 <code>/a/b/</code> 下的所有.txt文件</li><li><code>glob.glob(&#39;/a/b/^[xyz]*.txt&#39;)</code>: 匹配目录 <code>/a/b/</code> 下所有文件名以字母xyz中任意一个开始的文件</li><li><code>glob.glob(&#39;/a/*/*.txt&#39;)</code>: 匹配目录 <code>/a/</code> 下所有的.txt文件</li></ol><p>此外，<code>glob.glob()</code> 是一次查询完所有结果。在查询结果较多时，可以使用 <code>glob.iglob()</code> 迭代查询，<code>glob.iglob()</code> 返回一个<strong>生成器</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;glob模块&lt;/strong&gt; 是python的一个很基础、很简单的模块，用于匹配文件路径。&lt;/p&gt;
&lt;p&gt;glob这个单词本身有“通配符”的意思，通配的一个很关键的应用就是筛选出符合条件的文件。&lt;/p&gt;
&lt;p&gt;与python的另一个专门用于正则匹配的 &lt;s
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
      <category term="python模块" scheme="http://chenyin.top/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>os内建模块</title>
    <link href="http://chenyin.top/python/20190104-af30.html"/>
    <id>http://chenyin.top/python/20190104-af30.html</id>
    <published>2019-01-04T04:55:50.000Z</published>
    <updated>2019-02-22T05:57:41.834Z</updated>
    
    <content type="html"><![CDATA[<p><strong>os模块</strong> 用于处理文件系统中的文件和目录。</p><h1 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>os.getcwd()</td><td>当前脚本文件的工作目录</td></tr><tr><td>os.chdir(DIR)</td><td>切换工作目录至DIR，默认工作目录为脚本所在目录</td></tr></tbody></table><h1 id="目录的增删查改"><a href="#目录的增删查改" class="headerlink" title="目录的增删查改"></a>目录的增删查改</h1><table><thead><tr><th>新建目录</th></tr></thead><tbody><tr><td>os.mkdir(“A/B/“)</td><td>创建一个目录A/B/，不能递归创建，即要求目录A存在</td></tr><tr><td>os.makedirs(DIR)</td><td>创建一个目录DIR，与上面不同的是，可以递归创建目录</td></tr></tbody></table><table><thead><tr><th>删除目录</th></tr></thead><tbody><tr><td>os.rmdir(DIR)</td><td>当目录DIR为空时删除目录，不为空时报错</td></tr><tr><td>os.removedirs(DIR)</td><td>待查</td></tr></tbody></table><table><thead><tr><th>列举目录</th></tr></thead><tbody><tr><td>os.listdir(DIR)</td><td>列出<strong>直接</strong>属于目录DIR的文件和子目录</td></tr><tr><td>os.walk(DIR)</td><td>遍历目录DIR下所有的文件和目录，返回<strong>生成器</strong>，返回结果较复杂，待查</td></tr></tbody></table><table><thead><tr><th>文件和目录的重命名</th></tr></thead><tbody><tr><td>os.rename(OLD_NAME, NEW_NAME)</td><td></td></tr><tr><td>os.system(“COMMAMD_STRING”)</td><td>调用shell命令进行重命名</td></tr></tbody></table><h1 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h1><table><thead><tr><th>路径类型判断</th></tr></thead><tbody><tr><td>os.path.isfile(PATH)</td><td>判断是否为文件，是文件返回<code>True</code></td></tr><tr><td>os.path.isdir(PATH)</td><td>判断是否为目录，是目录返回 <code>True</code></td></tr><tr><td>os.path.exists(PATH)</td><td>判断是否存在，存在返回 <code>True</code></td></tr><tr><td>os.path.getsize(PATH)</td><td>是文件返回文件大小，是目录返回0</td></tr></tbody></table><table><thead><tr><th>路径的切割、合并</th></tr></thead><tbody><tr><td>os.path.split(‘1/2/3’)</td><td>分割成目录和文件，得到 <code>(&#39;1/2&#39;,&#39;3&#39;)</code></td></tr><tr><td>os.path.split(‘1/2/3/‘)</td><td>分割成目录和文件，得到 <code>(&#39;1/23&#39;,&#39;&#39;)</code></td></tr><tr><td>os.splitext(‘path/name.txt’)</td><td>分割出文件后缀，得到 <code>(&#39;path/name&#39;, &#39;.txt&#39;)</code></td></tr></tbody></table><table><thead><tr><th>路径的连接</th></tr></thead><tbody><tr><td>os.path.join(A, B)</td><td>使用默认路径分割符连接两个字符串，得到 <code>&quot;A/B&quot;</code></td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>os.sep 或 os.path.sep</td><td>当前系统下是使用的 <strong>路径分割符</strong></td></tr><tr><td>os.linesep</td><td>当前系统下使用的 <strong>行终止符</strong></td></tr><tr><td>os.environ</td><td>字典：环境变量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;os模块&lt;/strong&gt; 用于处理文件系统中的文件和目录。&lt;/p&gt;
&lt;h1 id=&quot;工作目录&quot;&gt;&lt;a href=&quot;#工作目录&quot; class=&quot;headerlink&quot; title=&quot;工作目录&quot;&gt;&lt;/a&gt;工作目录&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
      <category term="python模块" scheme="http://chenyin.top/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>获取当前文件所在的目录</title>
    <link href="http://chenyin.top/python/20190103-5c31.html"/>
    <id>http://chenyin.top/python/20190103-5c31.html</id>
    <published>2019-01-03T07:45:21.000Z</published>
    <updated>2019-02-22T04:54:21.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用os模块"><a href="#利用os模块" class="headerlink" title="利用os模块"></a>利用os模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前脚本文件所在的目录（工作目录）</span></span><br><span class="line">os.getcwd() <span class="comment"># Get current work directory</span></span><br></pre></td></tr></table></figure><p>这个方法不一定得到正确结果！</p><h1 id="利用内建数组sys-argv"><a href="#利用内建数组sys-argv" class="headerlink" title="利用内建数组sys.argv"></a>利用内建数组sys.argv</h1><p><code>sys.argv</code> 数组的第一个值（<code>sys.argv[0]</code>）存储的永远是当前脚本文件的绝对路径。</p><p>从这个路径中去掉文件名就是当前脚本文件所在目录的绝对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># current file directory</span></span><br><span class="line">cur_fdir = os.path.split(sys.argv[<span class="number">0</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用os模块&quot;&gt;&lt;a href=&quot;#利用os模块&quot; class=&quot;headerlink&quot; title=&quot;利用os模块&quot;&gt;&lt;/a&gt;利用os模块&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
      <category term="青铜派森" scheme="http://chenyin.top/tags/%E9%9D%92%E9%93%9C%E6%B4%BE%E6%A3%AE/"/>
    
  </entry>
  
  <entry>
    <title>博客改造计划</title>
    <link href="http://chenyin.top/%E9%80%9F%E6%9F%A5%E8%A1%A8/20190102-19a0.html"/>
    <id>http://chenyin.top/速查表/20190102-19a0.html</id>
    <published>2019-01-02T04:13:34.000Z</published>
    <updated>2019-03-15T06:54:43.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面元素位置控制"><a href="#页面元素位置控制" class="headerlink" title="页面元素位置控制"></a><span style="color:#666699">页面元素位置控制</span></h1><h2 id="右侧书签水平位置"><a href="#右侧书签水平位置" class="headerlink" title="右侧书签水平位置"></a>右侧书签水平位置</h2><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/02/2019-02-22_124005.jpg" alt=""></p><p>代码位置：<code>themes\raytaylorism\source\css\_partial\tablecontents.styl</code> <strong>第5行</strong></p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/02/2019-02-22_124219.jpg" alt=""></p><h2 id="正文区域宽度"><a href="#正文区域宽度" class="headerlink" title="正文区域宽度"></a>正文区域宽度</h2><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/02/2019-02-22_122808.jpg" alt=""></p><p>代码位置：<code>themes\raytaylorism\source\css\_base\lib_customize.styl</code> <strong>第5行</strong></p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/02/2019-02-22_123644.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;页面元素位置控制&quot;&gt;&lt;a href=&quot;#页面元素位置控制&quot; class=&quot;headerlink&quot; title=&quot;页面元素位置控制&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#666699&quot;&gt;页面元素位置控制&lt;/span&gt;&lt;/h1&gt;&lt;h2 id=&quot;右侧书签水平
      
    
    </summary>
    
      <category term="速查表" scheme="http://chenyin.top/categories/%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统信息查询</title>
    <link href="http://chenyin.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20190101-1ff5.html"/>
    <id>http://chenyin.top/操作系统/20190101-1ff5.html</id>
    <published>2019-01-01T13:53:38.000Z</published>
    <updated>2019-03-15T06:53:49.086Z</updated>
    
    <content type="html"><![CDATA[<p>emmmmmm,先记下来……</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p><code>uname -a</code>：内核、操作系统、CPU信息</p><p><code>head -n 1 /etc/issue</code>：操作系统版本</p><p><code>cat /proc/cpuinfo</code>：CPU信息</p><p><code>hostname</code>：计算机名</p><p><code>lspci -tv</code>：列出所有PCI设备</p><p><code>lsusb -tv</code>：列出所有USB设备</p><p><code>lsmod</code>：列出加载的内核模块</p><p><code>env</code>：查看环境变量</p><h1 id="内存与资源"><a href="#内存与资源" class="headerlink" title="内存与资源"></a>内存与资源</h1><p><code>free -m</code>：查看内存使用量和交换区使用量</p><p><code>df -h</code>：查看各分区使用情况</p><p><code>du -sh DIR</code>：查看目录DIR的大小，非本人的目录可能要使用 <code>sudo</code> 提权</p><p><code>grep MemTotal /proc/meminfo</code>：查看内存总量</p><p><code>grep MemFree /proc/meninfo</code>：查看空闲内存量</p><p><code>uptime</code>：查看系统运行时间、用户数、负载</p><p><code>cat /proc/loadavg</code>：查看系统负载</p><h1 id="磁盘和分区信息"><a href="#磁盘和分区信息" class="headerlink" title="磁盘和分区信息"></a>磁盘和分区信息</h1><p><code>mount | column -t</code>：查看挂接的分区状态</p><p><code>fdisk -l</code>：查看所有分区</p><p><code>swapon -s</code>：查看所有交换分区</p><p><code>hdparm -i /dev/hda</code>：查看磁盘参数</p><p><code>dmesg | grep IDE</code>：查看启动时IDE设备检测状况</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><code>ifconfig</code>：查看所有网络接口的属性</p><p><code>iptables -L</code>：查看防火墙设置</p><p><code>route -n</code>：查看路由表</p><p><code>netstat -lntp</code>：查看所有监听端口</p><p><code>netstat -antp</code>：查看所有已经建立的连接</p><p><code>netstat -s</code>：查看网络统计信息</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><code>ps -ef</code>：查看所有进程</p><p><code>top</code>：是实现显示进程状态</p><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p><code>w</code>：查看活动用户</p><p><code>id USERNAME</code>：查看用户USERNAME的信息</p><p><code>last</code>：查看用户登录日志</p><p><code>cut -d: -f1 /etc/passwd</code>：查看系统所有用户</p><p><code>cut -d: -f1 /etc/group</code>：查看系统所有组</p><p><code>crontab -l</code>：查看当前用户的计划任务</p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><code>chkconfig --list</code>：列出所有系统服务</p><p><code>chkconfig  --list | grep on</code>：列出所有启动的系统任务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;emmmmmm,先记下来……&lt;/p&gt;
&lt;h1 id=&quot;系统&quot;&gt;&lt;a href=&quot;#系统&quot; class=&quot;headerlink&quot; title=&quot;系统&quot;&gt;&lt;/a&gt;系统&lt;/h1&gt;&lt;p&gt;&lt;code&gt;uname -a&lt;/code&gt;：内核、操作系统、CPU信息&lt;/p&gt;
&lt;p&gt;&lt;code
      
    
    </summary>
    
      <category term="操作系统" scheme="http://chenyin.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="知识手册" scheme="http://chenyin.top/tags/%E7%9F%A5%E8%AF%86%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04LTS修改软件源</title>
    <link href="http://chenyin.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20181122-a661.html"/>
    <id>http://chenyin.top/操作系统/20181122-a661.html</id>
    <published>2018-11-21T16:07:36.000Z</published>
    <updated>2019-03-15T06:53:59.194Z</updated>
    
    <content type="html"><![CDATA[<p>1、备份原始源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>2、新建源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>写入以下内容（对于Ubuntu16.04LTS）：</p><pre># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</pre><p>其他版本的源列表可以在 <a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">这里</a> 查看。</p><p>3、刷新：<code>sudo apt-get update</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、备份原始源：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://chenyin.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu16.04LTS更新R到3.5.x</title>
    <link href="http://chenyin.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20181122-ad7f.html"/>
    <id>http://chenyin.top/操作系统/20181122-ad7f.html</id>
    <published>2018-11-21T16:02:52.000Z</published>
    <updated>2019-03-15T06:53:55.084Z</updated>
    
    <content type="html"><![CDATA[<p>1、<a href="/Linux/20181122-a661.html">系统换源</a></p><p>2、检查旧版本R</p><p>检查是否有旧版本的R：<code>R --verion</code></p><p>卸载旧版本的R：<code>sudo apt-get remove r-base-core</code></p><p>3、安装R3.5需要先添加源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository <span class="string">'deb https://cloud.r-project.org/bin/linux/ubuntu xenial-cran35/'</span></span><br></pre></td></tr></table></figure><p>添加上面这个源意味着在Ubuntu16.04LTS上可以安装R3.5。</p><blockquote><p><strong>xenial</strong> 意为“非洲地松鼠”，Ubuntu的每一个发行版都会有一个<a href="https://zh.wikipedia.org/wiki/Ubuntu发行版列表" target="_blank" rel="noopener">奇怪的名字</a>。</p></blockquote><p>然后更新源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>4、安装R3.5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install r-base r-base-dev</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;a href=&quot;/Linux/20181122-a661.html&quot;&gt;系统换源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、检查旧版本R&lt;/p&gt;
&lt;p&gt;检查是否有旧版本的R：&lt;code&gt;R --verion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;卸载旧版本的R：&lt;code&gt;sudo apt-ge
      
    
    </summary>
    
      <category term="操作系统" scheme="http://chenyin.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>python中运行shell命令</title>
    <link href="http://chenyin.top/python/20181121-b9c.html"/>
    <id>http://chenyin.top/python/20181121-b9c.html</id>
    <published>2018-11-21T08:35:13.000Z</published>
    <updated>2019-02-22T05:42:32.211Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Method 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">string = subprocess.check_output(<span class="string">"COMMAND_STRING"</span>, [shell=<span class="keyword">True</span>]).decode()</span><br></pre></td></tr></table></figure><p><strong>Method 2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">result = os.system(<span class="string">"COMMAND_STRING"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Method 1&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
      <category term="青铜派森" scheme="http://chenyin.top/tags/%E9%9D%92%E9%93%9C%E6%B4%BE%E6%A3%AE/"/>
    
  </entry>
  
  <entry>
    <title>自动加载自定义模块到环境</title>
    <link href="http://chenyin.top/python/20181121-d3bf.html"/>
    <id>http://chenyin.top/python/20181121-d3bf.html</id>
    <published>2018-11-21T08:31:49.000Z</published>
    <updated>2019-02-21T08:07:14.871Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>&lt;python安装根目录&gt;/site-packages</code>下新建一个文件（例如叫做 <code>my_module.pth</code>，在该文件中写入自定义模块文件的路径）。</p><p>为什么？</p><p>python在搜寻<code>sys.path</code>中的目录时如果遇到<code>.pth</code>文件加自动添加进环境</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;&amp;lt;python安装根目录&amp;gt;/site-packages&lt;/code&gt;下新建一个文件（例如叫做 &lt;code&gt;my_module.pth&lt;/code&gt;，在该文件中写入自定义模块文件的路径）。&lt;/p&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;p&gt;python在搜寻&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://chenyin.top/categories/python/"/>
    
    
      <category term="青铜派森" scheme="http://chenyin.top/tags/%E9%9D%92%E9%93%9C%E6%B4%BE%E6%A3%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux-vim设置优化</title>
    <link href="http://chenyin.top/os/20181121-5ec8.html"/>
    <id>http://chenyin.top/os/20181121-5ec8.html</id>
    <published>2018-11-21T08:25:38.000Z</published>
    <updated>2019-03-21T01:54:46.146Z</updated>
    
    <content type="html"><![CDATA[<p>设置tab宽度，显示行号，自动缩进…<br><code>vim ~/.vimrc</code> 打开文件（不存在则新建），键入（#后面为注释）：</p><pre># 将tab替换为4个空格set tabstop=4# Backspace时删除一个tabset softtabstop=4        # 显示行号set nu#自动缩进                set autoindent</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设置tab宽度，显示行号，自动缩进…&lt;br&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt; 打开文件（不存在则新建），键入（#后面为注释）：&lt;/p&gt;
&lt;pre&gt;# 将tab替换为4个空格
set tabstop=4

# Backspace时删除一个tab
set so
      
    
    </summary>
    
      <category term="os" scheme="http://chenyin.top/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>HttpRequest对象</title>
    <link href="http://chenyin.top/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-f755.html"/>
    <id>http://chenyin.top/IT开发笔记/20181121-f755.html</id>
    <published>2018-11-21T08:18:44.000Z</published>
    <updated>2019-03-15T06:33:45.451Z</updated>
    
    <content type="html"><![CDATA[<p>每个<strong>view函数</strong>函数的第一个参数都是HttpRequest对象，包含当前<strong>请求URL</strong>的一些信息<br>HttpRequest对象实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 属性</span></span><br><span class="line">request.path <span class="comment"># str类型，请求页面的全路径，不包括域名</span></span><br><span class="line">request.method <span class="comment"># str类型，值为'GET'或者'POST'</span></span><br><span class="line">request.GET <span class="comment"># QueryDict实例</span></span><br><span class="line">request.POST <span class="comment"># QueryDict实例，注意区分POST为空和POST的请求内容为空，判断是否为POST方法使用method属性</span></span><br><span class="line">request.COOKIES <span class="comment"># 标准python字典对象(用&#123;&#125;表示)，&#123;str:str&#125;</span></span><br><span class="line">request.FILES <span class="comment"># 类字典对象（？），包含所有上传文件</span></span><br><span class="line"><span class="comment"># 形式为：XxxDict&#123;name: &#123;'filename':..., 'content-type':..., 'content':...&#125;&#125;</span></span><br><span class="line"><span class="comment"># 上面的name变量的值是&lt;input type="file" name="..."&gt;中name属性的值</span></span><br><span class="line"><span class="comment"># 只有POST请求并且啥啥啥的FILES属性才会有值，否则为空</span></span><br><span class="line">request.META <span class="comment"># 可用的http头部信息字典</span></span><br><span class="line">request.user <span class="comment"># django.contrib.auth.models.User对象实例，代表当前登录的用户</span></span><br><span class="line"><span class="comment"># 用户未登录则为django.contrib.auth.models.AnonymousUser对象实例</span></span><br><span class="line"><span class="comment"># 通过 request.user.is_authenticated() 判断用户是否登录</span></span><br><span class="line"><span class="comment"># 需要激活django的AuthenticationMidlleware属性</span></span><br><span class="line">request.session <span class="comment"># 当前会话的字典对象，需要激活啥啥啥</span></span><br><span class="line">request.raw_post_data <span class="comment"># 未解析的原始post数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法</span></span><br><span class="line">request.__getitem__(key) <span class="comment"># 取出GET/POST中的值，优先POST</span></span><br><span class="line">request.has_key(key) <span class="comment"># 检查GET/POST是否包含key</span></span><br><span class="line">request.get_full_path() <span class="comment"># 返回包含查询字符串的请求路径字符串</span></span><br><span class="line">request.is_secure() <span class="comment"># 如果发出的是HTTPS安全请求返回True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个&lt;strong&gt;view函数&lt;/strong&gt;函数的第一个参数都是HttpRequest对象，包含当前&lt;strong&gt;请求URL&lt;/strong&gt;的一些信息&lt;br&gt;HttpRequest对象实例：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;
      
    
    </summary>
    
      <category term="IT开发笔记" scheme="http://chenyin.top/categories/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Django官方文档笔记-request(GET+POST)属性与QueryDict类.md</title>
    <link href="http://chenyin.top/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-8d33.html"/>
    <id>http://chenyin.top/IT开发笔记/20181121-8d33.html</id>
    <published>2018-11-21T08:13:38.000Z</published>
    <updated>2019-03-15T06:34:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>在HttpRequest对象中，GET和POST属性的值都是QueryDict的实例</p><p>QueryDict用来处理<strong>单键对应多值</strong>的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qd = django.http.QueryDict(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">#与普通字典一致的方法</span></span><br><span class="line">qd.__getitem__(key) <span class="comment"># 返回key对应值列表的最后一个值</span></span><br><span class="line">qd.__setitem__(key, value_list) <span class="comment"># GET和POST属性值字典不允许被直接修改，因此此方法只能用于该字典的拷贝上</span></span><br><span class="line">qd.get(key, IF_NONE) <span class="comment"># 如果key存在返回key对应值列表的最后一个值</span></span><br><span class="line">qd.update(d) <span class="comment"># D为QD(查询字典)或者D(python字典)都可以,如果key存在，执行添加而不是替换</span></span><br><span class="line">qd.items() <span class="comment"># 返回键值对，值是key对应的值列表的最后一个值（单值）</span></span><br><span class="line">qd.values() <span class="comment"># 跟items一样使用单值逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#特有方法</span></span><br><span class="line">qd.copy() <span class="comment"># 返回可更改的拷贝（比如可以使用__setitem__)</span></span><br><span class="line">qd.getlist(key) <span class="comment"># 返回key对应的python列表</span></span><br><span class="line">qd.setlist(key, value_list) <span class="comment"># 无须拷贝直接修改？？？？？</span></span><br><span class="line">qd.appendlist(key, value) <span class="comment"># 给已经存在的key的列表中添加一个值</span></span><br><span class="line">qd.setlistdefault(ket, value_list)</span><br><span class="line">qd.lists() <span class="comment"># 作用与items类似，不执行单值逻辑，也就是说键值对的值是所有值的列表</span></span><br><span class="line">qd.urlencode(key) <span class="comment"># 返回查询字符串格式的字符串，如'a=3&amp;a=4&amp;a=5'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在HttpRequest对象中，GET和POST属性的值都是QueryDict的实例&lt;/p&gt;
&lt;p&gt;QueryDict用来处理&lt;strong&gt;单键对应多值&lt;/strong&gt;的情况&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="IT开发笔记" scheme="http://chenyin.top/categories/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
