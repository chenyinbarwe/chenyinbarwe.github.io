<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>降维03 - SNE原理</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-80ae.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-80ae.html</url>
      
        <content type="html"><![CDATA[<p><strong>随机近邻嵌入算法 (Stochastic Neighbour Embedding, SNE)</strong> 由Hinton在2003年提出来的基于条件概率、只保留局部特征的非线性降维方法。 <a id="more"></a></p><h1 id="定义条件概率"><a href="#定义条件概率" class="headerlink" title="定义条件概率"></a>定义条件概率</h1><p>部分情况下，高维空间中两个点间的相似性可以用基于欧式距离的<strong>不相似度</strong> $d_{ij}$ 来衡量：<br>$$d_{ij}^2=\frac{||x_i-x_j||^2}{2\sigma_i^2}$$</p><p>SNE用<strong>条件概率</strong>来代替欧式距离度量两个高维数据点间的相似性。即：以点 $x_i$ 为中心，点 $x_i$ 选择 $x_j$ 作为自己邻居的概率记为 $p(x_j|x_i)$，定义<br>$$p_{ij}=p(x_j|x_i)=\frac{\exp(-d_{ij}^2)}{\sum_{k{\ne}i}{\exp(-d_{ik}^2)}} $$<br>注意这里对于 $p(x_i|x_i)$ 的理解有点怪异：它表示点 $x_i$ 选择自己作为邻居的概率，显然自己永远不可能是自己的邻居，所以 $p(x_i|x_i)=0$，而不是1。</p><h1 id="确定方差的确定"><a href="#确定方差的确定" class="headerlink" title="确定方差的确定"></a>确定方差的确定</h1><p>上式中的 $\sigma_i^2$ 是以 $x_i$ 为中心的高斯分布的<strong>方差</strong>：不同点周围的点的密度是不一样的，所以每个点的高斯分布对应的方差 $\sigma_i^2$ 也不相同，周围点密度大的中心点对应的方差应该较小。作者定义了<strong>困惑度 (perplexity)</strong> $k$ ：手动指定的超参，代表某个点的有效邻居数，这个值对所有点都是常数。$\sigma_i^2$ 的取值将使得以点 $x_i$ 为中心选择其它所有点作为邻居的分布对应的<strong>熵</strong>等于 $\log{k}$，即<br>$$-\sum_{j{\ne}i}{p(x_j|x_i)\log_2{p(x_j|x_i)}}=\log_2k$$<br>理论上可以通过上面的式子可以针对每个点 $x_i$ 解出对应的 $\sigma_i^2$。</p><h1 id="映射到低维空间"><a href="#映射到低维空间" class="headerlink" title="映射到低维空间"></a>映射到低维空间</h1><p>在低维空间（二维或者三维）确定一点 $y_i$，它与高维空间的点 $x_i$ 对应，我们手动设置点 $y_i$ 的条件概率分布，即固定以 $y_i$ 为中心点的高斯分布对应的方差为 $\frac12$，当 $j{\ne}i$ 时：<br>$$ q_{ij}=q(y_j|y_i) = \frac {\exp{(-||y_i-y_j||^2)}} {\sum_{k{\ne}i}{\exp{(-||y_i-y_k||^2)}}} $$<br>当j=i时 $q(y_j|y_i)=0$ 。</p><p>此时，如果低维点 $y_i$ 能够正确表示高维点 $x_i$，意味着 $q(y_j|y_i)=p(x_j|x_i)$。为了使两个概率（近似）相等，我们可以最小化<strong>KL散度</strong>。损失函数如下：<br>$$C=\sum_iKL(P_i|Q_i)=\sum_i\sum_jp_{ij}\log\frac{p_{ij}}{q_{ij}}$$</p><ul><li>$P_i$ 表示：给定点 $x_i$，其它所有点的条件概率分布；</li><li>$Q_i$ 表示：给定低维空间映射点 $y_i$，其它所有低维映射点的条件概率分布。</li></ul><p><strong>KL散度只能保留局部结构</strong> </p><p>KL散度中包含 $\log\frac{p_{ij}}{q_{ij}}$ 意味着这个映射不是对称的，即：</p><ul><li>使用距离较小的低维点表示距离较大的高维点时，$\log\frac{p_{ij}}{q_{ij}}$ 倾向于小于0，则损失C较小；</li><li>使用距离较大的低维点表示距离较小的高维点时，$\log\frac{p_{ij}}{q_{ij}}$ 倾向于大于0，则损失C较大。</li></ul><p>这里就存在一个问题：当两个高维点距离很远，而我构造两个距离很近的低维点能够使损失函数更小，却与实际的目的不相符！所以，SNE算法只能保留数据的局部结构，即高维空间中距离近的点在低维空间中距离仍然很近，但是远的点就嘿嘿嘿了。</p><h1 id="最小化损失函数"><a href="#最小化损失函数" class="headerlink" title="最小化损失函数"></a>最小化损失函数</h1><p>从 $q_{ij}$ 的定义式的分母部分可知，低维空间中点 $y_i$ 选择点 $y_j$ 的概率 $q_{ij}$ 与低维空间中的每一个映射点都有关系（分母起到了normalization的作用），但是求导结果却十分简洁：<br>$$\frac{\partial{C}}{\partial{y_i}}=2\sum_k{(y_i-y_k)[(p_{ik}-q_{ik})+(p_{ki}-q_{ki})]}$$<br>想沿着所有点以最陡梯度下降是不现实的，不仅低效，还可能陷入糟糕费解的局部最优。这里作者采用的是<strong>随机抖动</strong> (random jitter) 的技巧，尽管还是很慢，不过已经能够节省大量时间并且找到更优的局部解。所谓的随机抖动就是将所有的低维空间的映射点随机初始化在原点附近。当然还有其它的解决办法，例如对perplexity退火……</p><p><strong>更好的优化策略（简要摘录）</strong></p><p>随机抖动的最快梯度下降尽管能得到较优解，却需要耗费大量的时间：3000个高维点就要花上几个小时。作者提出了几种更加棒的优化策略：</p><ol><li>忽略 $p_{ij}$, $p_{ji}$, $q_{ij}$ 和 $q_{ji}$ 都很小的点对的计算；</li><li>另一个复杂版本的优化，这里暂时忽略；</li><li>给低维数据点增加维度并给这些额外的维度施加惩罚，在搜索最优解时这些额外的维度能够帮助绕过低维障碍，同时增大惩罚以保持平衡。</li></ol><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="http://papers.nips.cc/paper/2276-stochastic-neighbor-embedding.pdf" target="_blank" rel="noopener">Hinton, G. E., &amp; Roweis, S. T. (2003). <strong>Stochastic neighbor embedding</strong>. In Advances in neural information processing systems (pp. 857-864).</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
            <tag> 非线性降维 </tag>
            
            <tag> SNE </tag>
            
            <tag> t-SNE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降维02 - 主成分分析 (PCA)</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-c024.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-c024.html</url>
      
        <content type="html"><![CDATA[<p>PCA的大名如雷贯耳，曾经的我也以为PCA是个什么很复杂的东西，但是学习了<strong>线性代数</strong>之后才发现，PCA的原理简单而不失优雅，粗暴而不失趣味。<a id="more"></a></p><p>PCA是最易于理解的<strong>特征提取</strong>过程：通过对原始特征的<strong>线性组合</strong>构造新的“特征”，这些特征不同于原始特征，但是又能与原始特征一样表达原始数据的信息。</p><p><strong>PCA (Primary Component Analysis, 主成分分析)</strong> 为什么叫做主成分分析呢？因为PCA构造出的新特征地位并不是等同的，即这些新特征的重要程度存在差异：</p><ul><li><strong>第一主成分 (the first component)</strong> 是新特征中最重要的特征，它在所有新特征中方差最大，这意味着它对数据变异的贡献是最大的；</li><li><strong>第二主成分 (the second component)</strong> 在保证不影响第一主成分的基础上试图解释剩下的变异（即总变异 - 第一主成分引起的变异）；</li><li><strong>第三主成分 (the third component)</strong> 在不保证第一和第二主成分呢的基础上试图解释剩下的变异（即总变异 - 第一主成分引起的变异 - 第二主成分引起的变异）;</li><li>依次类推……</li></ul><h1 id="线代原理"><a href="#线代原理" class="headerlink" title="线代原理"></a>线代原理</h1><p>预备知识：线性代数（矩阵运算、特征值&amp;特征向量、特征值分解）</p><h2 id="可对角化"><a href="#可对角化" class="headerlink" title="可对角化"></a>可对角化</h2><p>如果一个n阶方阵A相似于对角矩阵，即存在可逆矩阵$P$使得$P^{-1}AP$是对角矩阵，则称方阵A是<strong>可对角化</strong>的。</p><p><strong>n阶方阵A可对角化的充要条件是A每个特征值的几何重数与代数重数相等</strong>：<strong>代数重数</strong>指<strong>特征多项式</strong>中该特征值的幂次，<strong>几何重数</strong>指特征值对应的线性无关的特征向量的个数。</p><p><strong>n阶方阵A可对角化的充要条件是A有n个线性无关的特征向量</strong>：几何重数与代数重数相等意味着n个线性无关的特征向量。</p><p>即使方阵A可逆也不能保证每个特征值的代数重数与几何重数相等，因此A可逆不是A可对角化的充要条件！</p><h2 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h2><p>如果矩阵A是一个<strong>可对角化</strong>的方阵，它就可以进行特征值分解，即A可表示为：<br>$$A=Q{\Lambda}Q^{-1}$$<br>其中</p><ul><li>$Q$ 是n阶方阵，它的n个列向量是方阵A的n个特征向量</li><li>$\Lambda$ 是对角方阵，对角线元素是方阵A的特征值，其位置与 $Q$ 中的特征向量位置相对应</li></ul><p>特征值分解的应用？求逆。<br>如果方阵A是<strong>非奇异矩阵</strong>（即可以进行特征值分解且特征值不含0），则 $A^{-1}=Q{\Lambda}^{-1}Q^{-1}$，其中 $[{\Lambda}^{-1}]_{ii}=\frac1{\lambda_i}$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>特征值分解对A的要求格外严格：可逆、特征值不含0、方阵……<br>放松特征值分解的限制，将A扩展到任意 $m{\times}n$ 的矩阵即得到 <strong>奇异值分解 (Singular Value Decomposition, SVD)</strong> 。</p><p>假设M是定义在<strong>实数域</strong>或者<strong>复数域</strong>上的 $m{\times}n$ 阶的矩阵：<br>$$M=U{\Sigma}V^\ast$$<br>其中</p><ul><li>U是 $m{\times}m$ 阶<strong>酉矩阵</strong>：U的m个列向量实际上是 $M^{\ast}M$ 的特征向量，称为M的<strong>左奇异向量</strong>。</li><li>$\Sigma$ 是 $m{\times}n$ 阶<strong>非负实数对角矩阵</strong>：对角线元素称为M的<strong>奇异值</strong>，一般情况下奇异值按<strong>从大到小</strong>的顺序排列！</li><li>$V^\ast$ 是 $V$ 的<strong>共轭转置</strong>，是 $n{\times}n$ 阶<strong>酉矩阵</strong>：V的n个列向量实际上是 $MM^\ast$ 的特征向量，称为M的<strong>右奇异向量</strong>。</li></ul><blockquote><p><strong>共轭转置</strong>：共轭转置与转置是两个概念，当矩阵定义在实数域上时二者结果相同，矩阵A的共轭转置记为 $A^\ast$，定义如下：<br>$$A^\ast=(\overline{A})^T=\overline{A^T}$$<br>其中，$\overline{A}$ 表示对A的元素<strong>复共轭</strong>，当A定义在实数域时 $\overline{A}=A$。</p></blockquote><p>当矩阵M定义在实数域时有：<br>$$M=U{\Sigma}V^T$$<br>我们在应用SVD时一般都是定义在实数域上的哟~</p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p>上面提到了对于任意 $m{\times}n$ 阶矩阵M的SVD分解：<br>$$M_{m{\times}n}=U_{m{\times}m}{\Sigma_{m{\times}n}}V_{n{\times}n}^T$$<br>直观图如下（这里假设样本数量m多于特征数量n，这意味着M有n个奇异值）：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-25_142825.png" alt=""><br>其中 $\Sigma$ 矩阵很有意思，当m&gt;n时，矩阵 $\Sigma_{m{\times}n}$ 中只有子矩阵 $\Sigma_{n{\times}n}$ 的对角线上的值不为0，如下图所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-25_144213.png" alt=""></p><p>以scRNA测序为例：假设在表达谱矩阵中，一行表示一个细胞中不同基因的表达量，一列表示一个基因在不同细胞中的表达量。这与我们的习惯（一列表示一个细胞，一行表示一个基因）有所不同！</p><p>对应到上述SVD分解式我们发现，n表示细胞数量，m表示基因数量。我们降维的结果肯定是要保证细胞总数m不变，而将基因数目从n减小到k。</p><p>具体的，取 $\Sigma$ 中最大的k个奇异值，即取 $\Sigma_{k{\times}k}$ 子矩阵，相应的取U的前k列和V的前k列（即$V^\ast$的前k行），即：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-25_150510.png" alt=""><br>此时<br>$$M_{m{\times}n}=U_{m{\times}k}{\Sigma_{k{\times}k}}V_{k{\times}n}^T$$<br>上式中的 $U_{m{\times}k}$ 就是 $M_{m{\times}n}$ 从n维特征空间降到k维特征空间的结果。注意矩阵 $U_{m{\times}k}$ 的k个列向量并不在矩阵  $M_{m{\times}n}$ 中，而是M中的n个列向量线性组合的结果。</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in python</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降维01 - 特征选择和特征提取</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-d2ce.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190325-d2ce.html</url>
      
        <content type="html"><![CDATA[<p>大数据包含了丰富的先验知识，即几乎包含了一切我们感兴趣的信息。但是数据量过大也会使我们在分析时感到茫然无措。特征过多使得我们不可能对单个特征进行详细解析，大部分时候我们是将所有特征当成一个整体进行考虑，或者分析特征之间的关系。对高维数据数据进行预处理是一种不错的选择，此时各种各样的<strong>降维</strong>浓缩技术应运而生。<a id="more"></a></p><p>降维的好处有哪些？</p><ol><li>减少数据维度，存储数据需要的空间也会减少（盘霸可忽略~）；</li><li>低维数据可以减少计算量，缩短模型训练时间；</li><li>很多算法在高维数据上的表现远远没有在低维数据上好；</li><li>去掉冗余特征（强相关特征），提高数据的质量；</li><li>有助于可视化，我们只能形象观察三维及以下的数据！</li></ol><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>降维总是围绕着减少特征数进行的，根据对特征的操作可分为：</p><ul><li><strong>特征选择</strong>：保留原始特征集的子集，即选取部分原始特征；</li><li><strong>特征提取</strong>：构造不同于原始特征的新特征，新特征往往是原始特征的组合，替代原始特征表达原始数据想表达的信息。<br>特征提取是降维算法研究的核心内容。</li></ul><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>特征选择只是对每个特征进行评估，去掉不重要的或者选出重要的：</p><ol><li>缺失值比率：按缺失值比率删除特征；</li><li>低方差滤波：删除方差小的特征；</li><li>高相关滤波：只保留高相关特征中的一个；</li><li>随机森林：计算每个特征的重要性；</li><li>前向特征选择：依次增加特征数检验模型性能；</li><li>反向特征消除：依次减少特征数检验模型性能。</li></ol><h1 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h1><p>特征提取才是降维思想的核心内容，降维算法家族枝繁叶茂，先做一个总体分类：<img src="" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper3 - RUV算法移除批次效应 (Davide Risso, 20140824)</title>
      <link href="/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190322-afa7.html"/>
      <url>/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190322-afa7.html</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p> Gagnon-Bartsch et al.提出了RUV-2用来标准化<strong>连续的</strong>微阵列数据，移除不需要的变异。这里基于前面的方法进行扩展，用以标准化<strong>离散的</strong>RNA测序数据。</p><p> 对于表达矩阵（样本数 $n{\times}J$ 基因数）,构建<strong>泛化线性模型</strong> (Generalized Linear Model, GLM):<br>$$ \log{E[Y|W,X,O]}=W\alpha+X\beta+O $$<br><a id="more"></a><br>参数意义如下：</p><ul><li>$Y$ 是 $n{\times}J$ 的表达矩阵；</li><li>$W$ 是 $n{\times}k$ 与<strong>不需要的变异</strong>相关的<strong>多余变异相关矩阵</strong>（k是不需要的变异相关的变量的个数），$\alpha$ 是 $k{\times}J$ 的多余变异相关矩阵的系数（参数）；</li><li>$X$ 是 $n{\times}p$ 与<strong>感兴趣的变异</strong>相关的<strong>期望变异相关矩阵</strong>（p是感兴趣的变异相关的变量的个数），$\beta$ 是 $p{\times}J$ 的期望变异相关矩阵的系数（参数）；</li><li>$O$ 是一个 $n{\times}J$ 的矩阵，它可以置零，也可以包含其它的标准化过程（如<a href="https://en.wikipedia.org/wiki/Quantile_normalization" target="_blank" rel="noopener">UQ标准化</a>）。</li><li>矩阵 $X$ 是一个随机变量，是我们实验的测量值，是已知的（先验）。</li><li>矩阵 $W$ 是未观测的随机变量；$\alpha$、$\beta$、$k$ 都是未知参数。</li></ul><p>不同于先前的标准化方法，RUV可以使用GLM标准化技术同时标准化reads计数（$W\alpha$）和推断差异表达（$X\beta$）。标准化的计数也可以通过由原始计数对不需要的因子进行回归分析后求残差得到，但是直接从原始计数中移除不需要的因子（$W\alpha$）可能会损失掉 $X$ 的一部分。[<a href="">reference</a>]</p><p>同时估计 $W$, $\alpha$, $\beta$ 和 $k$ 是很难的。对于一个给定的 $k$ 值，我们尝试着用下面三种方法对$W$ 进行估计：</p><h2 id="1-基于阴性对照基因的RUVg"><a href="#1-基于阴性对照基因的RUVg" class="headerlink" title="1. 基于阴性对照基因的RUVg"></a>1. 基于阴性对照基因的RUVg</h2><ol><li>假设我们鉴定出了一个阴性对照基因 (negative control genes) 的集合（大小为 $J_c$），例如不差异表达的基因，对这个基因集合来说 $\beta_c=0$ 即 $\log{E[Y_c|W,X,O]}=W\alpha_c+O_c$，公式中的下标c将矩阵限制在了大小为 $J_c$ 的基因集合里。</li><li>定义 $Z=\log{Y}-O$，$Z^\ast$ 是 $Z$ 列向量中心化（$Z$ 的各个列向量均值都为0）的结果。</li><li>对 $Z_c^\ast$ 进行奇异值分解 (singular value decomposition, SVD) 即 $Z_c^\ast=U{\Lambda}V^T$。矩阵 $U$ 是 $n{\times}n$ 列正交矩阵，它的列向量是 $Z^\ast$ 的左奇异向量集；矩阵 $V$ 是 $J_c{\times}J_c$ 的列正交矩阵，它的列向量是 $Z^\ast$ 的右奇异向量集；$\Lambda$ 矩阵是由 $Z^\ast$ 的奇异值组成的非方形对角矩阵，大小为 $n{\times}J_c$。$Z^\ast$ 最少有 $\min{(n,J_c)}$ 个奇异值。对于一个给定的 $k$，通过 $\widehat{W\alpha_c}=U\Lambda_kV^T$ 估计 $W\alpha_c$，通过 $\hat{W}=U\Lambda_k$ 估计 $W$。$|lambda_k$ 是由 $\Lambda$ 导出的大小为 $n{\times}J_c$ 的非方形对角矩阵，保留 $\Lambda$ 中最大的 $k$ 个奇异值，将其它的奇异值置为0。</li><li>将 $\hat{W}$ 带入上面基于 $J$ 个基因构建的公式中，通过GLM回归估计 $\alpha$ 和 $\beta$。</li><li>（可选）将标准化的读段计数定义为 $Z$ 对 $\hat{W}$ 的普通最小二乘回归 (ordinary least squares, OLS) 的残差。 </li></ol><p>这是最基础的RUV-2的离散版本。其中的关键假设是我们能够找到这个阴性对照基因集合。然而，RUV-2已被证实对对照基因的选择十分敏感。我们因此考虑下面的两种方法：RUVr不需要阴性对照基因，RUVs对阴性对照基因选择的鲁棒性更强。</p><h2 id="2-基于残差的RUVr"><a href="#2-基于残差的RUVr" class="headerlink" title="2. 基于残差的RUVr"></a>2. 基于残差的RUVr</h2><ol><li>计算残差矩阵 $E(n{\times}J)$: 计数矩阵 $Y(n{\times}J)$ 关于感兴趣的协变量矩阵 $X(n{\times}J)$ 的初步GLM回归，例如异常值残差。这里用于回归计算的计数矩阵可以是未标准化的原始数据，也可以是经过其它标准化工具（例如UQ）处理过的数据。</li><li>对残差进行奇异值分解，即 $E=U{\Lambda}V^T$，通过 $\hat{W}=U\Lambda_k$ 估计 $w$。接下来的步骤与 <code>RUVg</code> 的第4、5步相同。</li></ol><h2 id="3-基于重复-阴性对照样本的RUVs"><a href="#3-基于重复-阴性对照样本的RUVs" class="headerlink" title="3. 基于重复/阴性对照样本的RUVs"></a>3. 基于重复/阴性对照样本的RUVs</h2><ol><li>假设在多个复制样本中具有生物学特征的（我们感兴趣的）某些协变量的表达量可看作恒定的，它们的计数差异与<code>RUVg</code>中的阴性对照基因一样，对我们后续的研究没有影响。现在假设有 $R$ 个复制组，$r(i){\in}{1,…,R}$ 表示样本 $i$ 所属的复制组；如果样本 $i$ 不属于任何一个复制组，则 $r(i)=0$。例如，对于SEQC数据集，样本A和样本B各自的64个<strong>复制本</strong>（$=4[\text{libraries}]{\times}2[\text{flow-cell}]{\times}8[\text{lanes}]$）分别组成了一个<strong>复制组</strong>。</li><li>对每一个复制本对应的计数矩阵进行<strong>列中心化</strong>处理，即矩阵各个列向量的均值都为0。去掉不属于预期复制组的样本，即筛选出 $n_d=\sum_i{I(r(i)\ne0)}$ 个样本对应的列中心化后的计数子矩阵 $Y_d(n_d{\times}J)$。 此时 $\log{E[Y_d|W,X,O]}=W_d\alpha+O_d$，对应的矩阵大小是 $(n_d{\times}J){\leftarrow}({n_d\times}k)({k\times}J)+(n_d{\times}J)$。</li><li>定义 $Z_d=\log{Y_d}-O_d$，$Z_d^\ast$ 是 $Z_d$ 列中心化的结果，$Z_d^\ast=U{\Lambda}V^T$。通过 $\hat{\alpha}=\Lambda_kV^T$（保留最大的 $k$ 个奇异值，$k{\le}\min{(n_d,J)}$）来估计 $\alpha$。</li><li>在所有 $n$ 个原始数据和 $J_c$ 个阴性对照基因上对 $Z_c$ 进行最小二乘回归（OLS）。估计讨厌因子 $W$：$\hat{W}=Z_c\hat\alpha_c^T(\hat\alpha_c\hat\alpha_c^T)^{-1}$。接下来的步骤与 <code>RUVg</code>的第4、5步相同。</li></ol><hr><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="两个数据集"><a href="#两个数据集" class="headerlink" title="两个数据集"></a>两个数据集</h2><ol><li><strong>SEQC data set</strong>: The third phase of the MicroArray Quality Control (MAQC) project, also known as the Sequencing Quality Control17 (SEQC) project, aims to assess the technical performance of high-throughput sequencing platforms by generating benchmarking data sets.</li><li><strong>Zebrafish (斑马鱼) data set</strong>: All procedures were conducted in compliance with US federal guidelines in an AAALAC-accredited facility and were approved by the UC Berkeley Office of Animal Care and Use. </li></ol><h2 id="两种讨厌因子"><a href="#两种讨厌因子" class="headerlink" title="两种讨厌因子"></a>两种讨厌因子</h2><p>本文分析了两种讨厌因子：<strong>library preparation</strong> &amp; <strong>flow-cell effects</strong>。</p><p><strong>flowcell</strong>：流动室，别称鞘流池、流动池，是流式细胞技术的基础关键部件。大概长这个样子：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/flowcell-350x2332.jpg" width="100%"></p><p>作者用<strong>正交的主成分图</strong>展示了这两种讨厌因子：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-22_101808.jpg" width="100%"><span style="font-size:16px;color:gray">Scatterplot matrix of first three principal components (PC) for unnormalized counts (log scale, centered). The principal components are orthogonal linear combinations of the original 21,559-dimensional gene expression profiles, with successively maximal variance across the 128 samples, that is, the first principal component is the weighted average of the 21,559 gene expression measures that provides the most separation between the 128 samples. Each point corresponds to one of the 128 samples. The four sample A and the four sample B libraries are represented by different shades of blue and red, respectively (16 replicates per library). Circles and triangles represent samples sequenced in the first and second flow-cells, respectively. As expected for the SEQC data set, the first principal component is driven by the extreme biological difference between sample A and sample B. The second and third principal components clearly show library preparation effects (the samples cluster by shade) and, to a lesser extent, flow-cell effects reflecting differences in sequencing depths (within each shade, the samples cluster by shape).</span></p><h2 id="算法横向对比"><a href="#算法横向对比" class="headerlink" title="算法横向对比"></a>算法横向对比</h2><p><strong>上分位数标准化</strong> (Upper-quartile normalization, UQ)，UQ只能消除流细胞效应而对文库效应束手无策，RUV算法解决的就是如何消除不同文库的影响。</p><p><strong>局部加权回归散点平滑法</strong> (Locally Weighted Scatterplot Smoothing, LOWESS/LOESS)不能消除文库效应。</p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="ERCC-spike-in-controls"><a href="#ERCC-spike-in-controls" class="headerlink" title="ERCC spike-in controls"></a>ERCC spike-in controls</h2><p>ERCC 即 External RNA Controls Consortium，是斯坦福大学为了定制一套spike-in RNA而成立的专门性组织，主要的工作是设计了好用的spike-in RNA，方便microarray以及RNA-Seq进行内参定量。[<a href="https://jimb.stanford.edu/ercc/" target="_blank" rel="noopener">官方首页</a>]</p><p>RNA spike-in是一种数量和序列都已知的RNA转录本，用于校准RNA杂交实验（例如DNA微阵列实验、RT-qPCR、RNA测序等）的测量值。RNA spike-in作为对照组（控制组）探针，被设计成能与具有相应匹配序列的DNA分子结合，这个特异性结合的过程我们称之为<strong>杂交</strong>。在制备的过程中，已知数量的spike-in将与实验样本进行混合。spike-ins的杂交程度可以用来标准化样本RNA的测量值。[<a href="https://en.wikipedia.org/wiki/RNA_spike-in" target="_blank" rel="noopener">wiki</a>] [<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1797020" target="_blank" rel="noopener">reference</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 生信工具和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批次效应（batch effect）</title>
      <link href="/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190319-cca5.html"/>
      <url>/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190319-cca5.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a><span id="def">一、定义</span></h1><p>下面是大佬给出来的关于<strong>批次效应</strong>(batch effect)的定义：</p><blockquote><p>Batch effects are sub-groups of measurements that have qualitatively different behaviour across conditions and are unrelated to the biological or scientific variables in a study. For example, batch effects may occur if a subset of experiments was run on Monday and another set on Tuesday, if two technicians were responsible for different subsets of the experiments, or if two different lots of reagents, chips or instruments were used. <a href="https://www.nature.com/articles/nrg2825" target="_blank" rel="noopener">Leek et. al (2010)</a></p></blockquote><a id="more"></a><p>批次效应是测量结果中的一部分，它们因为实验条件的不同而具有不同的表现形式，并且与我们研究的变量没有半毛钱关系。一般批次效应可能在下述情形中出现：</p><ul><li>一个实验的不同部分在<strong>不同时间</strong>完成；</li><li>一个实验的不同部分由<strong>不同的人</strong>完成；</li><li>试剂用量不同、芯片不同、实验仪器不同；</li><li>将自己测的数据与从网上下载的数据混合使用；</li><li>……</li></ul><hr><h1 id="二、检测"><a href="#二、检测" class="headerlink" title="二、检测"></a>二、检测</h1><p>批次效应相关协变量已知时，直接聚类观察结果是否和相应协变量相关。<br>混合数据因为实验条件迥异，一般批次效应都很大。</p><p>以R为例，通过聚类检验是否存在批次效应。请先查看下面的<a href="#dataset">示例数据集</a>。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t() 转置函数</span></span><br><span class="line"><span class="comment"># dist() 距离函数：按照指定规则求行向量间的距离，因此要转置</span></span><br><span class="line">&gt; dist_mat &lt;- dist(t(edata))</span><br><span class="line">&gt; clustering &lt;- hclust(dist_mat) <span class="comment"># hclust 的输入结构与 dist 相同！</span></span><br><span class="line"><span class="comment"># 按照批次信息聚类</span></span><br><span class="line">&gt; plot(clustering, labels = pheno$batch)</span><br><span class="line"><span class="comment"># 按照是否是正常细胞聚类</span></span><br><span class="line">&gt; plot(clustering, labels = pheno$cancer)</span><br></pre></td></tr></table></figure></p><p>聚类结果如下：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-result1.png" width="50%"><br>左边的红色框框是正常细胞中混入的癌细胞，右边蓝色框框中是癌细胞中混入的正常细胞。</p><p>还有许多检验批次效应的的方法，这篇<a href="https://www.itl.nist.gov/div898/handbook/eda/section4/eda42a3.htm" target="_blank" rel="noopener">文章</a>给出了多种检验方式：</p><ul><li>图分析：双柱状图、QQ图、箱线图、块图、…</li><li>定量分析：F检验、双样本t检验、…</li></ul><hr><h1 id="三、处理"><a href="#三、处理" class="headerlink" title="三、处理"></a>三、处理</h1><p>实验条件允许的条件下，应该优化实验设计，将引起批次效应的协变量采样<strong>分散</strong>开来。例如，对于时间批次效应，实验的不同部分应该在各个时间内均匀采样。这叫“治病就治本”。</p><p>但是大多数情况下实验条件不允许，如果够幸运的话批次效应相关的协变量已经被记录下来了，此时对批次效应进行验证，然后使用统计模型过滤；如果十分不幸，批次效应相关的协变量没有被记录或者不明显，我们就需要借助相关工具猜一下哪个变量可能造成了批次效应，然后使用统计模型过滤。前者叫<strong>参数化方法</strong>，后者叫<strong>非参数化方法</strong>。</p><h2 id="1-导入示例数据集"><a href="#1-导入示例数据集" class="headerlink" title="1.导入示例数据集"></a><span id="dataset">1.导入示例数据集</span></h2><h3 id="bladderbatch包"><a href="#bladderbatch包" class="headerlink" title="bladderbatch包"></a>bladderbatch包</h3><p><code>bladderbatch</code>包包含了一项<a href="https://www.ncbi.nlm.nih.gov/pubmed/15173019" target="_blank" rel="noopener">膀胱癌研究</a>中相关的57个样本的基因表达数据，这些数据已经使用RMA标准化，并且已经按照<a href="https://www.ncbi.nlm.nih.gov/pubmed/20838408" target="_blank" rel="noopener">相关协议</a>进行了预处理。</p><p>另外阅读R文档我们发现：</p><ul><li><code>eSet</code>是一个包含高通量实验元数据的一个类，它不能直接被实例化。</li><li><code>pData</code>方法在类<code>eSet</code>中被定义，它的作用是访问数据的元数据（注释信息）。</li><li><code>ExpressionSet</code>继承自<code>eSet</code>，同样是一个高通量测序数据的容器，由&gt; * <code>biobase</code>包引入，封装了<strong>表达矩阵</strong>和<strong>样本分组信息</strong>。表达矩阵存储在<code>exprs</code>中。</li></ul><p><code>bladderbatch</code>数据集是（类似）<code>ExpressionSet</code>类型，我们可以使用<code>pData()</code>加载元数据，使用<code>exprs()</code>加载表达谱数据。<br><code>bladderbatch</code>数据集用来演示如何校正批次效应。</p><h3 id="下载和加载数据集"><a href="#下载和加载数据集" class="headerlink" title="下载和加载数据集"></a>下载和加载数据集</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.安装并加载数据集</span></span><br><span class="line">&gt; BiocInstaller::biocLite(<span class="string">"bladderbatch"</span>)</span><br><span class="line">&gt; <span class="keyword">library</span>(bladderbatch) <span class="comment"># 或者 library("bladderbatch", character.only=TRUE)</span></span><br><span class="line"><span class="comment">## 2.查看当前可用数据集</span></span><br><span class="line">&gt; data()</span><br><span class="line"><span class="comment">## 3.检查是否有如下信息</span></span><br><span class="line">Data sets <span class="keyword">in</span> package ‘bladderbatch’:</span><br><span class="line">bladderEset (bladderdata)           Bladder Gene Expression Data Illustrating Batch Effects</span><br><span class="line"><span class="comment">## 加载数据集</span></span><br><span class="line">&gt; data(bladderdata) <span class="comment"># 实际加载进来的数据集名字叫做 bladderEset !</span></span><br><span class="line">&gt; pheno &lt;- pData(bladderEset) <span class="comment"># 使用 pData 加载元数据/注释信息</span></span><br><span class="line">&gt; edata &lt;- exprs(bladderEset) <span class="comment"># 使用 exprs 加载数据</span></span><br></pre></td></tr></table></figure><p><code>pheno</code>如下所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-pheno.png" width="20%"><br>样本的批次信息存储作为元数据存储在<code>pheno$batch</code>中（R中使用<code>$</code>访问对象的属性）。</p><p><code>edata</code>如下所示：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-edata.png" width="50%"><br>一列表示一个样本（细胞），后面求距离需要转置。</p><hr><h2 id="2-R中的sva包"><a href="#2-R中的sva包" class="headerlink" title="2.R中的sva包"></a>2.R中的sva包</h2><p><code>sva</code>用于移除高通量测序数据中的<a href="#def"><strong>批次效应</strong></a>以及其它无关变量的影响。</p><p><code>sva</code>包含用于标识和构建高维数据集（例如基因表达、RNA测序/甲基化/脑成像数据等可以直接进行后续分析的数据）<strong>代理变量</strong>的函数。代理变量是直接从高维数据构建的协变量，可以在后续分析中用于调整未知的、未建模的或潜在的噪音源。</p><blockquote><p><strong>代理变量（surrogate/proxy variable）</strong>: A variable that can be measured (or is easy to measure) that is used in place of one that cannot be measured (or is difficult to measure). For example, whereas it may be difficult to assess the wealth of a household, it is relatively easy to assess the value of a house. See also proxy variable. (from <a href="http://www.oxfordreference.com/view/10.1093/oi/authority.20110803100544210" target="_blank" rel="noopener">Oxford Reference</a>)<br><strong>代理变量分析（Surrogate Variable Analysis）</strong>：<a href="https://digital.lib.washington.edu/researchworks/handle/1773/9586" target="_blank" rel="noopener">Click here</a></p></blockquote><p><code>sva</code>从三个方面消除人为设计造成的影响：</p><ol><li>为未知变异源构造代理变量；(Leek and Storey <a href="https://www.ncbi.nlm.nih.gov/pubmed/17907809" target="_blank" rel="noopener">2007 PLoS Genetics</a>, <a href="https://www.ncbi.nlm.nih.gov/pubmed/20941797" target="_blank" rel="noopener">2011 Pharm Stat.</a>)</li><li>使用ComBat直接移除已知的批次效应；<a href="https://academic.oup.com/biostatistics/article/8/1/118/252073" target="_blank" rel="noopener">(Johnson et al. 2007 Biostatistics)</a></li><li>使用已知的控制探针(known control probes)移除批次效应；<a href="https://www.biorxiv.org/content/10.1101/006585v2" target="_blank" rel="noopener">(Leek 2014 biorXiv)</a><br>移除批次效应和使用代理变量可以减少依赖性，稳定错误率估计值，提高重现性。</li></ol><p>查看<code>sva</code><a href="http://127.0.0.1:28090/library/sva/doc/sva.pdf" target="_blank" rel="noopener">在线文档</a>。</p><h3 id="gt-已记录批次信息"><a href="#gt-已记录批次信息" class="headerlink" title="&gt; 已记录批次信息"></a>&gt; 已记录批次信息</h3><p>当<strong>批次协变量</strong>已知时（即每个样本分属于哪一个批次记录在数据集的元数据中），可以使用<code>sva</code>的<code>ComBat</code>校正<strong>批次效应</strong>。<br><code>ComBat</code>使用参数（parametric）或者非参数（non-parametric）的<strong>经验贝叶斯框架</strong>（Empirical Bayes Frameworks）进行批次效应的校正。</p><p>先看<code>ComBat</code>的用法：摘自<a href="https://www.rdocumentation.org/packages/sva/versions/3.20.0/topics/ComBat" target="_blank" rel="noopener">官方文档</a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ComBat(dat, batch, mod=<span class="literal">NULL</span>, par.prior = <span class="literal">TRUE</span>, prior.plots = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># dat: 基因组测量矩阵（探针维度 X 样本数），探针维度例如marker数、基因数.....，例如表达谱矩阵</span></span><br><span class="line"><span class="comment"># batch: 批次协变量，只能传入一个批次协变量！</span></span><br><span class="line"><span class="comment"># mod: 这是一个模式矩阵，里面包含了我们感兴趣的变量！</span></span><br><span class="line"><span class="comment"># par.prior: 基于参数/非参数，默认为基于参数</span></span><br></pre></td></tr></table></figure></p><p>有了背景知识我们就可以进行膀胱癌数据的批次校正：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; pheno$hasCancer &lt;- pheno$cancer == <span class="string">"Cancer"</span></span><br><span class="line"><span class="comment"># 或者 &gt; pheno$hasCancer &lt;- as.numeric(pheno$cancer == "Cancer")</span></span><br><span class="line">&gt; model &lt;- model.matrix(~hasCancer, data=pheno)</span><br><span class="line">&gt; combat_edata &lt;- ComBat(dat = edata, batch = pheno$batch, mod = model)</span><br><span class="line"><span class="comment"># 这里的 mod 参数就比较有意思了，它记录的是我们感兴趣的变量。因为初次接触R只能肤浅理解一下。</span></span><br><span class="line"><span class="comment"># 它应该是一个我们期望样本能被正确聚类所依据的协变量，它总是数值型变量</span></span><br></pre></td></tr></table></figure></p><p><code>model.matrix(...)</code>的详细解释见<a href="/R/20190319-1548.html">这里</a>。</p><p>画图：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; dist_mat_combat &lt;- dist(t(combat_edata))</span><br><span class="line">&gt; clustering_combat &lt;- hclust(dist_mat_combat, method = <span class="string">"complete"</span>)</span><br><span class="line">&gt; plot(clustering, labels = pheno$batch)</span><br><span class="line">&gt; plot(clustering, labels = pheno$cancer))</span><br></pre></td></tr></table></figure></p><p>我们发现批次效应被移除了：<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/ComBat-result2.png" width="50%"></p><h3 id="gt-没有记录批次信息"><a href="#gt-没有记录批次信息" class="headerlink" title="&gt; 没有记录批次信息"></a>&gt; 没有记录批次信息</h3><p><a href="http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#removing-hidden-batch-effects" target="_blank" rel="noopener">看这里</a></p><hr><h2 id="3-R中的ber包"><a href="#3-R中的ber包" class="headerlink" title="3.R中的ber包"></a>3.R中的ber包</h2><p>ber的全称就是batch effects removal，使用<code>&gt; install.packages(&quot;ber&quot;)</code>安装ber包，查看<a href="https://cran.r-project.org/web/packages/ber/ber.pdf" target="_blank" rel="noopener">用户手册</a>。</p><p>这个包里有6个函数，它们的作用就是校正<strong>微阵列标准数据</strong>中的批次效应。标准数据指的是：输入矩阵每一行代表独立的样本，每一列代表基因；批次信息作为已知的<strong>分类变量</strong>；期望变量可以大大提高批次效应校正的效率。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>berr(Y, b, covariates = NULL)</code></td><td>using a two-stage regression approach <a href="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019031901.pdf" target="_blank" rel="noopener">(M. Giordan. February 2013)</a></td></tr><tr><td><code>ber_bg(Y, b, covariates = NULL,partial=TRUE,nSim=150)</code></td><td>using a two-stage regression approach and bagging <a href="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019031901.pdf" target="_blank" rel="noopener">(M. Giordan. February 2013)</a></td></tr><tr><td><code>combat_p(Y, b, covariates = NULL, prior.plots=T)</code></td><td>using a parametric empirical Bayes approach <a href="https://www.ncbi.nlm.nih.gov/pubmed/16632515" target="_blank" rel="noopener">(n Johnson et al. 2007)</a></td></tr><tr><td><code>combat_np(Y, b, covariates = NULL)</code></td><td>using a non-parametric empirical Bayes approach <a href="https://www.ncbi.nlm.nih.gov/pubmed/16632515" target="_blank" rel="noopener">(n Johnson et al. 2007)</a></td></tr><tr><td><code>mean_centering(Y, b)</code></td><td>using the means of the batches</td></tr><tr><td><code>standardization(Y, b)</code></td><td>using the means and the standard deviations of the batches</td></tr></tbody></table><p>上表中的：</p><ul><li><code>Y</code>是输入矩阵（样本数 $n{\times}g$ 探针数）</li><li><code>b</code>是 $n$ 维<strong>分类1向量</strong>，每个分量对应着每个样本的批次信息</li><li><code>covariates</code>是一个 $n$ 行的<code>data.frame</code>实例</li></ul><p>上面的6个函数都需要指定<code>b</code>，所以它们都是用来处理<strong>批次信息被记录</strong>的情形的，对于启发性的校正貌似没提出解决方案。</p><hr><h2 id="4-R中的RUVSeq包"><a href="#4-R中的RUVSeq包" class="headerlink" title="4.R中的RUVSeq包"></a>4.R中的RUVSeq包</h2><p>RUVSeq means <em>Remove Unwanted Variation from RNA-Seq Data</em>, which shows us how to conduct a differential expression (DE) analysis that controls for “unwanted variation”, e.g., batch, library preparation, and other nuisance effects, using the between-sample normalization methods proposed in <a href="https://www.nature.com/articles/nbt.2931" target="_blank" rel="noopener">Risso et al. (2014)</a>.</p><p>RUV算法基本原理参考<a href="/Bioinformatics/20190322-afa7.html">这里</a>，原文在<a href="https://www.nature.com/articles/nbt.2931" target="_blank" rel="noopener">这里</a>。</p><hr><h2 id="5-R中的BatchQC包"><a href="#5-R中的BatchQC包" class="headerlink" title="5. R中的BatchQC包"></a>5. R中的BatchQC包</h2><p><a href="https://bioconductor.org/packages/release/bioc/html/BatchQC.html" target="_blank" rel="noopener">BatchQC工具</a></p><hr><h1 id="四、FAQ"><a href="#四、FAQ" class="headerlink" title="四、FAQ"></a>四、FAQ</h1><ol><li><strong>标准化（normalization）可以消除批次效应吗？</strong> 只能缓解，不能消除。</li></ol><hr><h1 id="五、其它资料"><a href="#五、其它资料" class="headerlink" title="五、其它资料"></a>五、其它资料</h1><p>Stanford大学MOOC公开课讲义：<a href="http://genomicsclass.github.io/book/" target="_blank" rel="noopener">PH525x series - Biomedical Data Science</a></p><p><a href="https://bioinformatics.mdanderson.org/public-software/tcga-batch-effects/" target="_blank" rel="noopener">TCGA Batch Effects Viewer</a></p><p>From BioMedSearch: <a href="http://www.biomedsearch.com/nih/Removing-batch-effects-in-analysis/21386892.html" target="_blank" rel="noopener">Removing batch effects in analysis of expression microarray data: an evaluation of six batch adjustment methods.</a></p>]]></content>
      
      
      <categories>
          
          <category> 生信工具和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>model.matrix(...)</title>
      <link href="/R%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80/20190319-1548.html"/>
      <url>/R%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80/20190319-1548.html</url>
      
        <content type="html"><![CDATA[<p>R中的模型矩阵函数。<a id="more"></a></p><h1 id="分类变量"><a href="#分类变量" class="headerlink" title="分类变量"></a>分类变量</h1><p><strong>分类变量</strong>（Factors）：R中用来存储分类数据的类别信息。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; f = factor(c(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>))</span><br><span class="line"><span class="comment"># 检查变量是否是分类变量（因子）</span></span><br><span class="line">&gt; class(f)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"factor"</span></span><br><span class="line"><span class="comment"># 查看分类变量中有哪些类别</span></span><br><span class="line">&gt; levels(f)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line"><span class="comment"># 查看分类变量中有几类</span></span><br><span class="line">&gt; nlevels(f)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="哑变量"><a href="#哑变量" class="headerlink" title="哑变量"></a>哑变量</h1><p><strong>虚拟变量</strong>/<strong>哑变量</strong>（dummy variable）：量化非数值类型的变量，通常取0/1。例如，衡量一个人的性别：男 -&gt; 1，女 -&gt; 0。</p><h1 id="解释变量"><a href="#解释变量" class="headerlink" title="解释变量"></a>解释变量</h1><p><strong>解释变量</strong>（explanatory variable）：单纯从数理角度来看，解释变量等同于控制变量/自变量，与之相对的是<strong>被解释变量</strong>（反应变量/因变量）。<a href="http://blog.sciencenet.cn/blog-334577-426759.html" target="_blank" rel="noopener">REF</a></p><h1 id="设计矩阵"><a href="#设计矩阵" class="headerlink" title="设计矩阵"></a>设计矩阵</h1><p><strong>设计矩阵</strong>（design matrix）：又叫<strong>模型矩阵</strong>（model matrix）或者<strong>回归矩阵</strong>（regressor matrix）。由解释变量值组成的矩阵：一行代表一个独立的观测对象（样本），一列代表对应的变量（特征值、元数据），通常记为$X$。简单理解，就是我们所说的<strong>输入矩阵</strong>，可以是元数据的，也可以是数据的。</p><h1 id="model-matrix-…"><a href="#model-matrix-…" class="headerlink" title="model.matrix(…)"></a>model.matrix(…)</h1><p>定义：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># S3 method for default </span></span><br><span class="line">model.matrix(object, data = environment(object), contrasts.arg = <span class="literal">NULL</span>, xlev = <span class="literal">NULL</span>, …)</span><br><span class="line"><span class="comment"># 函数依据 object 创建设计矩阵，矩阵的创建必须借助于数据集 data</span></span><br><span class="line"><span class="comment"># data 必须能提供与 object 相同名字的变量！</span></span><br></pre></td></tr></table></figure></p><p>以膀胱癌去批次效应为例，元数据形式如下<br><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/model.matrix.pheno.png" alt="model.matrix.pheno"></p><p>下面是部分列处理后的结果：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; model &lt;- model.matrix(~batch, data = pheno)</span><br><span class="line">                  (Intercept)batch</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="comment"># pheno$batch 是数值型变量，相当于提取列</span></span><br><span class="line"><span class="comment"># 此时新的变量名仍然是 batch</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">&gt;model &lt;-  model.matrix(~cancer, data = pheno)</span><br><span class="line">             (Intercept) cancerCancer cancerNormal</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>            <span class="number">0</span>            <span class="number">1</span></span><br><span class="line"><span class="comment"># pheno$cancer 被处理成分类变量，每一类将单独作为列（哑变量），取值为0/1</span></span><br><span class="line"><span class="comment"># 此时新的变量名为 cancerCancer 和 cancerNormal</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">&gt; model &lt;- model.matrix(~cancer==<span class="string">"Cancer"</span>, data = pheno)</span><br><span class="line">             (Intercept) cancer == <span class="string">"Cancer"</span><span class="literal">TRUE</span></span><br><span class="line">GSM71019.CEL           <span class="number">1</span>                            <span class="number">0</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>                            <span class="number">0</span></span><br><span class="line"><span class="comment"># cancer=="Cancer" 是一个 logical 类型</span></span><br><span class="line"><span class="comment"># 这种写法极不优雅！我们应该先定好名字</span></span><br><span class="line">&gt; pheno$hasCancer &lt;- pheno$cancer == <span class="string">"Cancer"</span></span><br><span class="line">&gt; model &lt;- model.matrix(~hasCancer, data=pheno)</span><br><span class="line">             (Intercept) hasCancer</span><br><span class="line">GSM71019.CEL           <span class="number">1</span>         <span class="number">0</span></span><br><span class="line">GSM71020.CEL           <span class="number">1</span>         <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> R统计语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生信分析工具-SCENIC</title>
      <link href="/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-94a8.html"/>
      <url>/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-94a8.html</url>
      
        <content type="html"><![CDATA[<p><strong>SCENIC: Single-cell regulatory network inference and clustering</strong></p><p>基于regulon(TF-&gt;targets)构建GRNs，基于GRNs可以进行细胞聚类。</p><p>与其说是算法，不如说SCENIC是组合算法的一个流程。如下图所示：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/scenic-01.png" alt=""><br><a id="more"></a></p><h1 id="1-基因数据过滤"><a href="#1-基因数据过滤" class="headerlink" title="1. 基因数据过滤"></a>1. 基因数据过滤</h1><p>共表达分析之前需要对基因数据进行过滤，本文使用如下两个方法：</p><p>1.根据每个基因的reads数目移除可信度低或者将产生较大噪声的基因。reads数目的阈值与数据集的大小有关，以下是原文表述：3 UMI counts (slightly over the median of the nonzero values) multiplied by 1% of the number of cells in the dataset (e.g. in mouse brain: 3 UMI counts x 30 (1% of cells) = minimum 90 counts per gene).</p><p>2.根据可检测到某个基因的细胞数目过滤掉只在一个细胞或者极少量细胞中表达的基因，细胞数目的阈值设定参考原文：set a percentage lower than the smallest population of cells to be detected. For example, since microglia cells represent approximately 3% of the total cells in the dataset, we used a detection threshold of at least 1% of the cells.</p><h1 id="2-共表达分析"><a href="#2-共表达分析" class="headerlink" title="2. 共表达分析"></a>2. 共表达分析</h1><p>仅仅借助<strong>共表达分析</strong>(co-expression analysis)(GENIE3或者GRNBoost)得到regulons的表达情况（GRNs）。一个regulon由一个TF和它调控的靶基因组成。当数据集非常大时GENIE3的运行速度将会变得非常慢，此时使用GRNBoost替换GENIE3能大大加快计算速度。</p><p>但是，共表达分析存在许多假阳性结果，我们需要找到这些实际上不存在的TF-靶基因配对，因此需要下一步的基序富集分析。</p><h2 id="GENIE3"><a href="#GENIE3" class="headerlink" title="GENIE3"></a>GENIE3</h2><p>GENIE3的核心算法是<strong>随机森林回归模型</strong>。随机森林能够处理非线性共表达关系。针对不同的TF训练不同的模型，这些模型用于计算相应TF的权重，这些权重可以用来衡量它与靶基因共表达的强度。</p><p>输入：一个基因表达矩阵，矩阵的每一列代表一个细胞的不同基因，每一行代表一个基因在不同细胞里的表达量。矩阵的元素可以是UMI计数，也可以是其它指标，例如TPM (Transcripts Per Million)、FPKM/RPKM等等。输入矩阵应避免进行标准化或归一化处理，这样会人为的引入多余的协方差。</p><p>输出：一张三列表，分别代表TF、靶基因、权重（TF靶向目标基因的可信度）</p><h2 id="GRNBoost"><a href="#GRNBoost" class="headerlink" title="GRNBoost"></a>GRNBoost</h2><blockquote><p>Spark <strong>RDD</strong>：Risilient Distributed Datasets 弹性分布式数据库<br><strong>广播变量</strong>(Broadcast Variable)：将只读变量广播到各个节点以供读取，避免变量在任务间进行传递。变量被广播之后应避免被修改。</p></blockquote><p>GRNBoost作为GENIE3在大数据集下的替代方案，它仍然接受GENIE3的基本思想：仅从基因表达数据中推断GRNs。</p><p>算法方面，GRNBoost使用了XGBoost库中的GBM (Gradient Boosting Machines)。GBM是一种结合多种弱学习器、以提升学习作为基本策略的集成学习方法。相对于随机森林，GBM使用了bagging自助聚合进行模型的平均以提高回归准确度。</p><p>然而，GRNBoost的主要贡献是基于Spark实现了多回归并行计算。<br>软件输入是<strong>基因表达向量</strong>（一系列基因和一个转录因子表达量组成的向量？）。<br>GRNBoost首先将基因表达向量分发给集群的各个节点，然后构建一个基于表达数据全集的预测矩阵。<br>然后使用<strong>广播变量</strong>（Broadcast Variable）将这个预测矩阵广播到各个节点，接下来进行Map/Reduce分布式计算。</p><p><strong>Map阶段</strong>：基于基因表达向量使用预测器训练XGBoost回归模型。基于训练的模型，TF和靶基因的靶向强度将以网络的边的形式呈现出来。</p><p><strong>Reduce阶段</strong>：整合所有的边形成最终的GRNs。</p><h1 id="3-基序富集分析"><a href="#3-基序富集分析" class="headerlink" title="3. 基序富集分析"></a>3. 基序富集分析</h1><p><strong>基序富集分析</strong>(motif enrichment analysis)使用的工具是RcisTarget，它能找到共表达分析的假阳性结果。删除这些假阳性结果就能得到正确的GRNs (Gene Regulatory Networks)。</p><p>RcisTarget 是 i-cisTarget 和 iRegulon 基序富集框架的 R/Bioconductor 实现。</p><p>主要分为两个步骤：</p><ol><li>选择在基因的转录起始位点（TSS）附近明显高表达的DNA基序<br>This is achieved by applying a recovery-based method on a database that contains genome-wide cross-species rankings for each motif. 实现方法：在基序全基因组跨物种排名数据库上使用recovery方法<br>保留那些可以注释到TF并且标准富集分数(Normalized Enrichment Score, NES)大于3.0的基序<br>2.对于每个基序和基因集，RcisTarget预测候选靶基因（如在基因集中排列在前缘以上的基因）<br>方法详情见引用[32]，此方法在i-cisTarget&amp;iRegulon中均有实现，因此使用RcisTarget得到的结果与i-cisTarget&amp;iRegulon的结果一致</li></ol><p>为了构建最终的调控子，我们将每个有基序富集的TF模块预测的靶基因进行归并。<br>上面针对的是正调控，对于抑制，仍然可以对负相关的TF模块做相同的处理；但是我们的分析中，这类模块较少。<br>基于上述事实，本实验之研究正相关，不研究负相关<br>本文使用的数据集：the “18k motif collection” from iRegulon (gene-based motif rankings) for human and mouse<br>TSS搜索空间：10kb around the TSS or 500bp upstream the TSS</p><h1 id="4-AUCell打分"><a href="#4-AUCell打分" class="headerlink" title="4. AUCell打分"></a>4. AUCell打分</h1><p>The relative scores of each regulon across the cells allow identifying which cells have a significantly high sub-network activity<br>细胞的调节子打分容许我们识别哪些细胞具有明显的高子网络活性？？？结果是一个二进制的活性矩阵，可用于下游分析<br>——对此矩阵的聚类可用于细胞类型或者细胞状态的识别，基于调控子网络的活性共享。<br>对抗dropouts增强鲁棒性：对调节子整体进行打分，而不是针对特定的转录因子或者单个基因。</p><p>基于单细胞测序数据，从活化的GRNs中鉴定细胞<br>输入是一个基因集，输出为每个细胞中基因集的活性（AUC指标）<br>在SCENIC中，这些基因集表现为regulons，每个调控子由一个TF和它对应的靶基因组成<br>AUCell calculates the enrichment of the regulon as an area under the recovery curve (AUC) across the ranking of all genes in a particular cell, whereby genes are ranked by their expression value.<br>将AUC区域面积作为regulon的富集量，该区域包含了特定细胞中所有基因的排序。<br>This method is therefore independent of the gene expression units and the normalization procedure.<br>因为是在单个细胞上进行检验，因此很容易可以应用到大数据集</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/scenic-02.png" alt=""></p><p>——AUCell用来估计每个细胞中每个regulon的活性，通过计算恢复曲线下的面积，整合了每个regulon里所有排列的基因的信息<br>——AUC打分（上面计算出来的）通过设定阈值构建Regulon Activity Matrix，用来判定哪些细胞里的regulon处于on状态<br>——左图横坐标是一个regulon的靶基因的排列，纵坐标是从输入数据集中数出来的基因数目<br>然后，AUCell使用“曲线下面积”(AUC)计算输入基因集中的一个关键子集是否在每个细胞的排名顶部富集。<br>AUC表示表达基因在特征中的比例以及相对于细胞内其他基因的相对表达值<br>这一部的输出是一个矩阵：每一个细胞的每一个基因集的AUC分数<br>使用细胞中的一系列regulon的AUC值进行细胞的聚类，或者使用处理过的二值矩阵<br>——二值矩阵：自动 or 手动<br>——下图是AUC分布的几个例子</p><h1 id="5-基于GRNs的细胞聚类"><a href="#5-基于GRNs的细胞聚类" class="headerlink" title="5. 基于GRNs的细胞聚类"></a>5. 基于GRNs的细胞聚类</h1><p>AUC activity matrix：每个细胞中每个regulon的AUC值，连续值<br>regulon activity matrix：上面矩阵二值化的结果，01矩阵<br>可视化：主要用t-SNE、层次聚类的热图<br>探究结果的其他可选项<br>—— t-SNE的高密度区域 =&gt; 最可能的稳定状态<br>—— 鉴定key regulators<br>—— 基于数据库注释了解细胞属性<br>—— GO terms (regulon内的基因富集分析)</p><blockquote><p>操纵子（operon）：包含了操纵基因的核苷酸序列，被某个启动子控制，对应一组受操纵基因调控的基因<br>调节子（regulon）：对应受某个起调节作用的蛋白质调节的一组基因<br>刺激子（stimulon）：对应某类起调节作用的细胞调节的一组基因</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Nat Methods. 2017 Nov;14(11):1083-1086. doi: 10.1038/nmeth.4463. Epub 2017 Oct 9.<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5937676" target="_blank" rel="noopener">SCENIC: Single-cell regulatory network inference and clustering</a><br>Aibar S1,2, González-Blas CB1,2, Moerman T3,4, Huynh-Thu VA5, Imrichova H1,2, Hulselmans G1,2, Rambow F6,7, Marine JC6,7, Geurts P5, Aerts J3,4, van den Oord J8, Atak ZK1,2, Wouters J1,2,8, Aerts S1,2.</p><p><a href="http://scenic.aertslab.org" target="_blank" rel="noopener">&gt;&gt;&gt; SCENIC</a></p>]]></content>
      
      
      <categories>
          
          <category> 生信工具和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生信分析工具-RaceID2+StemID</title>
      <link href="/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-98e6.html"/>
      <url>/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-98e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>数据分析时要处理的噪声不仅来自实验误差和测量误差，基因表达和少量mRNA的扩增都会产生一定的噪声。其中来自生物过程的噪声可以通过大量测序来缓和。</p><p>如果根据某一时刻的转录表达情况推断细胞系谱结构一直是一个严峻的挑战。作者肯定了<a href="/生物信息学/20190315-643b.html">Wanderlust算法</a>的设计思想，但是同时对其设计的拓扑结构的合理性表示怀疑，并提出了自己的解决方案。</p><p>RaceID2算法旨在：基于单细胞转录组数据，通过聚类鉴定出干细胞</p><p>StemID算法旨在：利用RaceID2的聚类结果，构建系谱树</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法在小肠的Lgr5+细胞、骨髓造血干细胞上学习，在人类胰腺多能干细胞上测试。Lgr5+小鼠肠道干细胞群的分化过程研究已经发表，作为算法学习的基础数据集。</p><h2 id="RaceID"><a href="#RaceID" class="headerlink" title="RaceID"></a>RaceID</h2><p><a href="https://www.nature.com/articles/nature14966" target="_blank" rel="noopener">此处嘀向作者2015年发表的论文</a></p><h2 id="RaceID2"><a href="#RaceID2" class="headerlink" title="RaceID2"></a>RaceID2</h2><p>作者对自己已经发表的RaceID算法进行优化：RaceID使用K-means进行聚类，因此求所有样本平均值的做法使得RaceID对异常值十分敏感，同时RaceID使用<strong>间隔统计量</strong>（Gap Statistics, GS）确定分类个数；但是作者认为这种方法并不理想，因此在RaceID2中改用K-medoids方法聚类，并且依据类内散布饱和临界值为依据确定分类个数。K-medoids聚类方法使用类似于中位数的方法确定聚类中心，与K-means不同，它的聚类中心始终产生在样本点上。</p><p>RaceID2是一种改进的聚类算法，能够将大量细胞进行聚类，从而确定不同细胞群/亚群的分界线。</p><h2 id="StemID"><a href="#StemID" class="headerlink" title="StemID"></a>StemID</h2><p>StemID是一种系谱图推导方法，StemID的系谱图推导基于RaceID2的聚类结果。</p><p>下面是从原文摘录的算法流程图：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-15-000000.jpg" alt=""></p><p>图A是RaceID2的聚类结果，其聚类中心都在样本点上。</p><p>这里先介绍作者给出的一个<strong>感性假设</strong>：每个节点 $k$ (一个细胞)除了属于自身的第 $i$ 类外，它还将连接到一个其它的某个类 $j$ ，这个类 $j$ 实际意义等同于另一个的细胞群/亚群，细胞 $k$ 将倾向于朝细胞群 $j$ 分化。</p><p>如图A所示，Cluster 1的聚类中心是 $m_i$，这里 $i=1$，将 $m_i$ 与其它所有聚类中进行连接（如图A黑色矢量）。第 $i$ 类中的节点 $k$（蓝色矢量箭头处）与类中心 $m_i$ 组成了一个向量（如图A蓝色矢量）。蓝色矢量将在所有黑色矢量上产生一个 <strong>投影</strong>。我们取与 <strong>最大投影长度</strong> 相对应的那个外类作为 <strong>感性假设</strong> 中陈述的潜在分化方向。</p><p>如图B2所示，将所有节点转换成到之相对应的投影位置，此时所有节点都将落到由聚类中心组成的网络上。</p><p>此网络就是StenID算法所构建的系谱树框架。</p><p>给网络的边打分：映射后不同边上点的分布是不同的，对于某条边 $L$ 上的任意两点 $r_i$ 和 $r_j$，定义打分公式：</p><p>$$score=1-\max_{i,j{\in}L}{||r_i-r_j||}$$ </p><p>当 $score{\to}0$ 时说明该边上所有点非常紧密的靠近聚类中心。</p><p>p值计算：重复采样，略</p><p>细胞的熵得计算：略</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>作者自己分析了一下，在下面两种情况出现时算法可能不太灵光：</p><ol><li>出现中间过渡态细胞的样本缺失；</li><li>出现不直接关联的细胞。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Cell Stem Cell. 2016 Aug 4;19(2):266-277. doi: 10.1016/j.stem.2016.05.010. Epub 2016 Jun 23.<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4985539/" target="_blank" rel="noopener">De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome Data</a><br>Grün D1, Muraro MJ2, Boisset JC2, Wiebrands K2, Lyubimova A2, Dharmadhikari G3, van den Born M2, van Es J2, Jansen E2, Clevers H4, de Koning EJP3, van Oudenaarden A5.</p><p>github：<a href="https://github.com/dgrun/StemID" target="_blank" rel="noopener">StemID</a><br>omicX：<a href="https://omictools.com/stemid-tool" target="_blank" rel="noopener">stemid-tool</a></p>]]></content>
      
      
      <categories>
          
          <category> 生信工具和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生信分析工具-Wanderlust</title>
      <link href="/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-643b.html"/>
      <url>/%E7%94%9F%E4%BF%A1%E5%B7%A5%E5%85%B7%E5%92%8C%E7%AE%97%E6%B3%95/20190315-643b.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以人类B细胞为例，确定每个细胞在相应细胞过程（例如细胞分化）中的先后顺序。</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>输入</strong>：算法的输入是一个 $M{\times}N$ 的矩阵，其中 $M$ 是细胞数量，$N$ 是选取的marker数量。每个marker的丰度由<strong>质谱流式细胞技术</strong>(Mass Cytometry)测定。</p><p><strong>输出</strong>：每个细胞的路径打分。此打分值介于0~1之间：0表示路径起点细胞，1代表路径终点细胞。</p><p>Wanderlust实际上就是<strong>最近邻图</strong>(Nearest Neighbour Graph)与<strong>EM算法</strong>的组合。</p><p>下图是摘自原文的算法流程：</p><p><img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-15_153512.jpg" alt=""></p><p>图A是输入数据的形象表示。</p><p>1.凭先验知识确定一个<strong>起始节点</strong>（图B红色节点），<strong>随机</strong>确定 $nl$ 个<strong>路标节点</strong>（图B紫色节点）</p><p>为什么设置路标节点？路标节点起到缓冲噪声干扰的作用。相对于起始点，具有更小的<strong>最短路径距离</strong>（Shortest Path Distance）。而随机选取可以排除了先验知识的影响。</p><p>2.构建<strong>k-NNG</strong>，该图以<strong>邻接矩阵</strong>的方式进行存储，计算相连节点间的距离，可选的距离定义有欧式距离、余弦距离、……</p><p>3.NNG下采样：从这个k-NNG构造出 $l$ 个l-k-NNG。算法只在子图上迭代运行，最后取均值作为最终结果。</p><p>为什么采样成子图进行计算？前面构造的k-NNG实际上包含了许多与实际情况不符的连接，即“假边”。进一步的随机下采样使得这些“假边”在子图中出现一定程度的缺失，这将增强模型的适应能力（鲁棒性）。</p><p>对于每个子图进行迭代优化：</p><p>4.初始化每个节点（细胞）的路径打分；起始节点为0，终止节点为1，中间节点的初始打分为该节点到起始节点的最短路径距离。最短路径距离通过Dijkstra算法计算。</p><p>初始化两节点连接的方向：距离起始节点<strong>路径打分</strong>小的节点作为上游节点。</p><p>5.对每个目标节点 $t$ 和每个路标节点 $l$ 间的距离进行打分：</p><p>$$w_{l,t}=\frac{d(l,t)^2}{\sum_m{d(l,m)^2}}$$</p><p>这个打分有什么意义？尚未知晓</p><p>6.计算每个目标节点 $t$ 的路径打分，即该目标节点到所有路标节点距离的加权平均：</p><p>$$traj_t=\frac1{nl}\sum_l{w_{l,t}d(l,t)}$$</p><p>7.根据计算出来的路径打分计算新的方向。</p><p>8.重复步骤567直到路径打分收敛。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Cell. 2014 Apr 24;157(3):714-25. doi: 10.1016/j.cell.2014.04.005.<br><a href="https://www.ncbi.nlm.nih.gov/pubmed/24766814" target="_blank" rel="noopener">Single-cell trajectory detection uncovers progression and regulatory coordination in human B cell development.</a><br>Bendall SC1, Davis KL2, Amir el-AD3, Tadmor MD3, Simonds EF4, Chen TJ5, Shenfeld DK3, Nolan GP6, Pe’er D7.</p>]]></content>
      
      
      <categories>
          
          <category> 生信工具和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习-广义线性模型01-普通最小二乘法</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190225-724a.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20190225-724a.html</url>
      
        <content type="html"><![CDATA[<p>线性模型：输出是输入的线性组合，即：</p><p>$$y(w,x)=w_0+w_1x_1+\cdots+w_px_p$$ <a id="more"></a></p><p>在sklearn中，变量 <code>coef_</code> 存储向量 $w=(w_1,\cdots,w_p)$，变量 <code>intercept_</code> 存储 $w_0$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br></pre></td></tr></table></figure><hr><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p><strong>普通最小二乘法</strong>(Ordinary Least Squares)就是简单的计算残差和：</p><p>$$min_w{||Xw-y||_2}^2$$</p><p>这个算法叫做 <strong>线性回归</strong>(Linear Regression):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">estimator = linear_model.LineaRegression(...)</span><br></pre></td></tr></table></figure><p>简单的线性回归只在输入X数据集的各特征之间线性不相关时表现良好。</p><p>当X的特征线性相关时，估计结果受随机误差影响大，此时就需要进行模型的矫正。</p><hr><h1 id="脊回归-岭回归"><a href="#脊回归-岭回归" class="headerlink" title="脊回归/岭回归"></a>脊回归/岭回归</h1><p>当特征间 <strong>共线性</strong>（Collinearity）关系较强时，<strong>脊回归</strong>（Ridge Regression）可以使模型具有收缩能力。</p><p>这通过给线性回归添加L2正则项实现：</p><p>$$min_w{||Xw-y||_2}^2+\alpha{||w||_2}^2，其中\alpha\le0$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定关键超参数α的值</span></span><br><span class="line">estimator = linear_model.Ridge(alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>对于α，可以使用交叉验证进行最优解搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定α的取值范围，默认值如下</span></span><br><span class="line"><span class="comment"># cv指定交叉验证的折数，默认如下，默认使用留一交叉验证（Leave-One-Out CV）</span></span><br><span class="line">estimator = linear_model.RidgeCV(alpha=[<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>], cv=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="Lasso"><a href="#Lasso" class="headerlink" title="Lasso"></a>Lasso</h1><p>Lasso是用来估计稀疏系数的线性模型，和其变异体广泛用于语义压缩领域？</p><p>$$min_w\frac1{2n_{samples}}{||Xw-y||_2}^2+\alpha||w||_1，其中\alpha\le0$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># α默认值如下</span></span><br><span class="line">estimator = linear_model.Lasso(alpha=<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获得一组数的全排列</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20190221-9924.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20190221-9924.html</url>
      
        <content type="html"><![CDATA[<p>自己实现的python函数。<a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(xs)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(xs,str):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">str2charArray</span><span class="params">(str)</span>:</span></span><br><span class="line">            charArray = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">                charArray.append(i)</span><br><span class="line">            <span class="keyword">return</span> charArray</span><br><span class="line">        xs = str2charArray(xs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(xs) == <span class="number">0</span> <span class="keyword">or</span> len(xs) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [xs]</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(xs)):</span><br><span class="line">        temp_list = xs[:]</span><br><span class="line">        temp_list.pop(i)</span><br><span class="line">        temp = permutation(temp_list)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">            j.insert(<span class="number">0</span>,xs[i])</span><br><span class="line">            result.append(j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>glob内建模块</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20190221-3133.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20190221-3133.html</url>
      
        <content type="html"><![CDATA[<p><strong>glob模块</strong>是python的一个很基础、很简单的模块，用于匹配文件路径。<a id="more"></a></p><p>glob这个单词本身有“通配符”的意思，通配的一个很关键的应用就是筛选出符合条件的文件。</p><p>与python的另一个专门用于正则匹配的 <strong>re模块</strong> 不同，glob只需要三个通配符：<code>*</code>、<code>？</code>、<code>[]</code>。</p><p>以下是常见的匹配情形：</p><ol><li><code>glob.glob(&#39;/a/b/*.txt&#39;)</code>: 匹配目录 <code>/a/b/</code> 下的所有.txt文件</li><li><code>glob.glob(&#39;/a/b/^[xyz]*.txt&#39;)</code>: 匹配目录 <code>/a/b/</code> 下所有文件名以字母xyz中任意一个开始的文件</li><li><code>glob.glob(&#39;/a/*/*.txt&#39;)</code>: 匹配目录 <code>/a/</code> 下所有的.txt文件</li></ol><p>此外，<code>glob.glob()</code> 是一次查询完所有结果。在查询结果较多时，可以使用 <code>glob.iglob()</code> 迭代查询，<code>glob.iglob()</code> 返回一个<strong>生成器</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os内建模块</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20190104-af30.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20190104-af30.html</url>
      
        <content type="html"><![CDATA[<p><strong>os模块</strong>用于处理文件系统中的文件和目录。<a id="more"></a></p><h1 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>os.getcwd()</td><td>当前脚本文件的工作目录</td></tr><tr><td>os.chdir(DIR)</td><td>切换工作目录至DIR，默认工作目录为脚本所在目录</td></tr></tbody></table><h1 id="目录的增删查改"><a href="#目录的增删查改" class="headerlink" title="目录的增删查改"></a>目录的增删查改</h1><table><thead><tr><th>新建目录</th></tr></thead><tbody><tr><td>os.mkdir(“A/B/“)</td><td>创建一个目录A/B/，不能递归创建，即要求目录A存在</td></tr><tr><td>os.makedirs(DIR)</td><td>创建一个目录DIR，与上面不同的是，可以递归创建目录</td></tr></tbody></table><table><thead><tr><th>删除目录</th></tr></thead><tbody><tr><td>os.rmdir(DIR)</td><td>当目录DIR为空时删除目录，不为空时报错</td></tr><tr><td>os.removedirs(DIR)</td><td>待查</td></tr></tbody></table><table><thead><tr><th>列举目录</th></tr></thead><tbody><tr><td>os.listdir(DIR)</td><td>列出<strong>直接</strong>属于目录DIR的文件和子目录</td></tr><tr><td>os.walk(DIR)</td><td>遍历目录DIR下所有的文件和目录，返回<strong>生成器</strong>，返回结果较复杂，待查</td></tr></tbody></table><table><thead><tr><th>文件和目录的重命名</th></tr></thead><tbody><tr><td>os.rename(OLD_NAME, NEW_NAME)</td><td></td></tr><tr><td>os.system(“COMMAMD_STRING”)</td><td>调用shell命令进行重命名</td></tr></tbody></table><h1 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h1><table><thead><tr><th>路径类型判断</th></tr></thead><tbody><tr><td>os.path.isfile(PATH)</td><td>判断是否为文件，是文件返回<code>True</code></td></tr><tr><td>os.path.isdir(PATH)</td><td>判断是否为目录，是目录返回 <code>True</code></td></tr><tr><td>os.path.exists(PATH)</td><td>判断是否存在，存在返回 <code>True</code></td></tr><tr><td>os.path.getsize(PATH)</td><td>是文件返回文件大小，是目录返回0</td></tr></tbody></table><table><thead><tr><th>路径的切割、合并</th></tr></thead><tbody><tr><td>os.path.split(‘1/2/3’)</td><td>分割成目录和文件，得到 <code>(&#39;1/2&#39;,&#39;3&#39;)</code></td></tr><tr><td>os.path.split(‘1/2/3/‘)</td><td>分割成目录和文件，得到 <code>(&#39;1/23&#39;,&#39;&#39;)</code></td></tr><tr><td>os.splitext(‘path/name.txt’)</td><td>分割出文件后缀，得到 <code>(&#39;path/name&#39;, &#39;.txt&#39;)</code></td></tr></tbody></table><table><thead><tr><th>路径的连接</th></tr></thead><tbody><tr><td>os.path.join(A, B)</td><td>使用默认路径分割符连接两个字符串，得到 <code>&quot;A/B&quot;</code></td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>os.sep 或 os.path.sep</td><td>当前系统下是使用的 <strong>路径分割符</strong></td></tr><tr><td>os.linesep</td><td>当前系统下使用的 <strong>行终止符</strong></td></tr><tr><td>os.environ</td><td>字典：环境变量</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取当前文件所在的目录</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20190103-5c31.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20190103-5c31.html</url>
      
        <content type="html"><![CDATA[<p>记录下常用的方法。<a id="more"></a></p><h1 id="利用os模块"><a href="#利用os模块" class="headerlink" title="利用os模块"></a>利用os模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前脚本文件所在的目录（工作目录）</span></span><br><span class="line">os.getcwd() <span class="comment"># Get current work directory</span></span><br></pre></td></tr></table></figure><p>这个方法不一定得到正确结果！</p><h1 id="利用内建数组sys-argv"><a href="#利用内建数组sys-argv" class="headerlink" title="利用内建数组sys.argv"></a>利用内建数组sys.argv</h1><p><code>sys.argv</code> 数组的第一个值（<code>sys.argv[0]</code>）存储的永远是当前脚本文件的绝对路径。</p><p>从这个路径中去掉文件名就是当前脚本文件所在目录的绝对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># current file directory</span></span><br><span class="line">cur_fdir = os.path.split(sys.argv[<span class="number">0</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青铜派森 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客改造计划</title>
      <link href="/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20190102-19a0.html"/>
      <url>/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20190102-19a0.html</url>
      
        <content type="html"><![CDATA[<p>比较有意思的优化过程。<a id="more"></a></p><h1 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h1><p>修改hexo-generator-index插件：备份文件<code>node_modules/hexo-generator-index/lib/generator.js</code>并将其中代码替换为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; </span><br><span class="line"><span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; </span><br><span class="line"><span class="comment">// 否则按照top值降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; </span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>设置<code>hexo new</code>生成博文时自动添加<strong>top</strong>元数据：将<code>top:</code>添加到文件<code>scaffolds\post.md</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: </span><br><span class="line">top: </span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>设置top值即可，top值越大，文章越靠前</p><hr><h1 id="fork-me-on-github"><a href="#fork-me-on-github" class="headerlink" title="fork me on github"></a>fork me on github</h1><p>效果如下：<img src="http://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/2019/03/2019-03-23_104518.png" alt=""></p><p>在<code>themes\next\layout\_layout.swig</code>中搜索<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>找到如下位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 这个地方 --&gt;</span><br><span class="line">&lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>添加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- fork me on github begin --&gt;</span><br><span class="line">&lt;!-- 默认启用右上角图标，需要换成左上角请更换注释部分 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 右上角 --&gt;</span><br><span class="line">&lt;a href=&quot;https://github.com/barwe&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;</span><br><span class="line">&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot;</span><br><span class="line"> class=&quot;fork-me-on-github&quot;</span><br><span class="line"> style=&quot;position: absolute; border: 0;&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line"> &lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;</span><br><span class="line"> &lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;</span><br><span class="line"> &lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;</span><br><span class="line">@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;</span><br><span class="line">@media (max-width:500px)&#123;</span><br><span class="line">.github-corner:hover .octo-arm&#123;animation:none&#125;</span><br><span class="line">.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 左上角</span><br><span class="line">&lt;a href=&quot;https://github.com/barwe&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;</span><br><span class="line">&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; </span><br><span class="line"> class=&quot;fork-me-on-github&quot;</span><br><span class="line"> style=&quot;position: absolute; border: 0; transform: scale(-1, 1);&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;</span><br><span class="line">@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;</span><br><span class="line">@media (max-width:500px)&#123;</span><br><span class="line">.github-corner:hover .octo-arm&#123;animation:none&#125;</span><br><span class="line">.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- fork me on github end --&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>themes\next\source\css\_custom\custom.styl</code>文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在右上角或者左上角添加fork me on github图块</span><br><span class="line">.fork-me-on-github &#123;</span><br><span class="line">fill: red // 背景色</span><br><span class="line">color: white // 猫的颜色</span><br><span class="line">top: 0</span><br><span class="line">right: 0 // 在右上角</span><br><span class="line">//left: 0 // 在左上角</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个功能刷新可能需要重启服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 快捷清单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统信息查询</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20190101-1ff5.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20190101-1ff5.html</url>
      
        <content type="html"><![CDATA[<p>emmmmmm,先记下来…… <a id="more"></a></p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p><code>uname -a</code>：内核、操作系统、CPU信息</p><p><code>head -n 1 /etc/issue</code>：操作系统版本</p><p><code>cat /proc/cpuinfo</code>：CPU信息</p><p><code>hostname</code>：计算机名</p><p><code>lspci -tv</code>：列出所有PCI设备</p><p><code>lsusb -tv</code>：列出所有USB设备</p><p><code>lsmod</code>：列出加载的内核模块</p><p><code>env</code>：查看环境变量</p><h1 id="内存与资源"><a href="#内存与资源" class="headerlink" title="内存与资源"></a>内存与资源</h1><p><code>free -m</code>：查看内存使用量和交换区使用量</p><p><code>df -h</code>：查看各分区使用情况</p><p><code>du -sh DIR</code>：查看目录DIR的大小，非本人的目录可能要使用 <code>sudo</code> 提权</p><p><code>grep MemTotal /proc/meminfo</code>：查看内存总量</p><p><code>grep MemFree /proc/meninfo</code>：查看空闲内存量</p><p><code>uptime</code>：查看系统运行时间、用户数、负载</p><p><code>cat /proc/loadavg</code>：查看系统负载</p><h1 id="磁盘和分区信息"><a href="#磁盘和分区信息" class="headerlink" title="磁盘和分区信息"></a>磁盘和分区信息</h1><p><code>mount | column -t</code>：查看挂接的分区状态</p><p><code>fdisk -l</code>：查看所有分区</p><p><code>swapon -s</code>：查看所有交换分区</p><p><code>hdparm -i /dev/hda</code>：查看磁盘参数</p><p><code>dmesg | grep IDE</code>：查看启动时IDE设备检测状况</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><code>ifconfig</code>：查看所有网络接口的属性</p><p><code>iptables -L</code>：查看防火墙设置</p><p><code>route -n</code>：查看路由表</p><p><code>netstat -lntp</code>：查看所有监听端口</p><p><code>netstat -antp</code>：查看所有已经建立的连接</p><p><code>netstat -s</code>：查看网络统计信息</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><code>ps -ef</code>：查看所有进程</p><p><code>top</code>：是实现显示进程状态</p><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p><code>w</code>：查看活动用户</p><p><code>id USERNAME</code>：查看用户USERNAME的信息</p><p><code>last</code>：查看用户登录日志</p><p><code>cut -d: -f1 /etc/passwd</code>：查看系统所有用户</p><p><code>cut -d: -f1 /etc/group</code>：查看系统所有组</p><p><code>crontab -l</code>：查看当前用户的计划任务</p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><code>chkconfig --list</code>：列出所有系统服务</p><p><code>chkconfig  --list | grep on</code>：列出所有启动的系统任务</p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.04LTS修改软件源</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181122-a661.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181122-a661.html</url>
      
        <content type="html"><![CDATA[<p>修改软件源能大大加快软件更新和下载速度。<a id="more"></a></p><p>1、备份原始源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>2、新建源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>写入以下内容（对于Ubuntu16.04LTS）：</p><pre># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</pre><p>其他版本的源列表可以在 <a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">这里</a> 查看。</p><p>3、刷新：<code>sudo apt-get update</code></p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.04LTS更新R到3.5.x</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181122-ad7f.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181122-ad7f.html</url>
      
        <content type="html"><![CDATA[<p>重装R时踩得坑。<a id="more"></a></p><p>1、<a href="/Linux/20181122-a661.html">系统换源</a></p><p>2、检查旧版本R</p><p>检查是否有旧版本的R：<code>R --verion</code></p><p>卸载旧版本的R：<code>sudo apt-get remove r-base-core</code></p><p>3、安装R3.5需要先添加源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository <span class="string">'deb https://cloud.r-project.org/bin/linux/ubuntu xenial-cran35/'</span></span><br></pre></td></tr></table></figure><p>添加上面这个源意味着在Ubuntu16.04LTS上可以安装R3.5。</p><blockquote><p><strong>xenial</strong> 意为“非洲地松鼠”，Ubuntu的每一个发行版都会有一个<a href="https://zh.wikipedia.org/wiki/Ubuntu发行版列表" target="_blank" rel="noopener">奇怪的名字</a>。</p></blockquote><p>然后更新源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>4、安装R3.5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install r-base r-base-dev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python中运行shell命令</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20181121-b9c.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20181121-b9c.html</url>
      
        <content type="html"><![CDATA[<p>记录常用方法。<a id="more"></a></p><p><strong>Method 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">string = subprocess.check_output(<span class="string">"COMMAND_STRING"</span>, [shell=<span class="keyword">True</span>]).decode()</span><br></pre></td></tr></table></figure><p><strong>Method 2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">result = os.system(<span class="string">"COMMAND_STRING"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青铜派森 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-vim设置优化</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181121-5ec8.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20181121-5ec8.html</url>
      
        <content type="html"><![CDATA[<p>设置tab宽度，显示行号，自动缩进… <a id="more"></a><br><code>vim ~/.vimrc</code> 打开文件（不存在则新建），键入（#后面为注释）：</p><pre># 将tab替换为4个空格set tabstop=4# Backspace时删除一个tabset softtabstop=4        # 显示行号set nu#自动缩进                set autoindent</pre>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HttpRequest对象</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-f755.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-f755.html</url>
      
        <content type="html"><![CDATA[<p>每个<strong>view函数</strong>函数的第一个参数都是HttpRequest对象，包含当前<strong>请求URL</strong>的一些信息。<a id="more"></a><br>HttpRequest对象实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 属性</span></span><br><span class="line">request.path <span class="comment"># str类型，请求页面的全路径，不包括域名</span></span><br><span class="line">request.method <span class="comment"># str类型，值为'GET'或者'POST'</span></span><br><span class="line">request.GET <span class="comment"># QueryDict实例</span></span><br><span class="line">request.POST <span class="comment"># QueryDict实例，注意区分POST为空和POST的请求内容为空，判断是否为POST方法使用method属性</span></span><br><span class="line">request.COOKIES <span class="comment"># 标准python字典对象(用&#123;&#125;表示)，&#123;str:str&#125;</span></span><br><span class="line">request.FILES <span class="comment"># 类字典对象（？），包含所有上传文件</span></span><br><span class="line"><span class="comment"># 形式为：XxxDict&#123;name: &#123;'filename':..., 'content-type':..., 'content':...&#125;&#125;</span></span><br><span class="line"><span class="comment"># 上面的name变量的值是&lt;input type="file" name="..."&gt;中name属性的值</span></span><br><span class="line"><span class="comment"># 只有POST请求并且啥啥啥的FILES属性才会有值，否则为空</span></span><br><span class="line">request.META <span class="comment"># 可用的http头部信息字典</span></span><br><span class="line">request.user <span class="comment"># django.contrib.auth.models.User对象实例，代表当前登录的用户</span></span><br><span class="line"><span class="comment"># 用户未登录则为django.contrib.auth.models.AnonymousUser对象实例</span></span><br><span class="line"><span class="comment"># 通过 request.user.is_authenticated() 判断用户是否登录</span></span><br><span class="line"><span class="comment"># 需要激活django的AuthenticationMidlleware属性</span></span><br><span class="line">request.session <span class="comment"># 当前会话的字典对象，需要激活啥啥啥</span></span><br><span class="line">request.raw_post_data <span class="comment"># 未解析的原始post数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法</span></span><br><span class="line">request.__getitem__(key) <span class="comment"># 取出GET/POST中的值，优先POST</span></span><br><span class="line">request.has_key(key) <span class="comment"># 检查GET/POST是否包含key</span></span><br><span class="line">request.get_full_path() <span class="comment"># 返回包含查询字符串的请求路径字符串</span></span><br><span class="line">request.is_secure() <span class="comment"># 如果发出的是HTTPS安全请求返回True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django官方文档笔记-request(GET+POST)属性与QueryDict类.md</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-8d33.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-8d33.html</url>
      
        <content type="html"><![CDATA[<p>在HttpRequest对象中，GET和POST属性的值都是QueryDict的实例。<a id="more"></a></p><p>QueryDict用来处理<strong>单键对应多值</strong>的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qd = django.http.QueryDict(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">#与普通字典一致的方法</span></span><br><span class="line">qd.__getitem__(key) <span class="comment"># 返回key对应值列表的最后一个值</span></span><br><span class="line">qd.__setitem__(key, value_list) <span class="comment"># GET和POST属性值字典不允许被直接修改，因此此方法只能用于该字典的拷贝上</span></span><br><span class="line">qd.get(key, IF_NONE) <span class="comment"># 如果key存在返回key对应值列表的最后一个值</span></span><br><span class="line">qd.update(d) <span class="comment"># D为QD(查询字典)或者D(python字典)都可以,如果key存在，执行添加而不是替换</span></span><br><span class="line">qd.items() <span class="comment"># 返回键值对，值是key对应的值列表的最后一个值（单值）</span></span><br><span class="line">qd.values() <span class="comment"># 跟items一样使用单值逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#特有方法</span></span><br><span class="line">qd.copy() <span class="comment"># 返回可更改的拷贝（比如可以使用__setitem__)</span></span><br><span class="line">qd.getlist(key) <span class="comment"># 返回key对应的python列表</span></span><br><span class="line">qd.setlist(key, value_list) <span class="comment"># 无须拷贝直接修改？？？？？</span></span><br><span class="line">qd.appendlist(key, value) <span class="comment"># 给已经存在的key的列表中添加一个值</span></span><br><span class="line">qd.setlistdefault(ket, value_list)</span><br><span class="line">qd.lists() <span class="comment"># 作用与items类似，不执行单值逻辑，也就是说键值对的值是所有值的列表</span></span><br><span class="line">qd.urlencode(key) <span class="comment"># 返回查询字符串格式的字符串，如'a=3&amp;a=4&amp;a=5'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django官方文档笔记-模板系统-自动转义</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-b01.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-b01.html</url>
      
        <content type="html"><![CDATA[<h1 id="自动转义的产生背景"><a href="#自动转义的产生背景" class="headerlink" title="自动转义的产生背景"></a>自动转义的产生背景</h1><p>当对模板变量进行替换时，替换字符串中可能含有能产生<strong>非预期影响</strong>的元素。<br>例如<code>&quot;&lt;script&gt;alert(&#39;hellp&#39;)&lt;/script&gt;&quot;</code>将弹出警告框<br>用户利用这个特点做一些不可描述的事情 —— <strong>跨域脚本（XSS）攻击</strong>。<a id="more"></a></p><hr><h1 id="自动转义的详细操作"><a href="#自动转义的详细操作" class="headerlink" title="自动转义的详细操作"></a>自动转义的详细操作</h1><p>为了防止这种情况出现，django引入<strong>自动转义</strong>机制，默认开启。<br>以下5 个字符尤其重要：</p><ul><li><code>&lt;</code>自动转为<code>&amp;lt</code></li><li><code>&gt;</code>自动转为<code>&amp;gt</code></li><li><code>&#39;</code>自动转为<code>&amp;#39</code></li><li><code>&quot;</code>自动转为<code>&amp;quot</code></li><li><code>&amp;</code>自动转为<code>&amp;amp</code></li></ul><hr><h1 id="手动关闭自动转义"><a href="#手动关闭自动转义" class="headerlink" title="手动关闭自动转义"></a>手动关闭自动转义</h1><p>有时候我们确实是希望模板变量被替换成一段HTML代码</p><h2 id="来自用户的数据将进行自动转义"><a href="#来自用户的数据将进行自动转义" class="headerlink" title="来自用户的数据将进行自动转义"></a>来自用户的数据将进行自动转义</h2><ol><li>使用safe过滤器关闭单个模板变量的自动转义功能</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data | safe&#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>控制模板块的自动转义</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>是否自动转义可根据模板间的继承进行转移</li></ol><h2 id="default过滤器的参数（字符串）的自动转义"><a href="#default过滤器的参数（字符串）的自动转义" class="headerlink" title="default过滤器的参数（字符串）的自动转义"></a>default过滤器的参数（字符串）的自动转义</h2><p>因为这个常亮字符串是由模板作者定义的，默认已经通过了safe过滤器。<br>所以模板作者需要人工转义：定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data|default:<span class="string">"3 &amp;lt; 2"</span> &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>而不是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data|default:<span class="string">"3 &lt; 2"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django官方文档笔记-模板系统-扩展模板系统</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-c04f.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-c04f.html</url>
      
        <content type="html"><![CDATA[<p>绝大部分的<strong>模板定制</strong>是以<strong>自定义标签/过滤器</strong>的方式来完成的。<a id="more"></a></p><h1 id="怎么编写自己的模板库文件？"><a href="#怎么编写自己的模板库文件？" class="headerlink" title="怎么编写自己的模板库文件？"></a>怎么编写自己的模板库文件？</h1><p>这里的<strong>自定义模板库</strong>指的就是<strong>自定义模板标签/过滤器</strong>。</p><p>模板库文件显然有他固定的书写格式，我们需要在模块开头写上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library()</span><br></pre></td></tr></table></figure><p>模块级变量<code>register</code>是自定义模板标签/过滤器的<strong>基础数据结构</strong>。</p><blockquote><p>实际上我们在定义自己的模板库文件时可以参考官方的写法:</p><ul><li><code>django/template/defaultfilters.py</code>文件</li><li><code>django/template/defaulttags.py</code>文件</li></ul></blockquote><p>然后我们基于<code>register</code>来自<strong>定义模板标签/过滤器</strong>:</p><h2 id="自定义模板过滤器：定义-注册"><a href="#自定义模板过滤器：定义-注册" class="headerlink" title="自定义模板过滤器：定义 + 注册"></a>自定义模板过滤器：定义 + 注册</h2><p>过滤器本质上就是带参数的python函数（哈哈，没想到吧）。<br>第一个参数应该传递<strong>管道符(|)</strong>入口的值，其他参数通过<code>:</code>进行传递。<br>例如下面的这个过滤器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(value, arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> value.replace(arg, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>在模板中可以用来去掉<strong>模板变量</strong>值中的字符’A’:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;somevalue|cut:<span class="string">"A"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>过滤器总是有<strong>可正常使用的</strong>返回值，不能<strong>触发异常</strong>（关于触发异常我的理解是：使用<code>raise</code>抛出一个异常，而不是使用<code>try...except...</code>进行异常捕获）。</p><p>不知道你发现没有，在上面我们定义<strong>模板过滤器</strong>的过程中还没有用到<code>register</code>，实际上当我们定义好模板过滤器后需要对他们进行注册才能正常使用，使用一下语句注册：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register.filter(<span class="string">'cut'</span>, cut) //(过滤器名称，函数本身)</span><br></pre></td></tr></table></figure><blockquote><p>实际上我们可以还可以使用<strong>@修饰器</strong>在定义的时候进行注册：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//无参时直接@register.filter</span><br><span class="line"><span class="meta">@register.filter(name='cut') </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(value, arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> value.replace(arg, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="自定义模板标签"><a href="#自定义模板标签" class="headerlink" title="自定义模板标签"></a>自定义模板标签</h2><p>先略过,有需要再研究。。<a href="https://www.w3cschool.cn/django/cqoetozt.html" target="_blank" rel="noopener">POTAL</a></p><hr><h1 id="模板库文件放在哪里好？"><a href="#模板库文件放在哪里好？" class="headerlink" title="模板库文件放在哪里好？"></a>模板库文件放在哪里好？</h1><p><strong>模板库</strong>是Django能够导入的基本结构。</p><p>建议的目录结构如下：</p><ol><li>为自定义的模板库单独建一个app并在<code>INSTALLED_APPS</code>中注册（只有注册的模板库才能被导入）。</li><li>在合适的<strong>app根目录</strong>下为模板们建一个单独的文件夹。</li><li>在这个文件夹下建立<code>__init__.py</code>文件和自定义模板库文件。</li></ol><hr><h1 id="自定义的模板库怎么导入到模板中？"><a href="#自定义的模板库怎么导入到模板中？" class="headerlink" title="自定义的模板库怎么导入到模板中？"></a>自定义的模板库怎么导入到模板中？</h1><blockquote><p>这里注意对<strong>模板库</strong>和<strong>模板</strong>的概念进行区分</p></blockquote><p>我们在编写<strong>模板</strong>时可以使用如下语句来导入我们自定义的<strong>模板库</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load 模板库名 %&#125;</span><br></pre></td></tr></table></figure><p>load模板标签会检查<code>INSTALLED_APPS</code>，只有已安装的app内的模板库才能被加载。<br>这里<strong>模板库</strong>虽然是存放在某个特定的APP内的，但是<code>load</code>加载模板库时并没有涉及到这个APP。</p>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模板系统-RequestContext和Context处理器</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-276f.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20181121-276f.html</url>
      
        <content type="html"><![CDATA[<p>视图函数需要传递一个<strong>context</strong>给模板完成渲染，然后返回给用户完整页面。当向多个不同的模板中传入大量<strong>相同的键值对</strong>时会多写很多重复的代码，可以使用 <code>RequestContext</code>。<a id="more"></a></p><ol><li>首先定义这些可复用的键值对</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_items</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受request纯粹是因为里面构造返回值字典时可能会用到<br>换言之，它不是必须的：当你确定返回值字典用不着request完全可以不传参</p><ol start="2"><li>构造视图函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> RequestContext</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_1</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">    rcontext = RequestContext(request, d&#123;...&#125;, processors=[...])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>视图函数的第一个参数必须是request（HttpRequest对象实例）<br>这里我们使用 <strong>RequestContext</strong> 对象代替 <strong>Context</strong> 对象<br>构造RequestContext需要注意：</p><ul><li>第一个参数时request</li><li>第二个参数是字典，代表非公用的键值对</li><li><code>processors</code>是包含Context处理器的列表/元组</li><li>将RequestContext对象传递给<code>render_to_response</code>方法进行渲染<br>与Context对象不同，使用RequestContext除了传递处理器外还需要传递一个额外的字典（见上第二个参数）<br>使用关键字<code>context_instance</code>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> render_to_response(模板文件, 非公用字典, </span><br><span class="line">context_instance=RequestContext(request, processors=[...]))</span><br><span class="line"><span class="comment">#这里在构建RequestContext对象的时候并没有传递非公用字典,</span></span><br><span class="line"><span class="comment">#而是将该字典传递给了render_to_response方法！！！</span></span><br></pre></td></tr></table></figure><p>但是频繁的键入<code>processors</code>还是会产生大量的代码（这个是真的懒。。）所以Django设计了<strong>全局context处理器</strong>：一般在<code>settings.py</code>的类似于’context_processors’的列表中声明，不同版本可能关键字不一样<br>激活相应的处理器RequestContext将自动包含相对应的一部分变量到context中，具体如下：</p><ul><li><p><code>django.core.context_processors.auth</code>:<br>  <code>user</code>：一个<code>django.contrib.auth.models.User/AnonymousUser</code>实例<br>  <code>message</code>：当前登录用户的消息列表<br>  <code>perms</code>：当前登录用户的权限</p></li><li><p><code>django.core.context_processors.debug</code>:<br>  <code>debug</code>：settings.DEBUG值，检测是否处于debug模式，貌似一直为True？<br>  <code>sql_queries</code>：顺序记录每个SQL查询以及耗费时间<br>  这个处理器还需要满足一些其他的条件…</p></li><li><p><code>django.core.context_processors.i18n</code>:<br>  <code>LANGUAGES</code><br>  <code>LANGUAGE_CODE</code></p></li><li><p><code>django.core.context_processors.request</code></p></li><li><p><code>django.core.context_processors.messages</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>方差分析2-单因素方差分析</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181118-3a7c.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181118-3a7c.html</url>
      
        <content type="html"><![CDATA[<p>单因素实验是最简单的，人活在世，肯定不会自己难为自己，因此掌握最基础、最根本的单因素方差分析是十分必要的。</p><p>单因素方差分析的目的是：分析某个因素的<strong>不同水平</strong>之间的差异。<a id="more"></a></p><p>前面在讲<a href="/statistics/20181022-111b.html">方差分析的基本原理</a>时使用的例子实际上就是单因素的方差分析。</p><p>在进行单因素的实验设计时，不同处理（组）的样本量一般都是相同的（n），请钻牛角尖的同学不要自己难为自己。</p><p>下面这张公式表展示了单因素方差分析的精华：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118163608.jpg" alt=""></p><p>下面用一个例子详细阐释单因素方差分析的步骤。</p><p>题目如下：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118164235.jpg" alt=""></p><p>步骤：</p><p>1、搞清楚 $n$ 和 $k$：$n$ 是每个组的样本量，$k$ 是分组个数，这里 $n=4,\ k=5$</p><p>2、计算<strong>每组</strong>对应的 <strong>和($T_i=\sum{x}$)</strong> 和 <strong>平方和($\sum{x^2}$)</strong></p><p>&emsp;&ensp;计算所有组的 <strong>总和($T=\sum\sum{x_{ij}}=530.5$)</strong> 和 <strong>总平方和($\sum\sum{x_{ij}^2}=14258.21$)</strong></p><p>3、计算 $C=\frac{T^2}{nk}=\frac{530.5^2}{4{\times}5}=14071.51$</p><p>&emsp;&ensp;计算 $SS_T=\sum\sum{x_{ij}^2}-C=14258.21-14071.51=186.7$</p><p>&emsp;&ensp;计算 $SS_t=\frac1n\sum_{i=1}^{k}{T_i^2}-C=\frac{126.4^2+…+91.4^2}{4}-14071.51=173.71$</p><p>&emsp;&ensp;计算 $SS_e=SS_T-SS_t=186.7-173.71=12.99$</p><p>&emsp;&ensp;计算 $df_T=nk-1=4{\times}5-1=19$</p><p>&emsp;&ensp;计算 $df_t=k-1=5-1=4$</p><p>&emsp;&ensp;计算 $df_e=k(n-1)=5{\times}(4-1)=15$</p><p>&emsp;&ensp;计算 $S_t^2=\frac{SS_t}{df_t}=\frac{173.71}{4}=43.43$</p><p>&emsp;&ensp;计算 $S_e^2=\frac{SS_e}{df_e}=\frac{12.99}{15}=0.866$</p><p>&emsp;&ensp;计算 $F=\frac{S_t^2}{S_e^2}=\frac{43.43}{0.866}=50.15$</p><p>查F值临界表知，$F_{0.05\ (4,15)}=3.06$，$F_{0.01\ (4,15)}=4.89$</p><p>比较知，5个地区黄鼬冬季针毛长度差异<strong>极其显著</strong>。</p><p>结果表示如下：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118230641.jpg" alt=""></p><p>到这里整体的方差分析就做完了，为了详细比较<strong>具体两个地区</strong>之间的差异是否显著，在进行完整体的方差分析<strong>之后</strong>可以进行<strong>多重比较</strong>。</p><p>以<strong>LSD检验</strong>为例解释多重比较的步骤：</p><p>计算<strong>平均数差数的标准误</strong> $S_{\overline{X_1}-\overline{X_2}}=\sqrt{\frac{2S_e^2}{n}}=\sqrt{2{\times}0.866}{4}=0.658$</p><p>注意，在LSD检验中，不管我们选择哪两个处理进行差异分析，这个 <strong>标准误 $S_{\overline{X_1}-\overline{X_2}}$ </strong>都是一样的！相应的，它们使用的<strong>最小差数 $LSD_\alpha$ </strong>也是通用的！</p><p>$$LSD_{0.05}=t_{0.05}{\cdot}S_{\overline{X_1}-\overline{X_2}}=2.131{\times}0.658=1.402$$</p><p>$$LSD_{0.01}=t_{0.01}{\cdot}S_{\overline{X_1}-\overline{X_2}}=2.947{\times}0.658=1.939$$</p><p>然后愉快的进行比较就可以啦</p><p>选择一种结果表示法，这里选用<strong>字母标记法</strong>，表示结果如下：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118232057.jpg" alt=""></p><p>结果表明，东北与其它地区，内蒙古与安徽、贵州，河北与贵州黄鼬冬季针毛长度差异均达到极显著水平，安徽与贵州差异达到显著水平，而内蒙古与河北、河北与安徽差异不显著。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写论文值得收藏的8个网站</title>
      <link href="/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20181106-e8e2.html"/>
      <url>/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20181106-e8e2.html</url>
      
        <content type="html"><![CDATA[<p>① <span style="font-size:20px">OALib 免费论文搜索引擎</span> ( <a href="http://www.oalib.com/" target="_blank" rel="noopener">http://www.oalib.com/</a> )</p><p>② <span style="font-size:20px">HighWire 斯坦福学术文献电子期刊</span> ( <a href="https://www.highwirepress.com/" target="_blank" rel="noopener">https://www.highwirepress.com/</a> )</p><p>③ <span style="font-size:20px">Intute 学术资源搜索工具</span> ( <a href="https://www.jisc.ac.uk/" target="_blank" rel="noopener">https://www.jisc.ac.uk/</a> )</p><p>④ <span style="font-size:20px">FindaRticles 文献论文站点</span> ( <a href="http://findarticles.com/" target="_blank" rel="noopener">http://findarticles.com/</a> )</p><p>⑤ <span style="font-size:20px">Intechopen 免费科技文献</span> ( <a href="https://www.intechopen.com/" target="_blank" rel="noopener">https://www.intechopen.com/</a> )</p><p>⑥ <span style="font-size:20px">LolMyThesis 哈佛毕业论文分享网站</span> ( <a href="http://lolmythesis.com/" target="_blank" rel="noopener">http://lolmythesis.com/</a> )</p><p>⑦ <span style="font-size:20px">万方数据库</span> ( <a href="http://www.wanfangdata.com.cn/index.html" target="_blank" rel="noopener">http://www.wanfangdata.com.cn/index.html</a> )</p><p>⑧ <span style="font-size:20px">全国图书馆论文搜索网</span> ( <a href="http://www.ucdrs.superlib.net/" target="_blank" rel="noopener">http://www.ucdrs.superlib.net/</a> )</p><hr><p>以上资料来自<a href="https://zhuanlan.zhihu.com/p/27569947" target="_blank" rel="noopener">知乎同学</a>，点击查看图片和详情。</p>]]></content>
      
      
      <categories>
          
          <category> 快捷清单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方差分析1-基本原理、F检验、多重比较</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181022-111b.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181022-111b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、问题引入"><a href="#一、问题引入" class="headerlink" title="一、问题引入"></a><strong>一、问题引入</strong></h1><h2 id="1-什么是方差分析？"><a href="#1-什么是方差分析？" class="headerlink" title="1.什么是方差分析？"></a><strong>1.什么是方差分析？</strong></h2><p><span style="color:green"><strong>方差分析</strong></span>用于<strong>两个</strong>及<strong>两个以上</strong>样本的均数差异的显著性检验。<a id="more"></a></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>中文名</td><td>方差分析</td></tr><tr><td>中文别名</td><td>变异数分析、变量分析、F检验</td></tr><tr><td>外文名</td><td>Analysis of Variance, F test</td></tr><tr><td>简称</td><td>ANOVA</td></tr><tr><td>提出者</td><td>R.A.Fisher</td></tr></tbody></table><h2 id="2-t检验为什么不能代替方差分析？"><a href="#2-t检验为什么不能代替方差分析？" class="headerlink" title="2.t检验为什么不能代替方差分析？"></a><strong>2.t检验为什么不能代替方差分析？</strong></h2><p>t检验只适用于两个样本均数间的差异分析，当设计两个以上的样本时只能进行二元拆分，这种操作并不优雅。</p><p><strong>1.检验过程繁琐。</strong>m个样本需要进行$C_m^2$组t检验，自寻烦恼。</p><p><strong>2.无统一的试验误差，误差估计的精确性和检验的灵敏性低。</strong>（<span style="color:green">？？？</span>）</p><p><strong>3.二元切分后进行多次t检验会使犯第Ⅰ类错误（假阳性错误）的概率大大增加。</strong>t检验只能将每次的检验犯错误概率控制在$\alpha$以内，在多次检验时这个概率会逐渐变大。例如一个三样本的均值差异检验共需要进行$C_3^2=3$次t检验，每一次犯错误的概率为$\alpha$，这意味着每一次检验不犯错误的概率为$1-\alpha$，连续三次不犯错误的概率为$(1-\alpha)^3$，所以这三次t检验犯第一类错误的概率为$1-(1-\alpha)^3=0.142615$（当$\alpha=0.05$时），这个概率相比于0.05已经大了很多了。由此可知，当$n{\to}\infty$时，犯第一类错误的概率将会趋近于1。</p><hr><h1 id="二、方差分析的基本原理"><a href="#二、方差分析的基本原理" class="headerlink" title="二、方差分析的基本原理"></a><strong>二、方差分析的基本原理</strong></h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1.思想"></a><span style="color:green">1.思想</span></h2><p>多个样本一般可以来自多个不同的<strong>处理</strong>(treatment)，比如注射不同的药物等，这些处理是我们可以<strong>控制</strong>的。</p><p>不同的处理有可能影响并致使实验结果产生差异，这种影响一般是可以人为控制的，这种效应叫做<strong>处理效应</strong>(treatment effect)。</p><p>对每个个体的观测值不同，除了处理效应施加影响，还包括实验过程中偶然性因素和测量误差的干扰。</p><h2 id="2-目的"><a href="#2-目的" class="headerlink" title="2.目的"></a><span style="color:green">2.目的</span></h2><p>方差分析可以确定上面提到的<strong>处理效应</strong>和<strong>实验误差</strong>对总差异的贡献程度。</p><p>一般来说，实验误差是合理不可控的，同时它对总差异的影响也是很小的。因此我们可以比较<strong>处理效应</strong>和<strong>实验误差</strong>。</p><p>而实验误差显然不是我们关心的东西，我们关心的应该是<strong>处理</strong>间（组间）均值是否有差异，即我们关心应该是<strong>处理效应</strong>：<br>● 处理效应和实验误差相差不大，意味着处理效应对指标影响不大。<br>● 处理效应比实验误差大很多，处理效应对实验结果差异有很大影响。</p><h2 id="3-用途"><a href="#3-用途" class="headerlink" title="3.用途"></a><span style="color:green">3.用途</span></h2><ol><li>多样本均数的比较</li><li>多因素间相互作用的分析</li><li>回归方程的假设假设</li><li>方差的同质性检验</li></ol><hr><h1 id="三、数学模型"><a href="#三、数学模型" class="headerlink" title="三、数学模型"></a><strong>三、数学模型</strong></h1><p>根据上面对<strong>总差异</strong>的定性分析（由处理效应和实验误差构成）建立定量的数学模型。</p><p>观测数据记录形式一般如下：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201810/20181022194352.png" alt=""></p><p>其中每列（1,…,k）代表k个不同的处理，即k个样本；行数代表每种处理的重复次数，即一个样本的样本容量。</p><h2 id="1-线性等权加和模型"><a href="#1-线性等权加和模型" class="headerlink" title="1.线性等权加和模型"></a>1.线性等权加和模型</h2><p>这里采用最简洁的线性模型定量描述上述关系：</p><p>$$\begin{split}<br>x_{ij}&amp;=\mu+\tau_i+\epsilon_{ij}\\<br>i&amp;=1,…,k\\<br>j&amp;=1,…,n<br>\end{split}$$</p><ul><li>$\mu$是<strong>总体均数</strong>；</li><li>$\tau_i$是第$i$次处理的<strong>处理效应</strong>；</li><li>$\epsilon_{ij}$是第$i$次处理中第$j$个样本的<strong>实验误差</strong>；</li><li>$x_{ij}$是第$i$次处理中第$j$个样本的<strong>观测值</strong>；</li></ul><p>上面的线性模型只是简单的对总体均值、处理效应和实验误差进行<strong>等权加和</strong>进而构造出<strong>观测值</strong>。这种构造形式可能不是最优的形式，但却是最简单最易理解的形式。这进一步印证了解决问题总是一个化繁为简、由简入繁的过程。（<span style="color:green">当前更优的模型构建方式？？？</span>）</p><h2 id="2-处理效应不总是人为可控的"><a href="#2-处理效应不总是人为可控的" class="headerlink" title="2.处理效应不总是人为可控的"></a>2.处理效应不总是人为可控的</h2><p>虽然说大多数情况下通过<strong>实验设计</strong>我们可以控制处理的种类，即控制处理效应，但是这在某些实验中$\tau_i$却是不可控的。根据$\tau_i$是否可控将上面的数学模型分为三类：</p><table><thead><tr><th></th><th>$\tau_i$取值</th><th>泛化能力</th></tr></thead><tbody><tr><td>固定模型</td><td>$\tau_i=\mu_i-\mu$为常数且$\sum_{i=1}^{k}{\tau_i}=0$</td><td>结果不能扩展到其他处理</td></tr><tr><td>随机模型</td><td>$\tau_i$从$N(0,\sigma^2)$中采样</td><td>结果可以扩展到其他处理</td></tr><tr><td>混合模型</td><td>略略略</td><td>略略略</td></tr></tbody></table><h2 id="3-样本方差表达式求解"><a href="#3-样本方差表达式求解" class="headerlink" title="3.样本方差表达式求解"></a>3.样本方差表达式求解</h2><p>首先我们要明确方差求解式的结构：$\frac{平方和}{自由度}$</p><p>下面分别求解分子和分母。</p><h3 id="1-求分子（平方和）"><a href="#1-求分子（平方和）" class="headerlink" title="(1) 求分子（平方和）"></a>(1) 求分子（平方和）</h3><p>上面的模型虽然说简洁，但毕竟还是个花架子，我们需要把它的各个单项同真正的样本联系起来。</p><p>那么怎么将<strong>处理效应</strong>和<strong>随机误差</strong>同已知样本联系起来呢？这里有两句话自行体会：</p><ol><li><strong>组间的</strong>平均数差异是由<strong>处理效应</strong>引起的：$\overline{x_i}-\overline{x}$</li><li><strong>组内的</strong>差异是由<strong>随机误差</strong>引起的：$x_{ij}-\overline{x_i}$</li></ol><p>然后简单变换：</p><p>$$\begin{split}<br>(x_{ij}-\bar{x})&amp;=(x_{ij}-\overline{x_i})+(\overline{x_i}-\bar{x})\\<br>(x_{ij}-\bar{x})^2&amp;=[(x_{ij}-\overline{x_i})+(\overline{x_i}-\bar{x})]^2\\<br>&amp;=(x_{ij}-\overline{x_i})^2+(\overline{x_i}-\bar{x})^2+2(x_{ij}-\overline{x_i})(\overline{x_i}-\bar{x})<br>\end{split}$$</p><p>针对某个特定的<strong>处理</strong>对样本内所有观测数据求和：</p><p>$\sum_{j=1}^{n}(x_{ij}-\bar{x})^2=\sum_{j=1}^{n}(x_{ij}-\overline{x_i})^2+\sum_{j=1}^{n}(\overline{x_i}-\bar{x})^2+2\sum_{j=1}^{n}(x_{ij}-\overline{x_i})(\overline{x_i}-\bar{x})$</p><p>这里有个玄学项 $2\sum_{j=1}^{n}(x_{ij}-\overline{x_i})(\overline{x_i}-\bar{x})$，我们将与 $j$ 无关的项提前：</p><p>$2\sum_{j=1}^{n}(x_{ij}-\overline{x_i})(\overline{x_i}-\bar{x})=2(\overline{x_i}-\bar{x})\sum_{j=1}^{n}(x_{ij}-\overline{x_i})$</p><p><strong>均值</strong>具有这样一个特性：一个样本内所有观测数据到均值的距离（包含正负号）和为0。</p><p>所以有这样一个结论：$2\sum_{j=1}^{n}(x_{ij}-\overline{x_i})(\overline{x_i}-\bar{x})=0$</p><p>即$\sum_{j=1}^{n}(x_{ij}-\bar{x})^2=\sum_{j=1}^{n}(x_{ij}-\overline{x_i})^2+\sum_{j=1}^{n}(\overline{x_i}-\bar{x})^2$</p><p>然后我们将不同<strong>处理</strong>的观测数据的<strong>离均差平方</strong>进行累加：</p><p>$\sum_{i=1}^{k}\sum_{j=1}^{n}(x_{ij}-\bar{x})^2=\sum_{i=1}^{k}\sum_{j=1}^{n}(x_{ij}-\overline{x_i})^2+\sum_{i=1}^{k}\sum_{j=1}^{n}(\overline{x_i}-\bar{x})^2$</p><p>化简得：</p><p>$\underbrace{\sum_{i=1}^{k}\sum_{j=1}^{n}(x_{ij}-\bar{x})^2}_{SS_T}=\underbrace{\sum_{i=1}^{k}\sum_{j=1}^{n}(x_{ij}-\overline{x_i})^2}_{SS_e}+\underbrace{n\sum_{i=1}^{k}(\overline{x_i}-\bar{x})^2}_{SS_t}$</p><p>即：$SS_T(总平方和)=SS_e(组内平方和)+SS_t(组间平方和)$</p><p>预算</p><p>$$\begin{split}<br>T&amp;=\sum_{i=1}^{k}\sum_{j=1}^{n}x_{ij}\\<br>T_i&amp;=\sum_{j=1}^{n}x_{ij}\\<br>C&amp;=\frac{T^2}{kn}<br>\end{split}$$</p><p>得</p><p>$$\begin{split}<br>SS_T&amp;=\sum_{i=1}^{k}\sum_{j=1}^{n}x_{ij}^2-C\\<br>SS_t&amp;=\frac{1}{n}\sum_{i=1}^{k}T_i^2-C\\<br>SS_e&amp;=SS_T-SS_t<br>\end{split}$$</p><h3 id="2-求分母（自由度）"><a href="#2-求分母（自由度）" class="headerlink" title="(2) 求分母（自由度）"></a>(2) 求分母（自由度）</h3><p>分母就是与$SS_T$、$SS_t$和$SS_e$相关的<strong>自由度</strong>$df$:</p><p>$$\begin{split}<br>df_T&amp;=nk-1\\<br>df_t&amp;=k-1\\<br>df_e&amp;=df_T-df_t\\<br>&amp;=k(n-1)<br>\end{split}$$</p><h3 id="3-求方差"><a href="#3-求方差" class="headerlink" title="(3) 求方差"></a>(3) 求方差</h3><p>组间方差</p><p>$$\begin{split}<br>s_t^2&amp;=\frac{SS_t}{df_t}\\<br>s_e^2&amp;=\frac{SS_e}{df_e}<br>\end{split}$$</p><hr><h1 id="四、-F-检验"><a href="#四、-F-检验" class="headerlink" title="四、$F$ 检验"></a><strong>四、$F$ 检验</strong></h1><h2 id="1-F-值的定义"><a href="#1-F-值的定义" class="headerlink" title="1.$F$ 值的定义"></a><strong>1.$F$ 值的定义</strong></h2><p>$F$ 值的定义：$$F=\frac{s_1^2}{s_2^2}$$<br>这里 $s_1^2$ 和 $s_2^2$ 都是随机采样于<strong>正态总体($\mu$, $\sigma$)</strong>，它们可能具有不同的<strong>样本容量（自由度）</strong>。<br>习惯上，我们让 $F$ 值<strong>大于1</strong>，即大方差做分子，小方差做分母。</p><h2 id="2-公式迁移"><a href="#2-公式迁移" class="headerlink" title="2.公式迁移"></a><strong>2.公式迁移</strong></h2><p>在<strong>方差分析</strong>中，我们计算出了两个方差：组间方差 $S_t^2$ 和组内方差 $S_e^2$，它们分别代表了<strong>处理效应</strong>和<strong>实验误差</strong>，即<br>$$F=\frac{S_t^2}{S_e^2}=\frac{处理效应}{实验误差}$$</p><p>对于上面的定义需要解释两点：</p><p><strong>(1) 按照 $F$ 值的定义，分子和分母应该来自同一个正态总体</strong></p><p>如果我们假设处理效应和实验误差相差不多（这将作为我们假设检验的<strong>原假设/无效假设/零假设</strong>），即 $S_t^2{\approx}S_e^2$，此时我们可以认为 $S_t^2$ 和 $S_e^2$ 来自于同一个正态总体。</p><p><strong>(2) 按照 $F$ 值的定义，分子是大方差，分母是小方差</strong></p><p>方差分析的目的是确定 $S_t^2$（处理效应）和 $S_e^2$（实验误差）的相对大小，由于<strong>实验误差</strong>这种东西一般情况下都是不可控的，而且也不会很大，所以我们认为一般只存在一下两种情况：</p><ol><li><p>处理效应比实验误差大得多</p></li><li><p>处理效应与实验误差相差不多</p></li></ol><h2 id="3-F-临界值表"><a href="#3-F-临界值表" class="headerlink" title="3.$F$ 临界值表"></a><strong><a href="http://blog.sciencenet.cn/blog-456367-437322.html" target="_blank" rel="noopener">3.$F$ 临界值表</a></strong></h2><hr><h1 id="五、多重比较"><a href="#五、多重比较" class="headerlink" title="五、多重比较"></a><strong>五、多重比较</strong></h1><p>比较其中两组处理平均数间差异的显著性，本质上与t检验没有任何区别</p><h2 id="1-最小显著差数法（LSD）"><a href="#1-最小显著差数法（LSD）" class="headerlink" title="1.最小显著差数法（LSD）"></a><strong>1.最小显著差数法（LSD）</strong></h2><p><strong>Least Significant Difference</strong></p><h3 id="1-检验方法"><a href="#1-检验方法" class="headerlink" title="(1) 检验方法"></a><strong>(1) 检验方法</strong></h3><p>本质上是两均数的t检验。</p><ol><li>计算<strong>达到</strong>差异显著的<strong>最小差数</strong>，记为 <strong>$LSD_\alpha$</strong></li></ol><p>$$LSD_\alpha=t_\alpha{\cdot}S_{\overline{X_1}-\overline{X_2}}$$</p><p>其中 $S_{\overline{X_1}-\overline{X_2}}$ 为<strong>平均数差数的标准误</strong>：</p><p>$$\begin{split}<br>S_{\overline{X_1}-\overline{X_2}}&amp;&amp;=\sqrt{\frac{S_1^2}{n_1}+\frac{S_2^2}{n_2}}\\<br>&amp;&amp;=\sqrt{S_e^2{\cdot}(\frac{1}{n_1}+\frac{1}{n_2})}\\<br>&amp;&amp;=\sqrt{\frac{2S_e^2}{n}}{\quad}if{\quad}n_1=n_2=n<br>\end{split}$$</p><div style="border:1px solid black;padding:20px"><strong>☺ 为什么令 $S_1^2=S_2^2=S_e^2$ ?</strong><br>上述公式的推导本身基于我们做出的<strong>无效假设</strong>（处理效应与实验误差相差不多）！<br><br><strong>☺ 查表的自由度依据？</strong><br>因为本质上是两个均数差异的t检验，因此需要查t临界值表。<br>因为均数差数标准误最终化归到了 $S_e^2$，因此查表的自由度依据的是 $df_e$ 而不是 $df_t$。</div><ol start="2"><li>将两个处理平均数的差值绝对值 $\overline{x_1}-\overline{x_2}$ 与 $LSD_\alpha$ 进行比较</li></ol><h3 id="2-结果表示"><a href="#2-结果表示" class="headerlink" title="(2) 结果表示"></a><strong>(2) 结果表示</strong></h3><p>结果表示方法仅仅是用于优化两两比较次数，在使用结果表示方法之前都需要计算 <strong>$LSD_\alpha$</strong>。</p><h4 id="a-标记字母法"><a href="#a-标记字母法" class="headerlink" title="a. 标记字母法"></a><strong>a. 标记字母法</strong></h4><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118145733.jpg" alt=""></p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118145822.jpg" alt=""></p><h4 id="b-梯形比较法-三角形法"><a href="#b-梯形比较法-三角形法" class="headerlink" title="b. 梯形比较法/三角形法"></a><strong>b. 梯形比较法/三角形法</strong></h4><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181118150228.jpg" alt=""></p><h2 id="2-最小显著极差法（LSR）"><a href="#2-最小显著极差法（LSR）" class="headerlink" title="2.最小显著极差法（LSR）"></a><strong>2.最小显著极差法（LSR）</strong></h2><p><strong>Least Significant Ranges</strong></p><h3 id="1-新复极差检验（SSR）"><a href="#1-新复极差检验（SSR）" class="headerlink" title="(1) 新复极差检验（SSR）"></a>(1) 新复极差检验（SSR）</h3><p>新复极差法用于<span style="color:orange">方差分析后的</span>两两比较，有助于减少<strong>第二类错误</strong>，但是会增加<strong>第一类错误</strong>。</p><p>原假设仍然是假设两个均值无差异：$\mu_A-\mu_B=0$</p><p>步骤如下：</p><p>1.平均数降序排序</p><p>2.计算<strong>平均数标准误</strong>：$$S_{\bar{X}}=\sqrt{\frac{S_e^2}{n}}$$</p><p>这里两组处理的样本容量是一致的：$n_1=n_2=n$，实验设计时一般也不会设计不一致这种骚操作。</p><p>3.根据<strong>自由度 $df_e$ </strong>和排序平均数中相应两个数之间包含的平均数个数<strong>M</strong>查<a href="https://wenku.baidu.com/view/3a41820b763231126edb1197.html" target="_blank" rel="noopener"><strong>SSR值表</strong></a>，计算<strong>最小显著极差值</strong>（<strong>LSR值</strong>）：</p><p>$$LSR_\alpha=SSR_\alpha{\cdot}S_{\bar{X}}$$</p><p><div style="border:1px solid black;padding:20px"><strong>M值是个什么东西？</strong><br>排序平均数中相应两个数之间包含的平均数个数，即<strong>索引值差+1</strong>，相邻两个均数的M值为2。</div><br></p><h3 id="2-q检验"><a href="#2-q检验" class="headerlink" title="(2) q检验"></a>(2) q检验</h3><p><strong>q检验</strong>也叫<strong>NK检验</strong>，与SSR检验十分相似，不同的是在第二步计算 $LSR_\alpha$ 时使用的是 $q_\alpha$ 值，而不是 $SSR_\alpha$ 值，因此需要查<a href="https://wenku.baidu.com/view/afb5647155270722182ef712.html" target="_blank" rel="noopener"><strong> $q_\alpha$ 值表</strong></a>。</p><p>$$LSR_\alpha=q_\alpha{\cdot}S_{\bar{X}}$$</p><h2 id="3-各个方法应用场景"><a href="#3-各个方法应用场景" class="headerlink" title="3.各个方法应用场景"></a><strong>3.各个方法应用场景</strong></h2><p>上面提到的LSD检验、SSR检验（新复极差检验）、q检验分别有自己的适用场景</p><p>因此应用时</p><ol><li>对于精度要求高的检验，请使用<strong>q检验</strong>；</li><li><strong>SSR检验</strong>适用于一般的检验；</li><li><strong>LSD检验</strong>适用于将<strong>各个</strong>实验组与对照组进行比较。</li></ol><h1 id="六、方差分析的基本步骤"><a href="#六、方差分析的基本步骤" class="headerlink" title="六、方差分析的基本步骤"></a><strong>六、方差分析的基本步骤</strong></h1><p>从上面的过程我们可以总结出方差分析的三个大步骤：</p><ol><li>对样本数据的<strong>总平方和</strong>和<strong>总自由度</strong>分解为各个变异因素的平方和和自由度；</li><li>进行<strong> $F$ 检验</strong>，检验各个变异因素在总变异中的重要程度；</li><li>组间均数进行两两比较。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假设检验-显著性假设检验</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181018-327a.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181018-327a.html</url>
      
        <content type="html"><![CDATA[<p>不管是下面的单样本还是双样本都有两个大前提：总体服从正态分布、方差齐性！<a id="more"></a></p><h1 id="1-单样本平均数-bar-x-的差异显著性检验"><a href="#1-单样本平均数-bar-x-的差异显著性检验" class="headerlink" title="1. 单样本平均数$\bar{x}$的差异显著性检验"></a>1. <strong>单样本平均数$\bar{x}$的差异显著性检验</strong></h1><p>这里指的实际上是一个样本（的平均数）和总体（的平均数）间的差异显著性，因为我们只有一个样本，这就要求总体参数（这里是均值）已知，这通常是一个理论值、经验值或者期望值。</p><h2 id="1-大样本（n≥30）的均数检验"><a href="#1-大样本（n≥30）的均数检验" class="headerlink" title="(1). 大样本（n≥30）的均数检验"></a>(1). <strong>大样本（n≥30）的均数检验</strong></h2><p><strong>大样本</strong>通常指的是n≥30，此时<strong>样本的均值</strong>将服从于<strong>正态分布</strong>，我们可以将其标准化为<strong>标准正态分布</strong>，进而使用<strong>u检验</strong>进行假设检验。</p><h3 id="a-总体方差-sigma-2-已知时"><a href="#a-总体方差-sigma-2-已知时" class="headerlink" title="a. 总体方差$\sigma^2$已知时"></a>a. <strong>总体方差$\sigma^2$已知时</strong></h3><p>总体方差$\sigma^2$已知时直接计算相应的u值：</p><p>$$\sigma_{\bar{x}}=\sqrt{\frac{\sigma^2}{n}}=\frac{\sigma}{\sqrt{n}}$$</p><p>$$u=\frac{\bar{x}-\mu_0}{\sigma_{\bar{x}}}=\frac{\bar{x}-\mu_0}{\sigma/\sqrt{n}}{\sim}N(0,1)$$</p><p>式中$\bar{x}$是<strong>样本均值</strong>，$\mu_0$是<strong>总体均值</strong>，$\sigma$是<strong>总体方差</strong>，$n$是<strong>样本容量</strong>。</p><h3 id="b-总体方差-sigma-2-未知时"><a href="#b-总体方差-sigma-2-未知时" class="headerlink" title="b. 总体方差$\sigma^2$未知时"></a>b. <strong>总体方差$\sigma^2$未知时</strong></h3><p>在<strong>大样本</strong>的条件下直接用<strong>样本方差$s^2$</strong>代替<strong>总体方差$\sigma^2$</strong>，计算u值的方法同上：</p><p>$$s_{\bar{x}}=\sqrt{\frac{s^2}{n}}=\frac{s}{\sqrt{n}}$$</p><p>$$u=\frac{\bar{x}-\mu_0}{s_{\bar{x}}}=\frac{\bar{x}-\mu_0}{s/\sqrt{n}}{\sim}N(0,1)$$</p><p>样本方差$s^2$的计算：</p><p>$$s^2=\frac{1}{n-1}\sum_{i=1}^{n}{(x_i-\bar{x})^2}$$</p><h2 id="2-小样本（n-lt-30）的均数检验"><a href="#2-小样本（n-lt-30）的均数检验" class="headerlink" title="(2). 小样本（n&lt;30）的均数检验"></a>(2). <strong>小样本（n&lt;30）的均数检验</strong></h2><p>小样本只能使用<strong>t检验</strong>，此时我们要求的是<strong>t值</strong>而不是u值。</p><p>小样本的方差$s^2$与总体的方差$\sigma^2$往往差距较大。</p><p>t检验时查临界值表依据的是自由度<strong>df</strong>，这个值通常是n-1。</p><p>$$s^2=\frac{1}{n-1}\sum_{i=1}^{n}{(x_i-\bar{x})^2}$$</p><p>$$s_{\bar{x}}=\sqrt{\frac{s^2}{n}}=\frac{s}{\sqrt{n}}$$</p><p>$$t=\frac{\bar{x}-\mu_0}{s_{\bar{x}}}=\frac{\bar{x}-\mu_0}{s/\sqrt{n}}{\sim}t(n-1)$$</p><hr><h1 id="2-两个样本平均数-bar-x-1-和-bar-x-2-间的差异显著性检验"><a href="#2-两个样本平均数-bar-x-1-和-bar-x-2-间的差异显著性检验" class="headerlink" title="2. 两个样本平均数$\bar{x_1}$和$\bar{x_2}$间的差异显著性检验"></a>2. <strong>两个样本平均数$\bar{x_1}$和$\bar{x_2}$间的差异显著性检验</strong></h1><h2 id="1-两个大样本（-n-1-ge30-且-n-2-ge30-）的均数检验"><a href="#1-两个大样本（-n-1-ge30-且-n-2-ge30-）的均数检验" class="headerlink" title="(1). 两个大样本（$n_1\ge30$且$n_2\ge30$）的均数检验"></a>(1). <strong>两个大样本（$n_1\ge30$且$n_2\ge30$）的均数检验</strong></h2><p>当两个样本都是<strong>大样本</strong>时，与单样本检验类似，仍可以使用<strong>u检验</strong>。</p><h3 id="a-如果两个样本的方差-sigma-1-和-sigma-2-已知"><a href="#a-如果两个样本的方差-sigma-1-和-sigma-2-已知" class="headerlink" title="a. 如果两个样本的方差$\sigma^1$和$\sigma^2$已知"></a>a. <strong>如果两个样本的方差$\sigma^1$和$\sigma^2$已知</strong></h3><p>$$\sigma_{\bar{x_1}-\bar{x_2}}=\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}$$</p><p>$$u=\frac{\bar{x_1}-\bar{x_2}}{\sigma_{\bar{x_1}-\bar{x_2}}}{\sim}N(0,1)$$</p><h3 id="b-如果两个样本的方差-sigma-1-和-sigma-2-未知"><a href="#b-如果两个样本的方差-sigma-1-和-sigma-2-未知" class="headerlink" title="b. 如果两个样本的方差$\sigma^1$和$\sigma^2$未知"></a>b. <strong>如果两个样本的方差$\sigma^1$和$\sigma^2$未知</strong></h3><p>使用$s_{\bar{x_1}-\bar{x_2}}$来代替$\sigma_{\bar{x_1}-\bar{x_2}}$:</p><p>$$s_{\bar{x_1}-\bar{x_2}}=\sqrt{\frac{s_1^2}{n_1}+\frac{s_2^2}{n_2}}$$</p><p>$$u=\frac{\bar{x_1}-\bar{x_2}}{s_{\bar{x_1}-\bar{x_2}}}{\sim}N(0,1)$$</p><h2 id="2-两个小样本（-n-1-le30-且-n-2-le30-）的均数检验"><a href="#2-两个小样本（-n-1-le30-且-n-2-le30-）的均数检验" class="headerlink" title="(2). 两个小样本（$n_1\le30$且$n_2\le30$）的均数检验"></a>(2). <strong>两个小样本（$n_1\le30$且$n_2\le30$）的均数检验</strong></h2><p>小样本使用t检验。</p><p>按照实验设计的不同，两个样本可以是<strong>独立样本</strong>，也可以是<strong>配对样本</strong>。</p><h3 id="A-配对样本均数的t检验"><a href="#A-配对样本均数的t检验" class="headerlink" title="A. 配对样本均数的t检验"></a><strong>A. 配对样本均数的t检验</strong></h3><p>此时两组数据将形成对子，因此两个样本的样本容量是一样的，即$n_1=n_2$。</p><p>配对可以减少<strong>个体差异</strong>对实验的影响，但是也会增加数据处理的复杂度。</p><p>配对情况通常有以下三类：</p><ol><li>两个相似个体组成一对进行不同的实验处理：此时并没有完全消除个体差异的影响。</li><li>同一个个体同时进行两种不同的处理：处理的空间位置不同。</li><li>同一个个体先后进行两种不同的处理：不同时间个体的状态可能不同。</li></ol><p>简单理解就是：第一类使用相似的两个个体，第二类同时使用同一个个体不同的部位，第三类先后使用同一个体相同的部位。</p><p>计算过程如下：</p><p>$$d_i=x_i-y_i$$</p><p>$$\bar{d}=\frac1n\sum_{i=1}^{n}d_i$$</p><p>$$s_d^2=\frac{1}{n-1}\sum_{i=1}^{n}(d_i-\bar{d})^2$$</p><p>$$t=\frac{\bar{d}}{s_d/\sqrt{n}}$$</p><p>$$df=n-1$$</p><p>查<strong>t检验临界值表</strong>时注意使用df值而不是n值。</p><h3 id="B-独立样本均数的t检验"><a href="#B-独立样本均数的t检验" class="headerlink" title="B. 独立样本均数的t检验"></a><strong>B. 独立样本均数的t检验</strong></h3><p>对于独立样本不存在配对情况，因此$n_1$和$n_2$往往不同。</p><p>两独立样本对应的<strong>总体方差</strong>可能不同，因此：</p><h4 id="a-当两样本方差相同或者假设相同时"><a href="#a-当两样本方差相同或者假设相同时" class="headerlink" title="(a). 当两样本方差相同或者假设相同时"></a><strong>(a). 当两样本方差相同或者假设相同时</strong></h4><p>此时计算自由度$v=n_1+n_2-2$</p><p>计算两个样本的均值$\bar{x_1}$和$\bar{x_2}$、方差$S_1^2$和$S_2^2$。</p><p>$$S_c^2=\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{v}$$</p><p>$$S_{\overline{X_1}-\overline{X_2}}=\sqrt{(\frac{1}{n_1}+\frac{1}{n_2})S_c^2}$$</p><p>$$t=\frac{\overline{x_1}-\overline{x_2}}{S_{\overline{X_1}-\overline{X_2}}}$$</p><h4 id="b-经过F检验两样本方差不同时"><a href="#b-经过F检验两样本方差不同时" class="headerlink" title="(b). 经过F检验两样本方差不同时"></a><strong>(b). 经过F检验两样本方差不同时</strong></h4><p>如果$n_1=n_2=n$:</p><p>计算方法与假设方差相同时一致，只是自由度为$n-1$而不是$2n-2$。</p><p>没看懂，先抄下来……</p><hr><h1 id="3-u分布与t分布的区别和联系"><a href="#3-u分布与t分布的区别和联系" class="headerlink" title="3. u分布与t分布的区别和联系"></a>3. <strong>u分布与t分布的区别和联系</strong></h1><p>u检验理论上要求大样本（即$n\to+\infty$），但是这在实际情况中是不可能的，所以教科书设置标准为n=30。</p><p>按照<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"><strong>中心极限定理</strong></a>：在适当的条件下，大量相互独立随机变量的均值经适当标准化后<strong>依分布收敛</strong>于正态分布。这就是说，只有在大（无穷）样本时，样本的均值才会服从正态分布。按照正态分布的概率密度函数：</p><p>$$f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2{\sigma}^2}}$$</p><p>它只与总体的参数$\mu$和$\sigma$有关，而与样本容量n无关。</p><p>有限样本特别是小样本下样本均值是不严格服从正态分布的，此时有个更好的分布可以刻画样本均值，这就是t分布。</p><p>$$f(t)=\frac{\Gamma(\frac{\nu+1}{2})}{\sqrt{\nu\pi}\Gamma(\frac{\nu}{2})}(1+\frac{t^2}{\nu})^{\frac{-(\nu+1)}{2}}$$</p><p>$$\nu=n-1$$</p><p>它只与样本容量n有关！</p><p>但是请注意，当$n\to+\infty$时，t分布将会十分接近<strong>标准正态分布</strong>，有图为证：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201810/20181021220458.png" alt=""></p><p>所以我们可以说，<strong>标准正态分布</strong>只是<strong>t分布</strong>在$n\to+\infty$时的一个特例！</p><p>因此在有限样本容量情况下，t检验应该更合理和精确，所以在t检验可行的情况下应该优先采用t检验。什么时候不可行呢？t检验是要根据自由度查表的，如果自由度值不合适导致无法查表，此时就比较尴尬了。也不知道现在这个问题是怎么解决的~。</p><p>下面是一张常见的<strong>t分布临界值表</strong>，我们可以发现当自由度超过30以后就不连续了~（不是绝对的，但道理大抵如此吧）</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201810/20181021223927.png" alt=""></p><p>同时由上图我们知道，当n=30的时候，t分布和u分布已经十分近似了，所以才有了这个<strong>样本容量大于30时用u检验</strong>的规则。</p><p>所以</p><p>▶ u检验适用于大样本的情景，t检验适用于小样本的情景。</p><p>▶ t分布更加符合有限样本的场景，理论上t检验更加精确。</p><hr><h1 id="4-两独立样本的方差的齐性检验"><a href="#4-两独立样本的方差的齐性检验" class="headerlink" title="4. 两独立样本的方差的齐性检验"></a>4. <strong>两独立样本的方差的齐性检验</strong></h1><p>原假设$H_0$: $\sigma_1=\sigma_2$ (方差齐性)</p><p>备择假设$H_1$: $\sigma_1\ne\sigma_2$ (方差不齐性)</p><p>$$F=\frac{max(S_1^2,S_2^2)}{min(S_1^2,S_2^2)}$$</p><p>$$v_1=n_1-1$$</p><p>$$v_2=n_2-1$$</p><p>查<strong>F检验临界值表</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假设检验-假设检验的基本原理</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181017-aa04.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20181017-aa04.html</url>
      
        <content type="html"><![CDATA[<h1 id="显著性检验的意义"><a href="#显著性检验的意义" class="headerlink" title="显著性检验的意义"></a>显著性检验的意义</h1><p>以<strong>均数差异显著性检验</strong>来说，两样本平均数为$\bar{x_1}$和$\bar{x_2}$，样本背后对应的<strong>总体</strong>均值相应的为$\mu_1$和$\mu_1$。下式十分容易理解：</p><p>$$\bar{x_1}=\mu_1+\bar{\epsilon_1}$$</p><p>$$\bar{x_2}=\mu_2+\bar{\epsilon_2}$$</p><p>其中$\bar{\epsilon_1}$和$\bar{\epsilon_2}$均表示<strong>实验误差</strong>。</p><p>当我们检验这两个样本的均数是否存在差异时依据的实际上是下面这个式子：</p><p>$$\bar{x_1}-\bar{x_2}=(\mu_1-\mu_2)+(\bar{\epsilon_1}-\bar{\epsilon_2})$$</p><p>即样本均数间的差异（<strong>表面差异</strong>）是由总体间的<strong>真实差异</strong>和<strong>抽样误差</strong>共同决定的。</p><p>所以显著性检验的目的就是：判明表面差异$\bar{x_1}-\bar{x_2}$是来源于总体真实差异$\mu_1-\mu_2$还是抽样误差$\bar{\epsilon_1}-\bar{\epsilon_2}$。<a id="more"></a></p><hr><h1 id="原假设与备择假设的选取"><a href="#原假设与备择假设的选取" class="headerlink" title="原假设与备择假设的选取"></a>原假设与备择假设的选取</h1><p>统计学为实际目的服务，我们对某个总体进行抽样都是有确切目的的。换句话说，我们往往希望通过自己的努力搜集一定的证据去证明一些东西，这实际上是一个立场问题。譬如质量检测人员希望检测出劣质产品而不是合格产品，因为其工作内容就是努力找出不合格的产品；给作物施加改良药物希望的是作物产量提高而不是一成不变…</p><p>一般情况下我们都希望总体的参数存在差异（当然这也不是绝对的~），这是我们假设检验的<strong>方向</strong>，此时我们进行试验的初衷也是希望改变总体的参数已完成我们的工作目标。我们将与假设检验方向相同的假设称为<strong>备择假设</strong>，与备择假设再逻辑上完备互斥的假设称为<strong>原假设</strong>（<strong>无效假设</strong>、<strong>零假设</strong>）。</p><p>所以原假设往往希望总体参数不发生变化，即表面差异由抽样误差决定。我们假装接受原假设，然后对原假设进行检验，实际上就是对<strong>表面差异由抽样误差决定</strong>这一基于原假设的结论进行检验。后续通过求解P(表面差异由抽样误差决定)通过<strong>小概率事件不可能发生原理</strong>对原假设予以接受或者拒绝。</p><p>◆ 由于原假设假定总体参数未发生变化，所以等号往往出现在原假设中</p><p>◆ 原假设与备择假设逻辑上完备互斥，且原假设由备择假设确定</p><p>◆ 备择假设的选择往往和实验人员的<strong>立场</strong>息息相关</p><p>下面对案例进行详细分析：</p><h2 id="案例1-零件质量问题"><a href="#案例1-零件质量问题" class="headerlink" title="案例1 零件质量问题"></a>案例1 零件质量问题</h2><p><strong>背景</strong>：<span style="font-family:楷体">一汽车配件生产企业生产的某种汽车零件长度标准为70毫米，为对零件质量进行控制，质量监测人员需要对生产线上的一台加工机床进行检查，以确定这台机床生产的零件是否符合标准要求。如果零件的平均长度大于或小于70毫米，则表明该零件质量不正常，必须对机床进行检查。<br></span><br><strong>分析</strong>：“70毫米”是（合格产品）总体的参数，质量检测人员将进行抽样，需要比较这个样本对应的总体和合格产品总体。质量检测人员希望通过搜集证据证明的是样本不合格（其工作任务总是希望找出不合格的产品），因此备择假设为“零件的平均长度大于或小于（不等于）70毫米”（这是检测人员希望通过努力证明的结果）。由备择假设确定原假设为“零件的平均长度等于70毫米”。</p><h2 id="案例2-合格率问题"><a href="#案例2-合格率问题" class="headerlink" title="案例2 合格率问题"></a>案例2 合格率问题</h2><p><strong>背景</strong>：<span style="font-family:楷体">一采购商需要采购一批构件，某供应商称其提供的构件合格率超过95%，为了检验其可信度，采购商随机抽取了一批样本进行检验。</span></p><p><strong>分析</strong>：“95%”是总体的参数。采购商的立场总是尝试证明构件合格率不超过95%，这也是总体参数发生改变的假设，因此我们将之作为备择假设。由备择假设确定的原假设为“构件合格率≥95%”。</p><h2 id="案例3-成分含量问题"><a href="#案例3-成分含量问题" class="headerlink" title="案例3 成分含量问题"></a>案例3 成分含量问题</h2><p><strong>背景</strong>：<span style="font-family:楷体">一乳制品生产商生产的奶粉被媒体曝光某种营养成分大大低于国家规定的2%的含量标准。</span></p><p>▶ <span style="font-family:楷体">现质量监督部门从保护消费者权益角度出发，对曝光的奶粉进行抽查，请对检验做出假设。</span></p><p><strong>分析</strong>：质量监督部门的立场是通过搜集证据证明该成分含量低于2%，因此备择假设为“成分含量&lt;2%”，原假设为“成分含量≥2%”。</p><p>▶ <span style="font-family:楷体">如果生产商相信其产品不存在上述问题，判断这是由竞争对手操纵的不正当竞争手段，并委托市场上的第三方检测机构进行检测，请对这一检验作出假设。</span></p><p><strong>分析</strong>：第三方检测机构的立场是通过自己的努力证明成分含量是合格的（因为这也是生产商希望看到的，如果这个检测机构跟金主爸爸做对就是有病了~），因此备择假设为“成分含量≤2%”，原假设为“成分含量&gt;2%”。</p><p>◆ 有趣的是，上面同一个情景却因为立场和初衷的不同导致备择假设和原假设完全相反，这表明统计学真的源于生活啊hahaha</p><p>（注：尊重原创，以上案例均来自于<a href="https://blog.csdn.net/sanqima/article/details/51307443?utm_source=blogxgwz0" target="_blank" rel="noopener">博客</a>。）</p><hr><h1 id="显著性检验的一般步骤"><a href="#显著性检验的一般步骤" class="headerlink" title="显著性检验的一般步骤"></a>显著性检验的一般步骤</h1><h2 id="1-提出假设"><a href="#1-提出假设" class="headerlink" title="1.提出假设"></a>1.提出假设</h2><p>大多数情况下都是：</p><p>$$H_0: \mu=\mu_0$$</p><p>$$H_1: \mu\ne\mu_0$$</p><h2 id="2-确定显著水平"><a href="#2-确定显著水平" class="headerlink" title="2.确定显著水平"></a>2.确定显著水平</h2><p><strong>显著水平$\alpha$</strong>（significance level）即否定$H_0$的概率标准，人为规定的小概率事件分界线。生物统计学中通常取0.05和0.01。</p><h2 id="3-计算显著概率"><a href="#3-计算显著概率" class="headerlink" title="3.计算显著概率"></a>3.计算显著概率</h2><p>在假定原假设的条件下求<strong>表面差异是由抽样误差造成的</strong>的概率。</p><p>对于总体参数μ已知、单样本均值$\bar{x}$可求条件下，表面差异为$\bar{x}-\mu$，这个不难理解哈。</p><p>◆ 判定是<strong>两尾检验</strong>还是<strong>单尾检验</strong>。</p><h2 id="4-统计推断"><a href="#4-统计推断" class="headerlink" title="4.统计推断"></a>4.统计推断</h2><p>根据<strong>小概率事件实际不可能性</strong>对原假设予以接受或者否定。</p><p>检验结果被表述为“在α水平上$\bar{x}$与μ差异<strong>不显著/显著/极其显著</strong>”。</p><ol><li>不显著：|u|&lt;1.96，即p&gt;0.05</li><li>显著：1.96≤|u|&lt;2.58，即0.01&lt;p≤0.05</li><li>极其显著：|u|≥2.58，即p≤0.01</li></ol><hr><h1 id="显著水平与两种类型的错误"><a href="#显著水平与两种类型的错误" class="headerlink" title="显著水平与两种类型的错误"></a>显著水平与两种类型的错误</h1><p>实际上原假设正确，但我们却否定了原假设而接受备择假设时会犯<strong>第Ⅰ类错误</strong>：原假设正确意味着总体参数本来是相同的，但是我们推断认为他们不同，即将抽样误差错判为了真实差异。</p><p>犯第Ⅰ类错误的概率是α，因此减少犯第Ⅰ类错误的概率只需要减少α的值即可。</p><p>本来我们应该否定原假设，但是推断后却没有否认原假设时会犯<strong>第Ⅱ类错误</strong>：本应该否认原假设意味着总体参数间是存在差异的，但是我们没有否认原假设说明我们将这个真实差异错判为了抽样误差。</p><p>当<strong>表面差异很小</strong>或者<strong>抽样误差很大</strong>时就十分容易犯第Ⅱ类错误。</p><p>表面差异或许不可控制，但是我们可以通过<strong>增大样本量</strong>来减小抽样误差</p><p>◆ <strong>第Ⅰ类错误</strong>拒绝了正确的原假设，<strong>第Ⅱ类错误</strong>接受了错误的原假设。</p><p>◆ <strong>第Ⅰ类错误</strong>又叫做<strong>假阳性</strong>错误：因为我们接受了错误的备择假设。</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/20181017x01.jpeg" alt=""></p><hr><h1 id="两尾检验和一尾检验"><a href="#两尾检验和一尾检验" class="headerlink" title="两尾检验和一尾检验"></a>两尾检验和一尾检验</h1><h2 id="◆-两种检验的适用情况？"><a href="#◆-两种检验的适用情况？" class="headerlink" title="◆ 两种检验的适用情况？"></a>◆ <strong>两种检验的适用情况？</strong></h2><p>如果仅仅检验是否存在差异，即不在乎谁大谁小，采用<strong>两尾检验</strong>；</p><p>凭经验和专业知识断定取大（或者取小），采用<strong>一尾检验</strong>。</p><h2 id="◆-一尾检验的临界值怎么确定？"><a href="#◆-一尾检验的临界值怎么确定？" class="headerlink" title="◆ 一尾检验的临界值怎么确定？"></a>◆ <strong>一尾检验的临界值怎么确定？</strong></h2><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/single_tail_test.png" alt=""></p><p>对于两位检验可以直接查表获取临界值，一尾检验需要先转化为两尾检验再求临界值，如上图所示：$u_{2\alpha}$的值可以直接通过两尾检验的表获取。所以有下面的这个公式：</p><p>$$一尾检验的u_{\alpha}=两尾检验的u_{2\alpha}$$</p><p>$$一尾检验的u_{0.05}=两尾检验的u_{0.10}=1.64$$</p><p>$$一尾检验的u_{0.01}=两尾检验的u_{0.02}=2.33$$</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex数学符号表</title>
      <link href="/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20181017-aedb.html"/>
      <url>/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20181017-aedb.html</url>
      
        <content type="html"><![CDATA[<p>Latex，展现公式的美！<a id="more"></a></p><h1 id="1-重音符号"><a href="#1-重音符号" class="headerlink" title="1. 重音符号"></a>1. 重音符号</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/accent.png" alt=""></p><p>$\overline{m+n}$，代码：<strong>\overline{m+n}</strong> → <strong>\overline{}</strong></p><p>$\underline{m+n}$，代码：<strong>\underline{m+n}</strong> → <strong>\underline{}</strong></p><p>$\overbrace{a+b+\cdots+z}^{26}$，代码：<strong>\overbrace{a+b+\cdots+z}^{26}</strong> → <strong>\overbrace{}^{}</strong></p><p>$\underbrace{a+b+\cdots+z}_{26}$，代码：<strong>\underbrace{a+b+\cdots+z}{26}</strong> → <strong>\underbrace{}&#95;{}</strong></p><blockquote><p>为避免markdown将 <code>_..._</code> 解释为斜体，可用 <code>&amp;#95;</code> 替换其中一个 <code>_</code>。</p></blockquote><p>符号顶部箭头，常用来表示<strong>向量</strong>：</p><table><thead><tr><th>显示</th><th>代码</th></tr></thead><tbody><tr><td>$\vec{a}$</td><td>\vec{a}</td></tr><tr><td>$\overrightarrow{AB}$</td><td>\overrightarrow{AB}</td></tr><tr><td>$\overleftarrow{AB}$</td><td>\overleftarrow{AB}</td></tr></tbody></table><hr><h1 id="2-独立符号"><a href="#2-独立符号" class="headerlink" title="2. 独立符号"></a>2. 独立符号</h1><p><strong>希腊字符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/Greek_letter.png" alt=""></p><p><strong>其他数学符号</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/else_symbol.png" alt=""></p><p><strong>其他AMS数学符号</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/else_symbol_AMS.png" alt=""></p><p><strong>非数学符号</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/nonmathematical_symbol.png" alt=""></p><p><strong>字体</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/number_and_letter.png" alt=""></p><h1 id="3-关系符号"><a href="#3-关系符号" class="headerlink" title="3. 关系符号"></a>3. 关系符号</h1><p><strong>关系符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/relation_character.png" alt=""></p><p><strong>AMS关系符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/relation_character_AMS.png" alt=""></p><p><strong>AMS否定关系符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/negative_symbol_AMS.png" alt=""></p><h1 id="4-运算符号"><a href="#4-运算符号" class="headerlink" title="4. 运算符号"></a>4. 运算符号</h1><p><strong>运算符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/operator.png" alt=""></p><p><strong>大运算符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/operator_large.png" alt=""></p><p>求和符号基本格式：<strong>\sum_{}^{}{}</strong></p><p><strong>AMS运算符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/operator_AMS.png" alt=""></p><h1 id="5-箭头"><a href="#5-箭头" class="headerlink" title="5. 箭头"></a>5. 箭头</h1><p><strong>箭头</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/arrow.png" alt=""></p><p><strong>AMS箭头</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/arrow_AMS.png" alt=""></p><h1 id="6-括号及定界符"><a href="#6-括号及定界符" class="headerlink" title="6. 括号及定界符"></a>6. 括号及定界符</h1><p><strong>定界符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/delimiter.png" alt=""></p><p><strong>AMS定界符</strong> <img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/latex_math/delimiter_AMS.png" alt=""></p><h1 id="7-空格"><a href="#7-空格" class="headerlink" title="7. 空格"></a>7. 空格</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/201811/20181117152615.jpg" alt="空格"></p><h1 id="8-其他小技巧"><a href="#8-其他小技巧" class="headerlink" title="8. 其他小技巧"></a>8. 其他小技巧</h1><h2 id="基本运算的格式控制"><a href="#基本运算的格式控制" class="headerlink" title="基本运算的格式控制"></a><span style="color:#EE0C4D">基本运算的格式控制</span></h2><table><thead><tr><th>显示</th><th>代码</th></tr></thead><tbody><tr><td>$\frac{a}{b}$</td><td>\frac{a}{b}</td></tr><tr><td>$a_{1}^{(2)}$</td><td>a_{1}^{(2)}</td></tr><tr><td>$\sqrt{5}$</td><td>\sqrt{5}</td></tr><tr><td>$\sqrt[3]{5}$</td><td>\sqrt[3]{5}</td></tr></tbody></table><h2 id="公式末尾序号"><a href="#公式末尾序号" class="headerlink" title="公式末尾序号"></a><span style="color:#EE0C4D">公式末尾序号</span></h2><ul><li>自动标签（不建议使用）：<code>\begin{equation}...\end{equation}</code></li><li>手动标签：<code>...\tag{...}</code></li></ul><h2 id="单个公式的连等换行"><a href="#单个公式的连等换行" class="headerlink" title="单个公式的连等换行"></a><span style="color:#EE0C4D">单个公式的连等换行</span></h2><p>对于单个公式换行（共用一个标签）的格式控制问题，如下</p><p>$$\begin{split}<br>y&amp;=x^2-4x+5\\<br>&amp;=(x^2-4x+4)+1\\<br>&amp;=(x-2)^2+1<br>\end{split}\tag{xx}$$</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;split&#125;</span><br><span class="line">y&amp;=x^2-4x+5\\\\</span><br><span class="line">&amp;=(x^2-4x+4)+1\\\\</span><br><span class="line">&amp;=(x-2)^2+1</span><br><span class="line">\end&#123;split&#125;\tag&#123;xx&#125;$$</span><br></pre></td></tr></table></figure></p><p>要点如下：</p><ol><li>公式代码用<code>begin{split}...\end{split}</code>标识以说明需要多行显示一个单行公式；</li><li><code>\tag{...}</code>需要放到<strong>split区域</strong>外面，因为它不属于公式代码；</li><li>换行的地方用<code>\\</code>标识，如果在windows系统下可能是<code>\\\\</code>；</li><li>在<strong>所有</strong>行中使用且<strong>仅</strong>使用<strong>一个</strong><code>&amp;</code>标明对齐位置。</li></ol><h2 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a><span style="color:#EE0C4D">分段函数</span></h2><p>代码：</p><pre>Sign(x)=\begin{cases}    1, & \text{if $x$ > 0;}\\\\    0, & \text{if $x$ = 0;}\\\\    -1, & \text{else}\end{cases}</pre><p>效果：<br>$$<br>Sign(x)=<br>\begin{cases}<br>    1, &amp; \text{if $x$ &gt; 0;}\\<br>    0, &amp; \text{if $x$ = 0;}\\<br>    -1, &amp; \text{else}<br>\end{cases}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 快捷清单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>估计量选择的原则</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180928-e722.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180928-e722.html</url>
      
        <content type="html"><![CDATA[<p>以点估计为例，我们可以通过矩估计法和最大似然估计法对总体的某个参数进行估计。我们通过不同的方法对同一个参数的估计结果可能不同，因此我们需要选择一个最好的估计量。<a id="more"></a></p><p>下面是选择估计量时常用的三个标准：</p><h1 id="无偏性"><a href="#无偏性" class="headerlink" title="无偏性"></a>无偏性</h1><h2 id="什么是无偏性？"><a href="#什么是无偏性？" class="headerlink" title="什么是无偏性？"></a>什么是无偏性？</h2><p>若${X_1,X_2,\cdots,X_n}$是总体的一个样本，样本容量为$n$，$\theta$是与总体分布相关的一个<strong>待估参数</strong>。</p><p>我们基于样本${X_1,X_2,\cdots,X_n}$构造了一个<strong>估计量</strong>$\hat{\theta}=\theta(X_1,X_2,\cdots,X_n)$，当这歌估计量的<strong>期望</strong>$E(\hat{\theta})$存在且$E(\hat{\theta})=\theta$时称$\hat{\theta}$是$\theta$的<strong>无偏估计量</strong>。</p><p>简而言之，估计量的期望等于待估参数就是无偏估计。</p><h2 id="无系统误差"><a href="#无系统误差" class="headerlink" title="无系统误差"></a>无系统误差</h2><p>无偏估计意味着没有<strong>系统误差</strong>，那么有偏估计就意味着有系统误差，而系统误差是可以通过<strong>校正</strong>去除的，所谓我们可以对有偏估计进行无偏化处理得到完成无偏估计，典型的例子就是方差估计。</p><h2 id="期望是无偏的"><a href="#期望是无偏的" class="headerlink" title="期望是无偏的"></a>期望是无偏的</h2><p>不论总体的分布形式如何，<strong>k阶样本矩</strong>（样本的k阶原点矩）$A_k=\frac1n\sum_{i=1}^{n}X_i^k$都是<strong>k阶总体矩</strong>（总体的k阶原点矩）$\mu_k$的<strong>无偏估计</strong>。只需证明$E(A_k)=\mu_k$即可。</p><blockquote><p>样本常见的数字特征有：样本均值、未修正样本方差、修正样本方差、样本k阶原点矩和样本k阶中心矩。</p></blockquote><p>这意味着：<strong>样本均值</strong>总是<strong>总体期望</strong>的无偏估计。</p><h2 id="方差是有偏的"><a href="#方差是有偏的" class="headerlink" title="方差是有偏的"></a>方差是有偏的</h2><p>对于方差存在的总体，用未修正的样本方差$\hat{\sigma}^2=\frac1n\sum_{i=1}^{n}(X_i-\bar{X})^2$来估计总体方差$\sigma^2$是<strong>有偏</strong>的。</p><div style="border:3px black solid;padding:5px"><strong>证明：</strong><br>针对样本，由$E(X^2)=[E(X)]^2+D(X)$知<br>$$\begin{split}<br>\hat{\sigma}^2=D(X)&amp;=E(X^2)-[E(X)]^2\\<br>&amp;=A_2-\bar{X}^2<br>\end{split}$$<br>因为<strong>期望是无偏的</strong>，所以<br>$$\underbrace{E(A_2)=}_{期望无偏}\mu_2\underbrace{=\sigma^2+\mu^2}_{总体期望和方差的关系}$$<br>上式中 $\mu_2$ 是总体的二阶原点矩，$\mu$ 是总体的一阶原点矩（期望）。<br>对于<strong>复合随机变量$\bar{X}^2$</strong>有<br>$$E(\bar{X}^2)=D(\bar{X})+[E(\bar{X})]^2=\frac{\sigma^2}n+\mu^2$$<br><div style="border:1px black solid;padding:5px"><strong>证明$D(\bar{X})=\frac{\sigma^2}n$</strong>:<br>$$\begin{split}<br>D(\bar{X})&amp;=D(\frac{X_1+X_2+\cdots+X_n}n)\\<br>&amp;=\frac1{n^2}D(X_1+X_2+\cdots+X_n)\\<br>&amp;=\frac1{n^2}[D(X_1)+D(X_2)+\cdots+D(X_n)]\\<br>&amp;=\frac1{n^2}(\underbrace{\sigma^2+\sigma^2+\cdots+\sigma^2}_{n个})\\<br>&amp;=\frac{n\sigma^2}{n^2}\\<br>&amp;=\frac{\sigma^2}n<br>\end{split}$$</div><br>所以<br>$$\begin{split}<br>E(\hat{\sigma}^2)&amp;=E(A_2-\bar{X}^2)\\<br>&amp;=E(A_2)-E(\bar{X}^2)\\<br>&amp;=(\sigma^2+\mu^2)-(\frac{\sigma^2}n+\mu^2)\\<br>&amp;=\frac{n-1}n\sigma^2\ne\sigma^2<br>\end{split}$$<br>即证<strong>非修正的</strong>样本方差$\hat{\sigma}^2$是总体方差的$\sigma^2$的有偏估计。</div><p>我们令<br>$$S^2=\frac{n}{n-1}\hat{\sigma}^2=\frac1{n-1}(X_i-\bar{X}^2)$$<br>此时有<br>$$E(S^2)=E(\frac{n}{n-1}\hat{\sigma}^2)=\frac{n}{n-1}E(\hat{\sigma}^2)=\sigma^2$$<br>即得<strong>修正的</strong>样本方差$S^2$是总体方差的$\sigma^2$的无偏估计。</p><p>这就是为什么样本方差为什么总是除以n-1而不是n的原因~</p><hr><h1 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h1><p>当我们通过<strong>无偏性</strong>判断出多个无偏估计量$\hat{\theta_1}$、$\hat{\theta_2}$、…时我们需要进一步筛选。</p><p>由于无偏估计量的期望总是待估参数，因此方差越小越好</p><p>$$\hat{\theta_{opt}}=\mathop{\arg\min}_{i=1,2,\cdots}\hat{\theta_i}$$</p><hr><h1 id="相合性"><a href="#相合性" class="headerlink" title="相合性"></a>相合性</h1><p><strong>相合性</strong>指的是当样本容量$n\to\infty$时$\hat{\theta}(X_1,X_2,\cdots,X_n)$<strong>依概率收敛于</strong>$\theta$。</p><p>相合性是估计量最基本的特性，估计量可以有偏但不能不依概率收敛。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参数估计-点估计</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180921-469f.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180921-469f.html</url>
      
        <content type="html"><![CDATA[<h1 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h1><p><strong>参数估计</strong>作为一个名词短语，实际含义指的是<span style="color:red">估计参数</span>，意为<span style="color:red">估计<i>总体分布</i>参数</span>。事实上我们能观测到的数据成为<strong>样本</strong>，所以<strong>参数估计</strong>的内容就是<span style="color:blue">通过样本对总体分布的某些指标/参数进行估计</span>。</p><p><strong>参数估计</strong>分为<strong>点估计</strong>和<strong>区间估计</strong>。</p><p>其中<strong>点估计</strong>主要包含<strong>矩估计</strong>、<strong>极大似然估计</strong>。<a id="more"></a></p><hr><h1 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h1><p>基于<strong>矩</strong>的概念对<strong>总体分布</strong>的<strong>均值μ</strong>和<strong>方差σ</strong>进行估计，总体分布的其他参数通过μ和σ进行推断。</p><p>我们不需要知道总体分布的分布形式就可以进行矩估计，但是当总体分布已知时矩估计却没有彻底利用已知信息，显然不是一种较好的估计方法。</p><h2 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h2><p>随机变量<strong>X</strong>的期望是<strong>E[X]</strong></p><blockquote><p>令k是自然数，a为任意实数：<br>期望$E[(X-a)^k]$称为<strong>随机变量X对<span style="color:green">实数a</span>的k阶<span style="color:green">中心</span>矩</strong>，<br>期望$E[X^k]$称为<strong>随机变量X的k阶<span style="color:green">原点</span>矩</strong>。</p></blockquote><h2 id="矩估计-1"><a href="#矩估计-1" class="headerlink" title="矩估计"></a>矩估计</h2><p>矩估计基于<strong>总体的k阶矩等于样本的k阶矩</strong>，即<strong>假设样本的期望和方差与总体的期望与方差相同</strong>。</p><p>为什么呢？这里引用一个不加证明的专业说法：</p><blockquote><p>样本的k阶原点矩$\frac{1}{n}\sum_{i=1}^nX_i^k$<span style="color:red">依概率收敛于</span>总体的k阶原点矩$\mu_k$<br>同理，样本矩的连续函数也将依概率收敛于总体矩的连续函数</p></blockquote><p>什么叫<strong>依概率收敛</strong>？</p><blockquote><p>$X_n$依概率收敛于$X$，记做$X_n\xrightarrow{P}X$，表示：对$\forall\epsilon&gt;0$，当$n{\rightarrow}{\infty}$时，$P(|X_n-X|\leqslant\epsilon)\rightarrow1$。</p></blockquote><p>定义式如下：</p><table><thead><tr><th></th><th>样本</th><th>总体</th></tr></thead><tbody><tr><td>对$\overline{X}$的k阶中心矩</td><td>$\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k$</td><td>$E[(X-E[X])^k]$</td></tr><tr><td>k阶原点矩</td><td>$\frac{1}{n}\sum_{i=1}^nX_i^k$</td><td>$E[X^k]$</td></tr></tbody></table><p>基于<strong>一阶样本原点矩</strong>推测<strong>总体期望</strong>：</p><p>$$EX=E[X]\approx\frac{1}{n}\sum_{i=1}^{n}X_i=\overline{X}$$</p><p>基于<strong>二阶样本中心矩</strong>推测<strong>总体方差</strong>：</p><p>$$DX=D[X]\approx\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2$$</p><p>通过上式我们发现，因为在估计期望和方差的过程中并未涉及到总体分布的形式，因此上述估计式实际上是通用的。</p><hr><h1 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h1><p>使用极大似然估计，总体的分布形式一定要已知，不然没法进行计算。</p><p>极大似然估计基于<strong>极大似然原理</strong>：概率更大的事件在一次观测中更容易出现。</p><p>因此，我们求的是<strong>使当前样本出现概率最大</strong>的那组参数。</p><p>我们要想求出这个/这组参数，就必须先构建一个/一组方程。</p><p>通常这个/这组方程由某个<strong>函数求导/求偏导</strong>得出，这个函数就叫做<strong>似然函数</strong>，常记做 $L(\theta)$。</p><h2 id="构造似然函数"><a href="#构造似然函数" class="headerlink" title="构造似然函数"></a>构造似然函数</h2><p>1.离散型随机变量：$P(X=x)=p(x;\theta)$</p><p>联合概率 $ L(\theta)=\prod_{i=1}^{n}(x_i;\theta)=p(x_1;\theta)p(x_2;\theta){\cdots}p(x_n;\theta) $</p><p>2.连续性随机变量：$P(X=x)=\int_{-\infty}^{x}f(t;\theta)dt$</p><p>联合概率密度 $ L(\theta)=\prod_{i=1}^{n}f(x_i;\theta)=f(x_1;\theta)f(x_2;\theta){\cdots}f(x_n;\theta) $</p><h2 id="求解似然函数"><a href="#求解似然函数" class="headerlink" title="求解似然函数"></a>求解似然函数</h2><p>取对数 -&gt; 求导/求偏导 -&gt; 求解得到<strong>驻点</strong></p><p>对于一般属于<strong>指数分布族</strong>的分布形式（正态分布、泊松分布、伯努利分布…），令导函数为0的点（<strong>驻点</strong>）一般都是极值点，但是也有奇葩特例。</p><hr><h1 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h1><p>这里只简述贝叶斯估计的思想。</p><p>最大似然估计将参数θ看做一个<strong>确定变量</strong>，而贝叶斯估计将参数θ看做一个服从一定先验分布的<strong>随机变量</strong>。</p><p>我们期望通过p(x|θ)求出后验概率p(θ|x)，同时p(θ|x)在真实的θ处有一个<strong>峰</strong>，于是乎我们就求得了真正的θ，耶耶耶</p><p>搬运个更加直观的图：</p><p><img src="https://img-blog.csdn.net/20170606223618992" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCAS生物统计与实验设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编程思想-闭包</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180912-a712.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180912-a712.html</url>
      
        <content type="html"><![CDATA[<p><strong>什么是闭包（Closure）？</strong></p><p>先看看wiki百科是怎么解释的：</p><blockquote><p>In programming languages, a closure(also lexical closure or function closure) is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function together with an environment. The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created. A closure (unlike a plain function) allows the function to access those captured variables through the closure’s copies of their values or references, even when the function is invoked outside their scope.</p></blockquote><p>之我见：我们一般说起将<strong>属性</strong>和<strong>方法</strong>进行封装就会想到<strong>类</strong>。<strong>闭包</strong>的作用类似于<strong>类</strong>，只是它的<strong>专能性</strong>似乎更强。<a id="more"></a></p><p>用栗子来解释<strong>闭包</strong>为什么会和<strong>类</strong>相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closure_def</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line">    z = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">        print((x+y)*z)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>对于上面这个简单的栗子，我们发现以下几个特点：</p><ol><li><code>y</code> 和 <code>z</code> 是函数 <code>closure_def</code> 作用域下的<strong>局部变量</strong></li><li>函数 <code>fn</code> 定义在 函数 <code>closure_def</code> 的内部，同时它将直接调用 <code>y</code> 和 <code>z</code> </li><li>函数 <code>closure_def</code>返回的是函数 <code>fn</code> 的引用</li></ol><p>我们获取一个<strong>闭包</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">closure_1 = closure_def(<span class="number">4</span>)</span><br><span class="line">closure_1()</span><br><span class="line"><span class="comment">#输出结果为 10</span></span><br></pre></td></tr></table></figure><p>上述的 <code>closure_1</code> 就是传说中的<strong>闭包</strong>。因此，<strong>闭包本质上还是一个函数</strong>,我们通过 <code>closure_1()</code> 调用这个函数后将会输出结果10.</p><p>其实到这里我还是没弄清楚<strong>闭包</strong>与<strong>类</strong>到底相似在哪里。但是，这里有个很有意思的东西：我们通过 <code>closure_def(4)</code> 调用了闭包定义函数后，该函数内的局部变量（<code>y</code>和<code>z</code>)应该就失效了，但是函数<code>fn</code>实际上却被我们保存了下来（在<code>closure_1</code>中)。然而，这个<code>closure_1</code>需要使用<code>y</code>和<code>z</code>，按照我们前面的逻辑，这两个变量已经失效了，这就产生了一个十分尴尬的问题。</p><p>真实情况并非这样，<code>y</code>和<code>z</code>变量明显还存在于内存中，并且它们与这个<code>fn</code>函数绑定在一起了。这就是闭包的特性：将<code>y</code>和<code>z</code>这两个变量和函数<code>fn</code>绑定在一起，就好比<strong>类</strong>中将<strong>属性</strong>与<strong>方法</strong>绑定一样。</p><p>在python中，<strong>函数</strong>同基本数据类型一样同属于<strong>一级类对象</strong>，函数名就是这个一级类实例的引用。对于闭包，函数需要用到的变量值实际上存在于其中，我们可以这样访问这些变量：</p><ul><li><code>.__closure__</code> 返回一组存有变量值的cell对象</li><li><code>.__closure__[0].cell_centents</code> 将获取相应变量的值</li></ul><p>从上面我们发现，闭包就是将<strong>一组</strong>变量和<strong>一个</strong>函数进行封装，如下所示：</p><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/blogImgs/20180912182056.png" alt=""></p><p>我们保存的只有<span style="color:blue">蓝色框框</span>部分，但是<span style="color:blue">蓝色框框</span>需要使用<span style="color:red">红色框框</span>内的变量，闭包就将这两个框框进行封装。<span style="color:orange">橙色框框</span>返回闭包中的那个主函数。</p><p>而且，<strong>当我们只是对一个函数进行简单的封装（修饰）时，使用闭包将更加优雅</strong>。</p><p>闭包的一个重要应用就是python的装饰器（Decorator），且等下回之我见。</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫-网页解析工具-BeautifulSoup包API速查</title>
      <link href="/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20180911-ef0f.html"/>
      <url>/%E5%BF%AB%E6%8D%B7%E6%B8%85%E5%8D%95/20180911-ef0f.html</url>
      
        <content type="html"><![CDATA[<p>强大的网页解析工具！<a id="more"></a></p><h1 id="创建、查看"><a href="#创建、查看" class="headerlink" title="创建、查看"></a>创建、查看</h1><p>导入<strong>BeautifulSoup</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><p>创建<strong>BeautifulSoup对象</strong>：</p><p>1.传入<strong>字符串</strong>: html是源代码文本字符串。如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">html = requests.get(URL, headers=HEADERS, cookies=COOKIES).text</span><br><span class="line">bsobj = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><p>2.传入<strong>本地文件对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsobj = BeautifulSoup(open(LOCAL_FILE))</span><br></pre></td></tr></table></figure><p>格式化打印<strong>BeautifulSoup对象</strong>内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( bsobj.prettify() )</span><br></pre></td></tr></table></figure><hr><p><br></p><h1 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h1><ul><li><code>bs4.element.Tag</code>: 标签，具有 <code>name</code> 属性（标签名）和 <code>attrs</code>属性 （标签的属性字典）：如 <code>bsobj.title</code> 或者下文的 <code>SOME_TAG</code>;</li><li><code>bs4.element.NavigableString</code>: 标签内的字符串，通过 <code>SOME_TAG.string</code> 访问；</li><li><code>bs4.BeautifulSoup</code>: BeautifulSoup对象，即<code>bsobj</code>，相当于内容是<strong>html</strong>标签的一个tag，<code>name</code>值为<code>[document]</code>;</li><li><code>bs4.element.Comment</code>: 注释掉的内容，容易与<strong>NavigableString</strong>混淆</li></ul><hr><p><br></p><h1 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h1><p><br></p><h2 id="1-标签对象的属性"><a href="#1-标签对象的属性" class="headerlink" title="1.标签对象的属性"></a>1.标签对象的属性</h2><p>遍历标签的直接子节点，返回列表：<code>SOME_TAG.contents</code></p><p>遍历标签的直接子节点，返回<strong>listiterator对象</strong>：<code>SOME_TAG.children</code></p><p>遍历标签的所有子孙节点，返回<strong>listiterator对象</strong>：<code>SOME_TAG.descendants</code></p><p>标签内的字符串<strong>只有一个时</strong>获取这个字符串：<code>SOME_TAG.string</code></p><p>标签内的字符串<strong>有很多个时</strong>获取这些字符串：<code>SOME_TAG.strings</code></p><p>标签内的字符串<strong>有很多个时</strong>获取这些字符串并去掉其中的空白部分：<code>SOME_TAG.striped_strings</code></p><p>父节点(还是一个tag对象)：<code>SOME_TAG.parent</code></p><p>全部父节点，返回<strong>generator</strong>：<code>SOME_TAG.parents</code></p><p>兄弟节点：<code>SOME_TAG.previous_sibling</code> 或 <code>SOME_TAG.next_sibling</code></p><p>全部兄弟节点：<code>SOME_TAG.previous_siblings</code> 或 <code>SOME_TAG.next_siblings</code></p><p>前后节点：<code>SOME_TAG.previous_element</code> 或 <code>SOME_TAG.next_element</code></p><p>全部前后节点：<code>SOME_TAG.previous_elements</code> 或 <code>SOME_TAG.next_elements</code></p><p><br></p><h2 id="2-标签对象的方法"><a href="#2-标签对象的方法" class="headerlink" title="2.标签对象的方法"></a>2.标签对象的方法</h2><h3 id="1-find簇方法"><a href="#1-find簇方法" class="headerlink" title="(1) find簇方法"></a>(1) find簇方法</h3><h4 id="find-all-name-attrs-recursive-text-kwargs"><a href="#find-all-name-attrs-recursive-text-kwargs" class="headerlink" title="find_all( name , attrs , recursive , text , **kwargs )"></a><span style="color:red">find_all( name , attrs , recursive , text , **kwargs )</span></h4><p>在<strong>直接子节点/所有子孙节点</strong>中搜索，返回一个tag对象的列表</p><p>● 形参<strong>name</strong>限制搜索的html标签范围<br>可以是：</p><ul><li>直接指定标签，如 <code>name=&#39;title&#39;</code>限制为title标签；</li><li>正则表达式，如 <code>name=re.compile(r&#39;^b&#39;)</code> 限制为所有以b开头的标签;</li><li>标签的列表，如 <code>name=[&#39;a&#39;,&#39;p&#39;]</code>限制为a标签和p标签；</li><li>布尔值True，<code>name=True</code>将返回所有<strong>子孙</strong>标签；</li><li>一个<strong>特定规则的函数</strong>：形参为<strong>SOME_TAG</strong>，返回布尔值，如下：</li></ul><p>这个函数接受一个SOME_TAG，判断它是否具有class属性并且没有id属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_class_but_no_id</span><span class="params">(tag)</span>:</span></span><br><span class="line"><span class="keyword">return</span> tag.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure></p><p>● 形参<strong>attrs</strong>对name限定的标签进行属性上的过滤</p><p>实际上为一个<strong>html属性字典</strong>，如 <code>attrs={&#39;class&#39;:&#39;goodslist&#39;, &#39;id&#39;: &#39;gold&#39;}</code></p><p>● 形参<strong>recursive</strong>为布尔值</p><p>True（默认）表示搜索<strong>子孙节点</strong>，False表示只搜索<strong>直接子节点</strong></p><p>● 形参<strong>text</strong>对标签内的字符串内容进行限制以达到过滤目的</p><p>与形参<strong>name</strong>相似，可以传入字符串、正则表达式、字符串列表、布尔值、特定规则的函数</p><p><strong>NavigableString</strong>和<strong>Comment</strong>都在text参数过滤的范围内</p><p>● <strong>kwargs</strong>中常用关键字参数</p><ol><li><strong>非内置的过滤形参</strong>会被解析为属性值过滤行为</li></ol><p>上面的<code>attrs={&#39;class&#39;:&#39;goodslist&#39;, &#39;id&#39;: &#39;gold&#39;}</code>还可以写做 <code>class_=&#39;goodslist&#39;, id=&#39;gold&#39;</code></p><p>并不是所有html属性都可以这样写的，比如 <code>data-*</code> 属性，因为不符合python变量命名规范</p><p>我觉得还是用attrs字典比较靠谱！！！</p><ol start="2"><li><strong>limit</strong>关键字限制搜索结果的数量，当达到指定数量时即停止搜索，避免在文档树十分庞大时拖慢程序速度</li></ol><h4 id="find-name-attrs-recursive-text-kwargs"><a href="#find-name-attrs-recursive-text-kwargs" class="headerlink" title="find( name , attrs , recursive , text , **kwargs )"></a><span style="color:red">find( name , attrs , recursive , text , **kwargs )</span></h4><p>在<strong>直接子节点/所有子孙节点</strong>中搜索，只返回找到的第一个结果</p><h4 id="find-parents-…-or-find-parent-…"><a href="#find-parents-…-or-find-parent-…" class="headerlink" title="find_parents(…) or find_parent(…)"></a><span style="color:red">find_parents(…)</span> or <span style="color:red">find_parent(…)</span></h4><p>通过 <code>.parents</code> 或者 <code>.parent</code> 对<strong>父节点</strong>进行遍历</p><h4 id="find-previous-siblings-…-or-find-previous-sibling-…"><a href="#find-previous-siblings-…-or-find-previous-sibling-…" class="headerlink" title="find_previous_siblings(…) or find_previous_sibling(…)"></a><span style="color:red">find_previous_siblings(…)</span> or <span style="color:red">find_previous_sibling(…)</span></h4><p>通过 <code>.previous_siblings</code> 或者 <code>.previous_sibling</code> 对<strong>前文兄弟节点</strong>进行遍历</p><h4 id="find-next-siblings-…-or-find-next-sibling-…"><a href="#find-next-siblings-…-or-find-next-sibling-…" class="headerlink" title="find_next_siblings(…) or find_next_sibling(…)"></a><span style="color:red">find_next_siblings(…)</span> or <span style="color:red">find_next_sibling(…)</span></h4><p>通过 <code>.next_siblings</code> 或者 <code>.next_sibling</code> 对<strong>后文兄弟节点</strong>进行遍历</p><h4 id="find-all-previous-…-or-find-previous-…"><a href="#find-all-previous-…-or-find-previous-…" class="headerlink" title="find_all_previous(…) or find_previous(…)"></a><span style="color:red">find_all_previous(…)</span> or <span style="color:red">find_previous(…)</span></h4><p>通过 <code>.previous_elements</code> 或者 <code>.previous_element</code> 对<strong>前文所有节点</strong>进行遍历</p><h4 id="find-all-next-…-or-find-next-…"><a href="#find-all-next-…-or-find-next-…" class="headerlink" title="find_all_next(…) or find_next(…)"></a><span style="color:red">find_all_next(…)</span> or <span style="color:red">find_next(…)</span></h4><p>通过 <code>.next_elements</code> 或者 <code>.next_element</code> 对<strong>所有后文节点</strong>进行遍历</p><h3 id="2-select方法"><a href="#2-select方法" class="headerlink" title="(2) select方法"></a>(2) select方法</h3><p>遵循CSS标签选择器的语法规则</p><p>select方法通过一定的规则构造查询字符串，而find类方法则是通过关键字参数传入信息</p><ul><li>通过<strong>标签名</strong>查找，返回tag列表，如 <code>SOME_TAG.select(&#39;title&#39;)</code></li><li>通过<strong>class名</strong>查找，返回tag列表，如 <code>SOME_TAG.select(&#39;.goodslist&#39;)</code></li><li>通过<strong>id名</strong>查找，返回tag列表，如 <code>SOME_TAG.select(&#39;#gold&#39;)</code></li></ul><p>上述基本规则可以进行组合：</p><ul><li>满足标签从属关系的查找(使用<code>&gt;</code>)：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOME_TAG.select(<span class="string">'head &gt; title'</span>)</span><br></pre></td></tr></table></figure><ul><li>标签、类名、id名联合查找(1)：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOME_TAG.select(<span class="string">'table .goodslist #gold'</span>)</span><br></pre></td></tr></table></figure><ul><li>标签、类名、id名联合查找(2)：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOME_TAG.select(<span class="string">'table[class="goodslist",id="gold"]'</span>)</span><br></pre></td></tr></table></figure><ul><li>标签从属、类名、id名联合查找：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOME_TAG.select(<span class="string">'div[class="containor"] &gt; table[id="gold"]'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 快捷清单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数-逆矩阵的存在条件</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180815-dbe6.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180815-dbe6.html</url>
      
        <content type="html"><![CDATA[<p>我们现在要求解一个线性方程组：</p><p>$$ A{\cdot}x=b $$</p><p>其中$A{\in}R^{m{\times}n}$是一个<strong>已知</strong>矩阵，$x{\in}R^{n{\times}1}$是一个n维<strong>未知</strong>列向量，$b{\in}R^{m{\times}1}$是一个m维<strong>已知</strong>列向量。<a id="more"></a></p><p>按照<strong>矩阵×向量</strong>的定义，A中的每一行和b中的每一个对应元素形成约束，即b中对应元素都是由A中对应行向量和x运算（內积）而来。</p><p>上式的本质还是 $ A_{i,:}{\cdot}x=b_i $</p><p>定义<strong>单位矩阵</strong>$I_n{\in}R^{n{\times}n}$使得对任意的$x{\in}R^n$都有</p><p>$$ I_n{\cdot}x=x $$</p><p>定义<strong>逆矩阵</strong>$A^{-1}$:</p><p>$$ A^{-1}{\cdot}A=I_n $$</p><p>这样就可以得到$A{\cdot}x=b$的解为：</p><p>$$ x=A^{-1}{\cdot}b $$</p><p>那么重点来了，我们怎么求定义的$A^{-1}$？换句话说，$A^{-1}$什么时候存在？（毕竟如果不存在我们期望的这个$A^{-1}$的话怎么求都是徒劳的）因此我们需要对$A^{-1}$的存在条件进行分析。</p><h1 id="A-1-的存在条件分析"><a href="#A-1-的存在条件分析" class="headerlink" title="$A^{-1}$的存在条件分析"></a>$A^{-1}$的存在条件分析</h1><p>对于方程组$A{\cdot}x=b$，如果$A^{-1}$存在，那么$x$具有唯一解且这个解为$x=A^{-1}{\cdot}b$。</p><p>但是我们的b向量是在$R^m$空间任意取的，对于某些b向量实际实际上<strong>可能不存在解</strong>，而对另一些b向量则<strong>可能存在无穷多的解</strong>。那么是否存在一些$b$向量使得x存在<strong>不止一个但是又是有限个解</strong>呢？答案是不存在的，因为假设向量$x_1$和向量$x_2$是方程组$A{\cdot}x=b$的解，那么向量${\alpha}{\cdot}x_1+(1-{\alpha}){\cdot}x_2$（$\alpha$是任意实数）一定是方程组$A{\cdot}x=b$的解！</p><h2 id="与点的运动关联"><a href="#与点的运动关联" class="headerlink" title="与点的运动关联"></a>与点的运动关联</h2><p>从<strong>空间路径</strong>的角度考虑方程组的解的可能个数：</p><p>$A{\in}R^{m{\times}n}$，即A是一个m行n列的矩阵，A的列向量都是$R^m$空间里的向量，向量b也是$R^m$空间里的一个向量。</p><p>我们可以这样想，现在有一个$R^m$空间，它应该有m个坐标轴（直角坐标系），A的每一个列向量在这个坐标系里面实际上都指明了一个方向。</p><p>下图是一个例子：</p><p>$$<br>\begin{pmatrix}A_{1,1} &amp; … &amp; A_{1,n} \\ … &amp; … &amp; … \\ A_{m,1} &amp; … &amp; A_{m,n} \\ \end{pmatrix}<br>{\cdot}<br>\begin{pmatrix}x_1 \\ … \\ x_n \\ \end{pmatrix}<br>=\begin{pmatrix}b_1 \\ … \\ b_m \\ \end{pmatrix}<br>$$</p><p>注意</p><p>$$<br>\begin{pmatrix}b_1 \\ … \\ b_m \\ \end{pmatrix}=<br>\begin{pmatrix}<br>    A_{1,1}{\cdot}x_1+…+A_{1,n}{\cdot}x_n \\<br>    … \\<br>    A_{m,1}{\cdot}x_1+…+A_{m,n}{\cdot}x_n \\<br>\end{pmatrix}=<br>x_1{\cdot}\begin{pmatrix}A_{1,1} \\ … \\ A_{m,1} \\ \end{pmatrix}+…+<br>x_n{\cdot}\begin{pmatrix}A_{1,n} \\ … \\ A_{m,n} \\ \end{pmatrix}<br>$$</p><p>其中A的某个行向量$A_{i,:}$将控制向量b的某个分量$b_i$，而A的列向量$A_{:,j}$的对应分量将分别影响向量b的分量$b_j$（这里的<strong>M影响N</strong>意味着M是N的一部分，<strong>M决定N</strong>表示在其他因素不变的情况下N完全可以由M推导出来！）。有趣的是，A的列向量在影响向量b的分量时都是乘以了某一个常数（x对应的分量），这可以看做是<strong>对A的列向量在其本来的方向上进行缩放</strong>。</p><p>根据上面这种解释，A的所有列向量对b的影响的<strong>和</strong>（与x的內积）实际上就决定了向量b，即等效完成了A的行向量对向量b分量的控制过程。</p><p>上面提到，我们在$R_m$空间里建立了直角坐标系，A的所有列向量和向量b也位于这个空间中。从<strong>空间轨迹</strong>角度我们可以这样思考：</p><p><strong>O</strong>是$R_m$空间直角坐标系的原点，它首先沿着$A_{:,1}$列向量所指方向运动，运动距离是$x_1{\cdot}|A_{:,1}|$，然后沿着$A_{:,2}$列向量所指方向运动……以此类推，最终到达了向量b表示的<strong>B</strong>点。</p><p>换个角度看，上述过程实际上就是在对A的列向量进行<strong>线性组合</strong>，使之结果等价于b。</p><h2 id="关于A的形式讨论"><a href="#关于A的形式讨论" class="headerlink" title="关于A的形式讨论"></a>关于A的形式讨论</h2><p>在这里我们发现可以对A进行一些特殊处理，我们让A的列向量仅仅表示方向而不参与点的运动距离计算，距离计算将仅仅依赖于x的分量值，因此我们对A的列向量<strong>单位化</strong>（使其<strong>模</strong>为1），当然这不是必须的。</p><p>我们对A的一些可能情况进行讨论：假设我们将A的n个列向量沿$R_m$空间的坐标轴进行正交分解</p><ol><li><p>当n&lt;m时（即列向量个数少于列向量的维度数，A的列数少于行数，A是<strong>瘦矩阵</strong>）：我们只知道一维空间最少只需要一个非零向量就可以通过线性变换覆盖整个空间，二维平面最少需要两个<strong>线性无关</strong>的向量才能通过线性组合覆盖整个平面，三维空间至少需要三个<strong>线性无关</strong>的向量才能通过线性组合覆盖整个三维空间。A最多也就只能有n个线性无关的列向量，因此A的列向量的<strong>生成子空间</strong>根本不可能覆盖整个$R_m$空间，结果就是，对于那些在A列向量生成子空间外的向量b，没有办法通过对A的列向量进行线性组合来等效。<block style="color:red">结论：A列向量的<strong>生成子空间的有效维度</strong>少于A列向量的维度时，对于部分向量b，x无解。</block></p></li><li><p>当n=m时（即列向量的个数等于列向量的维度数，A的列数等于行数，A是<strong>方阵</strong>）：从第一点我们可以推断，当且仅当A的列向量线性无关时其列向量的<strong>生成子空间</strong>才能覆盖A的<strong>列向量空间</strong>，此时对于任意的$b{\in}R^{m{\times}1}$都能够找到一组x使得原点运动到<strong>B</strong>点。<block style="color:red">结论：A列向量的<strong>生成子空间的有效维度</strong>等于A列向量的维度时，对于任意的$b{\in}R^{m{\times}1}$都有唯一的x解。</block></p></li><li><p>当n&gt;m时（即列向量的个数大于列向量的维度数，A的列数等于行数，A是<strong>胖矩阵</strong>）：注意A的列向量在$R_m$空间中，所以这一组n个列向量中只能找到一组或多组不超过m个列向量的向量组线性无关，剩余列向量一定能被这组里的部分列向量所表示。有了这些列向量的参与，分解方式瞬间变为无数种，如下图(${\alpha}{\in}(0,180^{\circ})$)：</p></li></ol><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/math/2018-08-15_150357.png" alt=""></p><h2 id="唯一解问题"><a href="#唯一解问题" class="headerlink" title="唯一解问题"></a>唯一解问题</h2><p>因为我们定义的$A^{-1}$（如果存在）是通过A唯一确定的，基于$A^{-1}$我们求得的$x=A^{-1}{\cdot}b$也应是唯一解。</p><p>这就是说，当x有唯一解时我们就可以找到这样一个$A^{-1}$。</p><p>从上面的讨论中我们可以知道，当且仅当A的列向量的个数等于列向量的维度且线性无关时，即<strong>A是方阵</strong>且<strong>A的列向量线性无关</strong>时，x将有唯一解。</p><p>于是乎我们得到结论：只有矩阵A是方阵且列向量线性无关时才存在$A^{-1}$。</p><p><strong>奇异矩阵（方阵）</strong>：Singular Matrix，列向量相关的方阵</p><p>于是乎，只有<strong>非奇异矩（方）阵</strong>才存在$A^{-1}$。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-排序-鸡尾酒排序</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180814-6125.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180814-6125.html</url>
      
        <content type="html"><![CDATA[<p>鸡尾酒排序本质上就是<strong>双向冒泡排序</strong>。<a id="more"></a></p><hr><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>元素分为<strong>已经排序</strong>的元素和<strong>待排序</strong>的元素，每轮排序之增加一个<strong>已经排序的元素</strong>。</p><p>每轮排序都要从数组中<strong>待排序</strong>的那一端进行相邻元素的逐个比较，比较的结果是<strong>减少一个待排序元素</strong>，因此最多的比较次数将会是 (n-1)+…+1, 时间复杂度为 o(n^2)。</p><p>对于大部分有序的数组将会产生大量没有必要的比较，即当一轮比较不产生交换时说明已经全部有序，因此需要设置一个变量标识是否全部有序及时退出循环。</p><hr><h1 id="鸡尾酒排序（Cocktail-Sort）"><a href="#鸡尾酒排序（Cocktail-Sort）" class="headerlink" title="鸡尾酒排序（Cocktail Sort）"></a>鸡尾酒排序（Cocktail Sort）</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/its/jiweijiu-sort.gif" alt=""></p><p>经典的冒泡排序实际上是单向的，而鸡尾酒排序是双向的。</p><p>但是，在鸡尾酒排序中每一轮只能在待排序元素中确定一个最大值或者最小值，在最坏情况下它并不能减少比较次数，<strong>它的时间复杂度和空间复杂度与经典的冒泡算法相同</strong>，只是在大部分有序时可能少于经典冒泡排序的比较次数。</p><p>在大部分元素无序时两种排序半斤八两。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络基础-TCP数据包结构及TCP建立连接时的三次握手</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20180814-5f47.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20180814-5f47.html</url>
      
        <content type="html"><![CDATA[<p>三次握手，礼尚往来！<a id="more"></a></p><h1 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h1><p>Socket意为“插座”，可以说这是一个十分形象的比喻了，更专业的称呼叫“<strong>套接字</strong>”。网络上的两个程序（一般位于两台机器上）需要进行通讯，就必须在它们之间建立一个<strong>双向通信通道</strong>：一端连接服务器Server，一端连接者客户端Client。但是与一台Server（或者Client）进行通信的网络程序可能不止一个，它们怎么区分开呢？答案是通过<strong>端口</strong>（port）进行区分：不同的端口事实上会绑定不同的服务，与该主机的通讯实际上是通过某个特定的端口与该主机进行数据交流。端口就像主机身上的插孔，供外界取用信息。<strong>ip:port</strong>的格式就称之为一个<strong>套接字</strong>。显然，连接两个网络程序的这个双向通信通道需要有两个套接字：一个连接Client，一个连接Server。</p><h1 id="TCP数据包结构"><a href="#TCP数据包结构" class="headerlink" title="TCP数据包结构"></a>TCP数据包结构</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/its/tcp-data-package-construct.png" alt=""></p><p><strong>源始端口</strong>：16位，发送数据包的端口，取值 0 ~ 65535</p><p><strong>目的端口</strong>：16位，接受数据包的端口，取值 0 ~ 65535</p><p><strong>数据序号</strong>（Seq）：32位，数据包发送端指定的序号（可能是随机产生的）</p><p><strong>确认序号</strong>（Ack）：32位，数据包发送端指定的序号</p><ul><li>如果是第一次提出连接请求，例如Client请求连接Server，Seq可以随机产生，由于标志位A为0所以Ack值无效</li><li>如上，如果是Server回应Client的连接请求，当前数据包的Seq可以随机产生，Ack值必须是上述Seq值加1</li></ul><p><strong>UAPRSF</strong>：六个标志位，共6位</p><ol><li>U：URG，urgent，为1时表示 <em>紧急指针有效</em></li><li>A：ACK，acknowledge，为1时表示 <em>确认序号（Ack）有效</em></li><li>P：PSH，为1时表示 <em>接受端在接收到数据包后应该优先处理交付应用端</em></li><li>R：RST，reset，为1时表示 <em>TCP连接出现严重问题需要释放当前连接创建新的连接</em></li><li>S：SYN，synchronous，为1时表示 <em>当前数据包是一个与建立连接有关的数据包（请求或接受）</em></li><li>F：FIN，finish，为1时表示 <em>当前数据包已是发送端的最后一个数据包，连接需要关闭</em></li></ol><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p><img src="https://barwe-blog.oss-cn-shenzhen.aliyuncs.com/its/three-handshaking.jpg" alt=""></p><ol><li>客户端调用 <code>socket()</code> 函数创建套接字，客户端连接处于 <strong>CLOSED</strong> 状态。</li><li>服务器调用 <code>listen()</code> 函数使服务器端的套接字进入 <strong>LISTEN</strong> 状态：监听客户端的请求。</li><li>客户端调用 <code>connect()</code> 函数构建数据包：请求连接服务器。<ul><li>这个数据包的 SYN=1，ACK=0：SYN为1表示当前数据包为一个有关建立连接的数据包，ACK为0表示该数据包的作用是<strong>客户端请求连接服务器</strong>。</li><li>这个数据包的 Seq 由客户端产生，用于标识当前数据包的序号。</li><li>发送 <em>请求连接</em> 数据包后客户端进入 <strong>SYN-SEND</strong> 状态：连接请求已发送。</li></ul></li><li>服务器收到 SYN=1, ACK=0 的数据包，判断这是客户端发来的连接请求。</li><li>服务器构建表示 <em>接受连接</em> 的数据包：<ul><li>这个数据包的 SYN=1，ACK=1：当前数据包是一个关于建立连接的数据包，ACK有效意为着这是一个<strong>回应性的</strong>数据包，即<strong>接受客户端的连接请求</strong>。</li><li>这个数据包的 Seq 由服务器生成。</li><li>这个数据包的ACK=1意味着<strong>确认序号</strong>有效，这个确认序号应该为 <em>收到的客户端的请求性的数据包的数据序号加1</em>。</li><li>发送 <em>接受连接</em> 的数据包之后服务器进入 <strong>SYN-RECV</strong> 状态：连接已接受。</li></ul></li><li>客户端收到 SYN=1，ACK=1 的数据包，判断这是某个服务器发来的接受自己连接的数据包。</li><li>客户端检查这个数据包的<strong>确认序号</strong>是否是自己请求连接数据包的<strong>数据序号</strong>加1，如果是，则客户端构建 <em>确认</em> 数据包：确认收到服务器接受了连接这一条消息：<ul><li>这个数据包的 ACK=1：客户端需要最后向服务器发送确认消息因此需要设置ACK=1.</li><li>这个数据包的 <strong>确认序号</strong> 值为服务器发来的 <em>接受连接</em> 数据包的 <strong>数据序号</strong>。</li><li>客户端进入 <strong>ESTABLISED</strong> 状态：通道客户端已就绪。</li></ul></li><li>服务器收到 ACK=1 的数据包，判断这是客户端发来的最后的确认包。</li><li>服务器检查这个数据包的 <strong>确认序号</strong>，检查是否为自己发送的 <em>接受请求</em> 数据包的 <strong>数据序号</strong> 加1，如果是则连接建立，服务器进入 <strong>ESTABLISED</strong> 状态：通道服务器端已就绪。</li><li>至此，通道两端都已就绪，下面就可以收发数据了。</li></ol><p>从上图我们可以发现，整个连接建立的过程一共需要发送三个数据包，即三次握手。</p><p>其中两个由客户端发送，分别表示“请求连接”和“通告服务器自己已知晓服务器接受了请求”；一个由服务器发送，表示“接受连接”。</p><p>三个数据包的区分通过SYN和ACK的组合来判定。</p><p>服务器只会收到两个数据包：一个ACK为0表示这是始发包，表示客户端的“请求连接”；一个ACK为1表示这是客户端的确认包。</p><p>客户端只会收到一个数据包：与建立连接有关的（SYN=1）、属于回应性（ACK=1）的数据包。</p>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python读取json文件时书写的语法差异</title>
      <link href="/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95/20180809-575c.html"/>
      <url>/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95/20180809-575c.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用json文件作为配置文件时如果涉及到列表（list）类型，最后一个元素后面千万不能加逗号。"><a href="#使用json文件作为配置文件时如果涉及到列表（list）类型，最后一个元素后面千万不能加逗号。" class="headerlink" title="使用json文件作为配置文件时如果涉及到列表（list）类型，最后一个元素后面千万不能加逗号。 "></a><strong>使用json文件作为配置文件时如果涉及到列表（list）类型，最后一个元素后面千万不能加逗号。</strong> <a id="more"></a></h2><p>对于较多参数的程序我们可以通过命令行进行参数传入，也可以定义额外的配置文件。</p><p>这里我使用json格式的文件作为额外的配置文件。</p><h1 id="json-decoder-JSONDecodeError"><a href="#json-decoder-JSONDecodeError" class="headerlink" title="json.decoder.JSONDecodeError"></a>json.decoder.JSONDecodeError</h1><p>使用json文件作为配置文件时如果涉及到列表（list）类型，最后一个元素后面千万不能加逗号。</p><p>即 <code>[&quot;a&quot;]</code> 是正确的，<code>[&quot;a&quot;, ]</code> 是不正确的。这个规则适用于所有json文件。</p><p>加逗号将报错如下：</p><pre>Traceback (most recent call last):  File "<stdin>", line 1, in <module>  File "......\lib\json\__init__.py", line 268, in load    parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)  File "......\lib\json\__init__.py", line 319, in loads    return _default_decoder.decode(s)  File "......\lib\json\decoder.py", line 339, in decode    obj, end = self.raw_decode(s, idx=_w(s, 0).end())  File "......\lib\json\decoder.py", line 357, in raw_decode    raise JSONDecodeError("Expecting value", s, err.value) from Nonejson.decoder.JSONDecodeError: Expecting value: line 16 column 9 (char 491)</module></stdin></pre><p>其中 <code>raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None</code> 应该是指，json解析函数认为逗号后面应该还有元素，因此尝试去解析后面的元素，结果却什么也没得到，抛出 <code>json.decoder.JSONDecodeError</code> 错误，告诉你这里本该有值的（”Expecting value: …”）。模块作者有可能受到了其他语言习惯的影响？</p>]]></content>
      
      
      <categories>
          
          <category> 小黄鸭调试法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>warnings内建模块</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180730-5f87.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180730-5f87.html</url>
      
        <content type="html"><![CDATA[<p>不同于<strong>异常</strong>，不想影响到程序的正常执行，同时又想让使用者知道点什么</p><ul><li>使用警告：<code>warnings.warn(...)</code></li><li>忽略RuntimeWarning警告：<code>warnings.filterwarnings(action=&#39;ignore&#39;, category=RuntimeWarning)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之飘逸的format格式化字符串控制</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180730-ee75.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180730-ee75.html</url>
      
        <content type="html"><![CDATA[<p>标志性符号 <code>{:}</code> <a id="more"></a></p><h1 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h1><ol><li><p>通过<code>{}</code>内的<strong>索引</strong>取值</p><p> <code>&#39;{}-{}&#39;.format(111,222)</code> &lt;=&gt; ‘111-222’<br> <code>&#39;{0}-{1}&#39;.format(111,222)</code> &lt;=&gt; ‘111-222’<br> <code>&#39;{1}-{0}&#39;.format(111,222)</code> &lt;=&gt; ‘222-111’<br> <code>&#39;{0}-{1}-{0}&#39;.format(111,222)</code> &lt;=&gt; ‘111-222-111’</p></li></ol><ol><li><p>通过<code>{}</code>内的<strong>关键字</strong>取值</p><p> <code>&#39;{one}-{two}&#39;.format(one=111,two=222)</code> &lt;=&gt; ‘111-222’<br> <code>&#39;{two}-{one}&#39;.format(one=111,two=222)</code> &lt;=&gt; ‘222-111’</p></li><li><p>传入<strong>对象</strong></p><p> <code>&#39;{specific_obj.attr1}-{specific_obj.attr2}&#39;.format(specific_obj)</code></p></li><li><p>传入<strong>序列</strong>（元组，列表，…）</p><p> L = [111,222]<br> P = [333,444]</p><p> <code>&#39;{0[0]}-{0[1]}&#39;.format(L)</code> &lt;=&gt; ‘111-222’<br> <code>&#39;{0[1]}-{0[0]}&#39;.format(L)</code> &lt;=&gt; ‘222-111’</p><p> <code>&#39;{0[0]}-{1[1]}&#39;.format(L,P)</code> &lt;=&gt; ‘111-444’</p></li></ol><h1 id="格式控制-（借助于：）"><a href="#格式控制-（借助于：）" class="headerlink" title="格式控制 {:}（借助于：）"></a>格式控制 <code>{:}</code>（借助于<code>：</code>）</h1><ol><li><p><strong>填充</strong></p><p> <code>&#39;{:w&gt;8}&#39;.format(1314)</code> &lt;=&gt; ‘wwww1314’</p><blockquote><p>: 格式控制必须字符<br>w 是填充符，必须为单字符，可以不指定，默认为空格，例如 {:&gt;8}<br><span>&gt;</span> 左对齐，相应地’&lt;’为右对齐, ‘^’为居中对齐<br>8 域宽</p></blockquote></li><li><p><strong>浮点数精度</strong></p><p> <code>&#39;{:.2f}&#39;.format(1.2345)</code> &lt;=&gt; ‘1.23’</p><blockquote><p>.2 代表保留两位小数，而不是两位有效数字</p></blockquote><p> <code>&#39;{:.{}f}&#39;.format(1.2345, 3)</code> &lt;=&gt; ‘1.234’</p><blockquote><p>{}可以嵌套使用！！</p></blockquote><p> <code>&#39;{k:.2f}.format(1.2345)</code> &lt;=&gt; ‘1.23’</p><blockquote><p>配合关键字使用</p></blockquote></li><li><p><strong>进制转换</strong></p><p> <code>{:b}</code>: 二进制<br> <code>{:d}</code>: 十进制<br> <code>{:o}</code>: 八进制<br> <code>{:x}</code>: 十六进制</p></li><li><p><strong>数字分隔符</strong></p><p> <code>{:,}.format(1234567)</code> &lt;=&gt; ‘1,234,567’</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间内建模块</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180728-42ac.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180728-42ac.html</url>
      
        <content type="html"><![CDATA[<p>包括time, datetime, calendar, business_calendar, pytz, dateutil等等模块。<a id="more"></a></p><h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><p><code>ticks = time.time()</code> 返回一个表示当前时刻的浮点数，<strong>只能表示1970年到2038年</strong>。</p><p><code>struct_time = time.localtime(time.time())</code> 返回本地时间</p><ul><li>返回时间元组对象 <em>struct_time</em>，并不能自动转化为字符串</li><li>返回例如<pre>time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0)</pre></li><li><em>tm_wday</em> 表示一周的第几天</li><li><em>tm_yday</em> 表示一年的第几天</li><li><em>tm_isdst</em> 表示是否是夏令时</li></ul><p><code>time.asctime(struct_time)</code> 返回给定时间的字符串表示，只能传入时间元组而不是ticks</p><p><code>time.strftime(FORMAT, STRUCT_TIME)</code> 可以定制时间字符串格式</p><ul><li>时间格式化符号<ul><li>%y (两位数年份00-99)，%Y (四位数年份0000-9999)</li><li>%m (月份01-12)，%d (月中的第几天01-31)</li><li>%H (24小时制00-23)，%I (12小时制01-12)</li><li>%M (分钟数00-59)，%S (秒数00-59)</li><li>%w (周几0-6，0代表周日)，%a (本地简化星期名称，如Sat)，%A (本地完整星期名称，如Saturday)</li><li>%U (一年中的第几周00-53，周日始)，%W (一年中的第几周00-53，周一始)</li><li>%a (本地简化月份名称，如Jul)，%A (本地完整月份名称，如July)</li><li>%j (一年内的第几天001-366)</li><li>%p (值为AM或者PM)</li><li>常用格式：<ul><li>%Y-%m-%d %H:%M:%S</li></ul></li></ul></li></ul><p><code>time.strptime(STRING[, FORMAT])</code> 将字符串转换为struct_time对象。如果STRING是标准的时间字符串可以不用指定FORMAT，否则还是指明的好。</p><p><code>time.mktime(struct_time_object)</code> 将struct_time对象转化为一个浮点数（时间戳）</p><p><code>time.clock()</code> 返回当前CPU时间，用于<strong>计算程序耗时</strong>。</p><hr><h1 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h1><p>是time模块的高级封装，同时解除了time模块对年份（1970 - 2038）的限制。</p><p>datetime模块包含了5个类，实际常用的是datetime类。</p><p><code>ddnow = datetime.datetime.now()</code> 获取当前时间，是一个datetime.datetime对象</p><pre>datetime.datetime(2018, 7, 28, 9, 49, 22, 994058)</pre><p>这个可比time模块舒服多了…</p><table><thead><tr><th>API</th><th>Function</th></tr></thead><tbody><tr><td><code>ddnow.year</code></td><td>获取相关字段信息，类似的还有<code>.month</code>, <code>.day</code>, <code>.hour</code>, <code>.minute</code>, <code>.second</code>, <code>.tzinfo</code>, <code>.microsecond</code>等等</td></tr><tr><td><code>ddnow.replace(...)</code></td><td>修改上述字段的值</td></tr><tr><td><code>ddnow.strftime(FORMAT)</code></td><td>格式化时间字符串，与<code>time.strftime()</code>作用相同</td></tr><tr><td><code>datetime.datetime.strptime(STRING, FORMAT)</code></td><td>相对的datetime模块也能从时间字符串重构datetime对象</td></tr><tr><td><code>ddnow.date()</code><br><code>ddnow.time()</code></td><td>和datetime模块其他两个类（date，time）交互</td></tr><tr><td><code>ddnow.timetuple()</code></td><td>返回 <em>time.struct_time</em> 对象</td></tr></tbody></table><hr><h1 id="calendar模块"><a href="#calendar模块" class="headerlink" title="calendar模块"></a>calendar模块</h1><p>与日历相关</p><hr><h1 id="business-calendar模块"><a href="#business-calendar模块" class="headerlink" title="business_calendar模块"></a>business_calendar模块</h1><p>工作日相关</p><hr><h1 id="pytz模块"><a href="#pytz模块" class="headerlink" title="pytz模块"></a>pytz模块</h1><p>时区相关</p><hr><h1 id="dateutil模块"><a href="#dateutil模块" class="headerlink" title="dateutil模块"></a>dateutil模块</h1><p><code>dateutil.parser</code> 非常强大的时间字符串解析函数，返回datetime.datetime对象</p><p><code>dateutil.rrule</code> 根据定义的规则生成datetime.datetime对象</p><hr><h1 id="pandas-to-datetime"><a href="#pandas-to-datetime" class="headerlink" title="pandas.to_datetime"></a>pandas.to_datetime</h1><p>略</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logging内建模块（入门）</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180724-1605.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180724-1605.html</url>
      
        <content type="html"><![CDATA[<p>Python版本：Python 3.7</p><h1 id="logging基础教程"><a href="#logging基础教程" class="headerlink" title="logging基础教程"></a>logging基础教程</h1><p>日志指的是一些软件运行时我们记录下的事件的发生轨迹。软件的开发者在他们的代码里加入日志调用来查看哪些事件跟随着软件的运行发生了。一个事件通过一条描述性的消息进行记录，这条消息可以选择性地包括各种各样的数据（例如这些数据可能描述了某个事件在不同时刻的差异等）。事件也是开发者归咎错误等级的重要手段，这也叫做<strong>严重等级（日志等级）</strong>。<a id="more"></a></p><h2 id="什么时候使用日志？"><a href="#什么时候使用日志？" class="headerlink" title="什么时候使用日志？"></a>什么时候使用日志？</h2><p>日志模块提供了一些简单便利的函数以实现简单的日志功能，他们是<code>debug()</code>, <code>info()</code>, <code>warning()</code>, <code>error()</code>,和<code>critical()</code>。什么时候使用什么等级的日志函数见下表：</p><table><thead><tr><th>你想要执行的任务</th><th>该任务最适合的工具</th></tr></thead><tbody><tr><td>命令行脚本或程序简单地将输出显示到控制台</td><td>报告在程序正常运行期间发生的事件，例如状态监控、断层调查</td></tr><tr><td>报告在程序正常运行期间发生的事件，例如状态监控、断层调查</td><td><code>logging.info()</code>（或者以诊断为目的获取更加详细的输入的<code>logging.debug()</code></td></tr><tr><td>对一个特定的程序运行时产生的事件发出警告</td><td>使用库函数<code>warnings.warn()</code>，警告是可以避免的，应该修改程序代码以消除这样的警告<br><code>logging.warning()</code>，当我们对这样的情况不能作出任何修改而且警告必须被保存下来时就需要使用这个函数</td></tr><tr><td>将特定程序运行时产生的事件报告为错误</td><td>抛出异常即可</td></tr><tr><td>不抛出异常而报告一个错误（例如长期运行的服务器需要<strong>错误处理器</strong>）</td><td><code>logging.error()</code><br> <code>logging.exception()</code><br><code>logging.critical()</code></td></tr></tbody></table><p>默认的等级是<code>logging.WARNING</code>，这意味着只有当前等级以及大于当前等级的事件才会被跟踪，除非额外配置日志处理器的行为。</p><p>被跟踪的事件可以通过不同的方式进行处理，处理跟踪事件最简单的方式是把它们打印在控制台上。而另外一种常见的方式是把它们写入磁盘文件。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>一个非常简单地例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">'Watch out!'</span>) <span class="comment"># 将会打印信息到控制台</span></span><br><span class="line">logging.info(<span class="string">'I told you so'</span>) <span class="comment"># 将不会打印任何东西</span></span><br></pre></td></tr></table></figure><p>如果你将这些语句写入脚本并且运行它，你将看到：</p><pre>WARNING:root:Watch out!</pre><p>当打印到控制台时，<code>INFO</code>信息并没有出现，原因是默认的严重等级是<code>WARNING</code>。我们看到的打印消息实际上包含了严重等级以及调用日志函数时提供的描述信息，比如”Watch out!”。别担心打印消息中的’root’部分，我们接下来将会对其进行解释。实际的输出结果可以灵活地定制格式以满足各自的需要；格式的定制也将在后面部分进行介绍。</p><h2 id="将日志写入到文件"><a href="#将日志写入到文件" class="headerlink" title="将日志写入到文件"></a>将日志写入到文件</h2><p>一种非常典型的情景就是在文件中记录日志事件，我们接下来详细说说这种情况。确保接下来的语句在一个新打开的Python解释器中运行，千万不要使用上一部分的环境，否则你可能得到与我们不一样的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>, level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</span><br><span class="line">logging.info(<span class="string">'So should this'</span>)</span><br><span class="line">logging.warning(<span class="string">'And this, too'</span>)</span><br></pre></td></tr></table></figure><p>现在如果我们打开文件看看里面有什么，我们会发现以下日志信息：</p><pre>DEBUG:root:This message should go to the log fileINFO:root:So should thisWARNING:root:And this, too</pre><p>这个例子也展示了你应该如何设置日志的<strong>等级</strong>，这个等级将作为是否跟踪事件的阀门。在这个例子中因为我们将阀门设置为了<code>DEBUG</code>，所有的信息都将被打印出来。</p><p>如果你想在命令行选项参数里设置日志等级，请使用如下格式：</p><pre>--log=INFO</pre><p>你也可以通过变量 <em>loglevel</em> 获取<code>--log</code>参数传递的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(logging, loglevel.upper())</span><br></pre></td></tr></table></figure><p>获取你想要传递给<code>basicConfig()</code>的 <em>level</em> 参数的值，检查以下用户从命令行传入的参数是否合法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设loglevel一定是从命令行参数获取的字符串，后台自动将其转换为大写的形式，</span></span><br><span class="line"><span class="comment"># 这样用户就可以在命令行中指定 --log=DEBUG 或者 --log=debug</span></span><br><span class="line">numeric_level = getattr(logging, loglevel.upper(), <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(numeric_level, int):</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">'Invalid log level: %s'</span> % loglevel)</span><br><span class="line">logging.basicConfig(level=numeric_level, ...)</span><br></pre></td></tr></table></figure><p>调用<code>basicConfig()</code>应该在调用<code>debug()</code>, <code>info()</code>等方法之前。这种方式被有意设计成一次性的配置，只有第一次配置发挥作用，接下来再进行子参数的配置将起不到任何作用。</p><p>如果你多次运行上面的脚本，来自连续运行脚本的日志信息都将被添加到文件 <em>example.log</em> 中。如果你想要每个程序运行时都使用全新的日志文件而不是记住之前的日志信息，你可以指定 <em>fielmode</em> 参数，我们修改上面对<code>basicConfig()</code>的调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(</span><br><span class="line">filename=<span class="string">'example.log'</span>, </span><br><span class="line">filename=<span class="string">'w'</span>, </span><br><span class="line">level=logging.DEBUG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出将和以前一样，但是日志文件将不再是<strong>末尾添加</strong>模式，先前运行的日志信息已经丢失。</p><h2 id="多个模块的日志信息"><a href="#多个模块的日志信息" class="headerlink" title="多个模块的日志信息"></a>多个模块的日志信息</h2><p>如果你的程序是由多个模块组成的，这里有个例子展示你该如何在多个模块中组织的你的日志记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myapp.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> mylib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">logging.basicConfig(filename=<span class="string">'myapp.log'</span>, level=logging.INFO)</span><br><span class="line">logging.info(<span class="string">'Started'</span>)</span><br><span class="line">mylib.do_something()</span><br><span class="line">logging.info(<span class="string">'Finished'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mylib.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">()</span>:</span></span><br><span class="line">logging.info(<span class="string">'Doing something'</span>)</span><br></pre></td></tr></table></figure><p>如果你运行 <em>myapp.py</em>，你将在 <em>myapp.log</em> 中看到如下内容：</p><pre>INFO:root:StartedINFO:root:Doing somethingINFO:root:Finished</pre><p>见心之所想实在是一件鼓舞人心的事情。你可以使用<em>myapp.py</em>中的方法将这种模式推广到更复杂的多模块程序中去。需要注意的是，仅仅通过这种简单的方式你并不能根据日志文件的内容来判断日志信息来自哪一个模块，除非借助于消息描述本身。如果你想要跟踪你的日志消息的源位置，你需要放下这个基础教程去看看<a href="https://docs.python.org/2.7/howto/logging.html#logging-advanced-tutorial" target="_blank" rel="noopener">高级日志教程</a></p><h2 id="记录变化的数据"><a href="#记录变化的数据" class="headerlink" title="记录变化的数据"></a>记录变化的数据</h2><p>为事件的描述信息使用<strong>格式化字符串</strong>并将变量作为参数传递给日志函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">'%s before you %s'</span>, <span class="string">'look'</span>, <span class="string">'leap!'</span>)</span><br></pre></td></tr></table></figure><p>将会显示：</p><pre>WARNING:root:Look before you leap!</pre><p>正如你所看到的，将变量中的信息合并到日志描述信息中可以使用老式的%风格的格式化字符串。事实上，格式化字符串是向后兼容的，也就是说，你也可以使用<code>str.format()</code>或者<code>string,Template</code>。这些新的格式化字符串也被支持，这里不做详细探讨。</p><h2 id="改变消息显示的格式"><a href="#改变消息显示的格式" class="headerlink" title="改变消息显示的格式"></a>改变消息显示的格式</h2><p>为了改变用于显示的消息的格式，你需要指定你想用的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">format=<span class="string">'%(levelname)s:%(message)s'</span>, </span><br><span class="line">level=logging.DEBUG</span><br><span class="line">)</span><br><span class="line">logging.debug(<span class="string">'This message should appear on the console'</span>)</span><br><span class="line">logging.info(<span class="string">'So should this'</span>)</span><br><span class="line">logging.warning(<span class="string">'And this, too'</span>)</span><br></pre></td></tr></table></figure><p>将打印：</p><pre>DEBUG:This message should appear on the consoleINFO:So should thisWARNING:And this, too</pre><p>注意在前面出现的’root’在这里又出现了。对于控制格式的字符串的设置可以参见<a href="https://docs.python.org/2.7/library/logging.html#logrecord-attributes" target="_blank" rel="noopener">文档</a>。如果只是简单的使用日志，你只需要指定 <em>levelname</em>（日志等级），<em>message</em>（事件描述，可以包含变量）以及当事件发生时需要在哪里显示消息，这部分将在接下来详细介绍。</p><h2 id="在消息中显示时间"><a href="#在消息中显示时间" class="headerlink" title="在消息中显示时间"></a>在消息中显示时间</h2><p>如果需要在日志消息中显示时间，你需要在<strong>格式化字符串</strong>中放置 ‘%(asctime)s’：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s %(message)s'</span>)</span><br><span class="line">logging.warning(<span class="string">'is when this event was logged.'</span>)</span><br></pre></td></tr></table></figure><p>将打印如下消息：</p><pre>2010-12-12 11:41:42,612 is when this event was logged.</pre><p>上面这种默认时间显示格式被称之为 ISO8601。如果你想要更加自由的控制时间格式，请提供一个 <em>datefmt</em> 参数给 <code>basicConfig</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">format=<span class="string">'%(asctime)s %(message)s'</span>, </span><br><span class="line">datefmt=<span class="string">'%m/%d/%Y %I:%M:%S %p'</span></span><br><span class="line">)</span><br><span class="line">logging.warning(<span class="string">'is when this event was logged.'</span>)</span><br></pre></td></tr></table></figure><p>将打印如下消息：</p><pre>12/12/2010 11:46:36 AM is when this event was logged.</pre><p><em>datefmt</em> 的格式控制原理与 <code>time.strftime()</code> 相同。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面的作为基础教程，应该能够使你开始将日志功能添加到自己的代码中。事实上，logging包还提供了许多更为丰富的内容，如果你想更加熟练的应用日志功能，你需要花一点时间阅读<a href="https://docs.python.org/2.7/howto/logging.html#advanced-logging-tutorial" target="_blank" rel="noopener">高级教程(英)</a>。</p><p>如果你对日志功能的需求十分简单，你可以阅读上面的例子，将简单的日志记录融入到自己的代码中去。如果遇到任何问题或者对某些东西不太理解欢迎光临<a href="https://groups.google.com/group/comp.lang.python" target="_blank" rel="noopener">论坛</a>。</p><p>如果你看过了高级教程，也可以读读 <a href="https://docs.python.org/2.7/howto/logging-cookbook.html#logging-cookbook" target="_blank" rel="noopener">Logging Cookbook</a>。</p><p>注注注：本文手撸自<a href="https://docs.python.org/2.7/howto/logging.html#basic-logging-tutorial" target="_blank" rel="noopener">官方文档</a></p><p style="font-size:16px;margin:0">Author: Barwe(YinChen)<br>Email: <a href="mailto:chenyinbarwe@qq.com" target="_blank" rel="noopener">chenyinbarwe@qq.com</a></p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>getpass内建模块</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180723-77b1.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180723-77b1.html</url>
      
        <content type="html"><![CDATA[<p><strong>getpass</strong>模块用于命令行程序获取密码，输入密码时不会回显在屏幕上<br> 该模块主要包括两个可用的函数：</p><ol><li><code>getpass.getpass()</code></li><li><code>getpass.getuser()</code></li></ol><h1 id="getpass-getpass-提示字符串"><a href="#getpass-getpass-提示字符串" class="headerlink" title="getpass.getpass(提示字符串)"></a>getpass.getpass(提示字符串)</h1><h1 id="getpass-getuser"><a href="#getpass-getuser" class="headerlink" title="getpass.getuser()"></a>getpass.getuser()</h1><p>该函数实际上会首先检索环境变量<strong>LOGNAME</strong>（Linux系统可通过<code>echo $LOGNAME</code>查看该值）及其他环境变量的值</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-mysql-删除(DROP+TRUNCATE+DELETE)</title>
      <link href="/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20180718-3284.html"/>
      <url>/IT%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/20180718-3284.html</url>
      
        <content type="html"><![CDATA[<p>这里的删除分为：</p><ol><li>删除表中的部分数据</li><li>删除表的所有数据：下次添加数据前不需要新建表</li><li>同时删除表的数据和表的<strong>定义</strong>：下次添加数据之前必须新建表</li></ol><p>主要关键词有：<strong>TRUNCATE</strong> <strong>DROP</strong> <strong>DELETE</strong></p><a id="more"></a><p>下面按删除类型介绍操作语句：</p><h1 id="删除一行或部分行"><a href="#删除一行或部分行" class="headerlink" title="删除一行或部分行"></a>删除一行或部分行</h1><p>1.<strong>DELETE FROM 表 WHERE 字段 = 值</strong>：选择性地删除一行</p><p>有趣的是，MySQL对DELETE语句添加了标准SQL语句没有的一些功能：</p><p>2.<strong>DELETE FROM 表 WHERE 字段 = 值 LIMIT 数量</strong>：当WHERE过滤结果有多个时删除前面的几个，即<strong>删除过滤结果中的部分数据</strong></p><p>如果上述语句2对删除部分结果的排序标准不明确可以使用ORDER BY指定排序字段，再使用LIMIT限制删除部分数据：</p><p>3.<strong>DELETE FROM 表 WHERE 字段 = 值 ORDER BY 排序字段 LIMIT 数量</strong>：由小到大</p><p>4.<strong>DELETE FROM 表 WHERE 字段 = 值 ORDER BY 排序字段 DESC LIMIT 数量</strong>：由大到小</p><h1 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h1><p><strong>UPDATE</strong></p><h1 id="删除所有行但保留表的定义"><a href="#删除所有行但保留表的定义" class="headerlink" title="删除所有行但保留表的定义"></a>删除所有行但保留表的定义</h1><p>1.<strong>DELETE FROM 表</strong>：返回被删除的记录数，自增字段起始值恢复为1</p><p>2.<strong>TRUNCATE TABLE 表</strong>：不返回被删除的记录数，自增字段起始值恢复为1</p><p>3.<strong>DELETE FROM 表 WHERE true</strong>：返回被删除的记录数，自增字段起始值不变</p><p>注意：</p><ul><li>语句3由于加了WHERE将进行逐行扫描（尽管不进行WHERE判断），而语句1直接删除所有数据就好了，所以语句3的执行成本高于语句1</li><li>语句2相对于语句1虽然不能返回被删除的记录数，但是<strong>非常快</strong></li></ul><h1 id="删除指定表（包括内容和定义）"><a href="#删除指定表（包括内容和定义）" class="headerlink" title="删除指定表（包括内容和定义）"></a>删除指定表（包括内容和定义）</h1><p><strong>DROP TABLE 表</strong></p><h1 id="删除指定数据库的所有表数据（保留结构）"><a href="#删除指定数据库的所有表数据（保留结构）" class="headerlink" title="删除指定数据库的所有表数据（保留结构）"></a>删除指定数据库的所有表数据（保留结构）</h1><p>首先要能遍历到所有表：SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA=’数据库名’</p><p>然后我们使用内置连接语句CONCAT生成多个命令：</p><p><strong>SELECT CONCAT(‘TRUNCATE TABLE ‘, TABLE_NAME, ‘;’) FROM information_schema.TABLES WHERE TABLE_SCHEMA=’数据库名’</strong>：注意TRUNCATE TABLE后面留一个空格</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html" target="_blank" rel="noopener">DROP、DELETE、TRUNCATE的适用情况</a></p>]]></content>
      
      
      <categories>
          
          <category> IT开发笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>玻尔兹曼机和受限玻尔兹曼机</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180717-601f.html"/>
      <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180717-601f.html</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="http://yann.lecun.com/exdb/publis/pdf/lecun-06.pdf" target="_blank" rel="noopener">A Tutorial on Energy-Based Learning</a></p><a id="more"></a><p><strong>基于能量的模型(EBM, Energy Based Model)</strong>：在以计算概率为目标时我们需要将直接计算结果进行归一化和非负处理，完成这两个目标的方式有很多种，我们需要选择计算较为简单的，比如自然指数e。例如，对于离散型随机变量，x经过f变换后再经过自然指数的变换，最后归一化，结果可以被视为一组概率值：</p><p><img src="https://www.zhihu.com/equation?tex=P%28x%29%3D%5Cfrac%7B1%7D%7BZ%7De%5E%7Bf%28x%29%7D" alt=""> 其中 <img src="https://www.zhihu.com/equation?tex=Z%3D%5Csum_%7Bx%5Cin+X%7D+e%5E%7Bf%28x%29%7D" alt=""></p><p>借用原博主的一句话，“哇，是不是很像softmax” <a href="https://www.zhihu.com/question/59264464" target="_blank" rel="noopener">知乎回答</a></p><p>为什么称之为能量？按照原博主的介绍，“能量”的概念应该来自于统计物理学中相似的分布形式：</p><p><img src="https://www.zhihu.com/equation?tex=P%28x%29%3D%5Cfrac%7Be%5E%7B-E%28x%29%7D%7D%7B%5Csum_%7Bx%5Cin+X%7D+e%5E%7B-E%28x%29%7D%7D" alt=""></p><hr><p><strong>玻尔兹曼机(Boltzmann Machine)</strong>：由观察节点和隐藏节点组成，但是任意两个节点间都有无向边连接，这样的结构在应用中没有实际效果。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Boltzmannexamplev1.png" alt="https://zh.wikipedia.org/wiki/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"></p><hr><p><strong>受限玻尔兹曼机(RBM, Restricted Boltzmann Machine)</strong>：顾名思义，在玻尔兹曼机的基础上去掉<strong>观察节点间</strong>和<strong>隐藏节点间</strong>的无向边，<strong>观察层</strong>和<strong>隐藏层</strong>由<strong>无向边</strong>进行连接。RBM定义了神经网络连续两层的形式，可以说是神经网络之砖瓦了。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Restricted_Boltzmann_machine.svg/440px-Restricted_Boltzmann_machine.svg.png" alt="https://zh.wikipedia.org/wiki/%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"></p><p>受限玻尔兹曼机实际上是一个<strong>二分图</strong>：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/400px-Simple-bipartite-graph.svg.png" alt="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E5%9B%BE"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>统计模型估计-噪音对比估计NCE</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180716-beb2.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180716-beb2.html</url>
      
        <content type="html"><![CDATA[<p><strong>噪声对比估计(NCE, Noise-Contrastive Estimation)</strong></p><p>指数有着十分好的性质，非负、求导快…但同时，指数概率分布的<strong>配分函数</strong>有时会很难计算：<a id="more"></a></p><p><img src="https://image.jiqizhixin.com/uploads/editor/4aec943e-657c-43b8-8b18-6a90a53e3031/1529470679336.png" alt=""></p><p>配分函数<img src="https://image.jiqizhixin.com/uploads/editor/33d70f04-36b9-40b7-be05-b7918121b691/1529470681193.png" alt=""></p><p>配分函数难以计算主要原因有两个：</p><ol><li>由于Z需要对所有样本求加和，当样本数庞大时计算量将超过预期</li><li>对于某些G(x)，Z实际上是不可计算的</li></ol><p>如果我们要求p(x)就必须计算配分函数，但是当配分函数实际不可计算时P(x)也就不可求了。此时我们必须曲线救国，<a href="https://www.jiqizhixin.com/articles/2018-06-20-9" target="_blank" rel="noopener">然后中间是看不太懂的巴拉巴拉…</a>。总之，NCE的思想就是将概率生成问题转化为<strong>二分类问题</strong>：真实样本和从简单分布随机采样的错误样本进行对比，试图找到真实样本与错误样本的差异。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/82bf809e-afe7-4db1-8e33-379aa57a6358/1529470679806.png" alt=""></p><p>原文证明了为什么γ能够替换配分函数</p><p>当负样本比正样本多的多时可以考虑NCE</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python从requirements.txt安装包</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180423-48b5.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180423-48b5.html</url>
      
        <content type="html"><![CDATA[<p><strong>requirements.txt</strong>记录的是当前程序的依赖包和版本号<br>用来在另一台电脑上重构运行环境。<a id="more"></a></p><h1 id="生成requirements-txt文件"><a href="#生成requirements-txt文件" class="headerlink" title="生成requirements.txt文件"></a>生成requirements.txt文件</h1><p>查看包列表：</p><pre><code>pip freeze</code></pre><p>保存只需要借助定向符即可：</p><pre><code>pip freeze &gt; requirements.txt</code></pre><h1 id="从requirements-txt文件进行安装"><a href="#从requirements-txt文件进行安装" class="headerlink" title="从requirements.txt文件进行安装"></a>从requirements.txt文件进行安装</h1><pre><code>pip install -r requirements.txt</code></pre><p><strong>pip freeze</strong>保存的是当前环境下所有的包<br>实际上我们可能只需要与项目有关的包<br>这里建议使用另一个工具：</p><h1 id="pipreqs"><a href="#pipreqs" class="headerlink" title="pipreqs"></a>pipreqs</h1><p>安装它：</p><pre><code>pip install pipreqs</code></pre><p>使用它：</p><pre><code>pipreqs 项目路径 [选项]</code></pre><p>默认保存为项目根路径下的requirements.txt</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青铜派森 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下在右键菜单中添加获取管理员权限入口</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-f8ae.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-f8ae.html</url>
      
        <content type="html"><![CDATA[<p>右键菜单改造。<a id="more"></a></p><h1 id="添加“管理员权限”"><a href="#添加“管理员权限”" class="headerlink" title="添加“管理员权限”"></a>添加“管理员权限”</h1><p>效果如下：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/49382740.jpg" alt=""></p><p>新建<strong>REG</strong>文件，右键编辑内容</p><pre><code>Windows Registry Editor Version 5.00;取得文件修改权限  [HKEY_CLASSES_ROOT\*\shell\runas]  @=&quot;管理员权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,102&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\*\shell\runas\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2]  @=&quot;管理员权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,102&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas]  @=&quot;管理员权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,102&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;</code></pre><p>双击运行</p><h1 id="添加“恢复原始权限”"><a href="#添加“恢复原始权限”" class="headerlink" title="添加“恢复原始权限”"></a>添加“恢复原始权限”</h1><p><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/63044065.jpg" alt=""></p><p>新建<strong>REG</strong>文件，右键编辑内容</p><pre><code>Windows Registry Editor Version 5.00;恢复原始权限  [HKEY_CLASSES_ROOT\*\shell\runas-]  @=&quot;恢复原始权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,101&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;; &amp;&amp; takeown /f \&quot;%1\&quot;[HKEY_CLASSES_ROOT\*\shell\runas-\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2-]  @=&quot;恢复原始权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,101&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2-\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas-]  @=&quot;恢复原始权限&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\imageres.dll,101&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas-\command]  @=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /reset &amp;&amp; cacls \&quot;%1\&quot; /e /r \&quot;%%USERNAME%%\&quot;&quot;</code></pre><p>双击运行</p><h1 id="取消上面两个选项"><a href="#取消上面两个选项" class="headerlink" title="取消上面两个选项"></a>取消上面两个选项</h1><p>取消之后就像从未发生过一样~~~<br>新建<strong>REG</strong>文件，右键编辑内容</p><pre><code>Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\*\shell\runas][-HKEY_CLASSES_ROOT\exefile\shell\runas2][-HKEY_CLASSES_ROOT\Directory\shell\runas][-HKEY_CLASSES_ROOT\*\shell\runas-][-HKEY_CLASSES_ROOT\exefile\shell\runas2-][-HKEY_CLASSES_ROOT\Directory\shell\runas-]</code></pre><p>双击运行</p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10下给目录右键菜单添加cmd入口</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-38fd.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-38fd.html</url>
      
        <content type="html"><![CDATA[<p>你是否厌倦了在cmd中切换工作路径？<br>现在教你设置在图形界面中通过右键菜单直接以某个目录作为工作路径<br>即，在目录的右键菜单中添加“进入cmd”选项<br>核心方法，还是修改注册表~~~ <a id="more"></a></p><p>Ⅰ.打开注册表，路径栏搜索<strong>HKEY_CLASSES_ROOT\Folder\shell</strong></p><p>Ⅱ.右键<strong>shell</strong>新建<strong>项</strong>，名称为<strong>cmdPrompt</strong><br><span style="color:red">实际上这个名字可以随便取</span>，这就意味着我们可以添加多个项<br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/35089862.jpg" alt=""><br>新建完成如下：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/73456749.jpg" alt=""></p><p>Ⅲ.双击<strong>cmdPrompt</strong>下右侧的<strong>名称</strong>设置值，该字符串用于显示在右键菜单上，所以可以取个响亮的名字，比如“在cmd中打开”<br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/32232029.jpg" alt=""></p><p>Ⅳ.右键<strong>cmdPrompt</strong>新建<strong>项</strong>，名称为<strong>command</strong><br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/91034896.jpg" alt=""></p><p>Ⅴ.双击<strong>command</strong>下右侧的<strong>名称</strong>设置值，值为<strong>cmd.exe /k cd %1</strong></p><blockquote><p>/k 表示执行后面的命令并保留终端</p></blockquote><p><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/2107162.jpg" alt=""></p><p>Ⅵ.保存退出即可</p><p>最终效果如下：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/20081696.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10下隐藏资源管理器中六大用户文件夹</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-6264.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-6264.html</url>
      
        <content type="html"><![CDATA[<p>打开<strong>资源管理器</strong>或者<strong>我的电脑</strong>你会看到下面这六个用户文件夹<a id="more"></a><br><img src="http://p33k8pinb.bkt.clouddn.com/18-4-20/11431529.jpg" alt=""><br>如果你没有把文件存在这个目录下的打算，他们会显得特别碍眼<br>这里我们可以隐藏这六个目录<br>隐藏通过修改注册表实现：我们即可已直接修改注册表，也可以通过<strong>.reg</strong>脚本修改注册表<br>因为涉及到的值较多，我们使用后一种方式修改注册表</p><h1 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h1><p>在你喜欢的目录下新建reg文件，文件名随便取，但是必须以<strong>.reg</strong>结尾<br>右键<strong>编辑</strong>，千万不能直接<strong>双击</strong>！！<br>输入以下内容：</p><pre><code>Windows Registry Editor Version 5.00[-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}][-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{d3162b92-9365-467a-956b-92703aca08af}][-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}][-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}][-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{088e3905-0323-4b02-9826-5d99428e115f}][-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]</code></pre><p>保存后<strong>双击</strong>运行即可，弹出的一切提示均点击<strong>是</strong>即可</p><h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p>恢复只要报上面语句的<strong>负号</strong>去掉即可<br>新建另一个.reg文件，输入：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{d3162b92-9365-467a-956b-92703aca08af}][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{088e3905-0323-4b02-9826-5d99428e115f}][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]</code></pre><p>保存后<strong>双击</strong>即可恢复那六个文件夹</p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10下使用doskey在cmd中建立类似于linux中alias的宏</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-1a3f.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180420-1a3f.html</url>
      
        <content type="html"><![CDATA[<p>在linux系统中可以通过修改.bashrc文件十分简便的设置alias宏命令（macro)<br>在win10下cmd中实现相同的功能要复杂一点<a id="more"></a></p><h1 id="新建宏文件"><a href="#新建宏文件" class="headerlink" title="新建宏文件"></a>新建宏文件</h1><p>首先你需要一个文件存放宏，假设我们在C盘根目录下建立了文件<code>cmd-alias.bat</code></p><h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><p>然后你需要在启动cnd时自动加载文件中的宏，那么问题来了，怎么自动加载宏？修改注册表：<br>1、摁下win+R输入regedit回车<br>2、在菜单栏下的路径栏输入<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor</code>回车<br>3、右侧新建<strong>字符串值</strong>，数值名称填<code>AutoRun</code>，数值数据填<code>C:\cmd-alias.bat</code>（第一步那个文件的路径）<br>4、关闭即可。。</p><h1 id="修改宏文件"><a href="#修改宏文件" class="headerlink" title="修改宏文件"></a>修改宏文件</h1><p>右键第一步的文件，选择<strong>编辑</strong>（默认用记事本打开）</p><p>◎ 在windows系统下不是alias命令，而是doskey命令</p><blockquote><p>doskey程序路径为<code>C:\Windows\System32\doskey.exe</code></p></blockquote><p>◎ 与.bashrc文件一样，一行一个doskey，语句以<strong>doskey</strong>开头</p><p>◎ 以<strong>@doskey</strong>开头的宏在cmd打开时不会显示在屏幕上</p><h2 id="单个命令的宏"><a href="#单个命令的宏" class="headerlink" title="单个命令的宏"></a>单个命令的宏</h2><p><strong>@doskey ls=dir</strong>：列出当前目录下的子文件/子目录信息</p><blockquote><p>win10默认为<strong>dir</strong>，linux默认为ls，这里我们设置<strong>ls</strong>起到与dir相同的作用</p></blockquote><p><strong>@doskey ls=dir $*</strong>：<strong>$*</strong>表示后面可能还有其他参数，参考<strong>ls</strong></p><h2 id="多个命令的宏"><a href="#多个命令的宏" class="headerlink" title="多个命令的宏"></a>多个命令的宏</h2><p>多个命令的宏用<strong>$t</strong>隔开，命令间不用加空格<br><strong>@doskey hexocgd=hexo clean$thexo g$thexo d</strong>：顺序执行hexo clean, hexo g, hexo d</p><h1 id="doskey"><a href="#doskey" class="headerlink" title="doskey"></a>doskey</h1><p><strong>doskey /MACROS</strong> 可查看所有已经定义的宏命令</p>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划-钢材切割经典问题</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180313-6ba0.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180313-6ba0.html</url>
      
        <content type="html"><![CDATA[<h1 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h1><p><img src="http://p33k8pinb.bkt.clouddn.com/18-3-13/48270209.jpg" alt=""></p><h1 id="什么时候用动态规划"><a href="#什么时候用动态规划" class="headerlink" title="什么时候用动态规划?"></a>什么时候用动态规划?</h1><p>动态规划（Dynamic Programming）问题的显著特征：<a id="more"></a></p><ol><li><strong>最优子结构</strong> （optimal substructure）</li></ol><p><span style="color:red;">如果一个问题的解结构包含其子问题的最优解，称此问题具有最优子结构问题。</span>如上的钢条切割问题，长度为n的钢条显然存在最优解，而且最优解一定可以分为两组，假设为i和n-i，那么长度分别为i和n-i的钢条显然也存在最优解，而且可以对这两种钢条独立求解（对长度分别为i和n-i的钢条求解完全是另外的不同的问题）。当然，这里还存在另外一种情况，长度为n的钢条不一定非要切割才能产生最优解，事实上当p<sub>n</sub>足够大时最优解发生在不切割时，因此需要取<strong>不切割</strong>和<strong>切割成两组</strong>中较大的那个值。事实上所谓的<strong>切割成两组</strong>可能存在不止一种切法：长度为n的钢条存在n-1种切法。因此实际上的递归式可以写为：</p><p>$$r_n=\max{(p_n,r_1+r_{n-1},r_2+r_{n-2},…,r_{n-1}+r_1)},\text{共n项}$$</p><p>考虑到重复元素，可进一步精简为：$[\frac{n}2]$表示取整</p><p>$$r_n=max{(p_n,r_1+r_{n-1},r_2+r_{n-2},…,r_{[frac{n}2]}+r_{n-[\frac{n}2]})},\text{共$1+\frac{n}2$项}$$</p><ol start="2"><li><strong>重叠子问题</strong>（overlapping subproblems） </li></ol><p>当根据递归式<strong>自顶向底</strong>进行计算时，如果不运用任何技巧（如备忘录），将会浪费大量的资源重复计算相同的子问题，很明显这些子问题是重叠的。递归本来就需要额外的空间对中间状态进行存储，如果还要浪费大量时间重复计算重叠子问题，大大的不划算。解决重叠子问题大概有两种方法：</p><ol><li><strong>备忘录</strong>：自顶向下计算时将中间结果存下来，下次遇到时直接查询即可。备忘录解决了重叠子问题的计算。</li><li><strong>自底向顶计算</strong>：这个就厉害了，连递归栈也省略了。利用递推式从最小的同类问题开始计算，你会发现意外的惊喜。在钢条切割问题中最简单的同类问题不外乎$r_0=0$或者$r_1=r_p$。</li></ol><blockquote><p>java中可以使用 <code>Arrays.stream(ARRAY).max().getAsInt()</code> 获取最大值</p></blockquote><h1 id="动态规划的经典模型"><a href="#动态规划的经典模型" class="headerlink" title="动态规划的经典模型"></a>动态规划的经典模型</h1><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><p>状态的排布呈线性：？？</p><div style="font-size:18px;font-family:楷体;padding:20px">【例题】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。</div><h2 id="区间模型"><a href="#区间模型" class="headerlink" title="区间模型"></a>区间模型</h2><h2 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三大相关系数 Pearson Kendall Spearman</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180312-2d85.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180312-2d85.html</url>
      
        <content type="html"><![CDATA[<p>简单区分一下三大相关系数：<a id="more"></a></p><h1 id="Pearson积矩相关系数r"><a href="#Pearson积矩相关系数r" class="headerlink" title="Pearson积矩相关系数r"></a>Pearson积矩相关系数r</h1><p>度量两变量间的<strong>线性相关</strong>关系，用r表示，定义为两变量<strong>协方差与标准差积的商</strong>（公式网上有的是。。）。</p><ul><li>高斯采样：因为公式要用到<strong>方差</strong>和<strong>均值</strong>，而已方差和均值作为参数的分布显而易见是高斯分布，因此两变量都要求从高斯分布采样</li><li>成对采样：因为需要计算协方差矩阵（方阵）</li><li>线性相关：各变量的离散值趋势大致呈直线，计算的是两条近似直线间的差异程度</li><li>显然计算Pearson距离属于<strong>参数统计方法</strong></li><li>而且以上条件较强，实际应用时难度较大</li></ul><h1 id="Spearman秩相关系数ρ"><a href="#Spearman秩相关系数ρ" class="headerlink" title="Spearman秩相关系数ρ"></a>Spearman秩相关系数ρ</h1><p>度量两个变量之间关系的强弱</p><ul><li><p>非参数统计方法：因为不需要假设总体的分布</p><ul><li>只要两变量间具有单调的函数关系，则两变量<strong>完全Spearman相关</strong></li></ul></li><li><p>通常被认为是排列后的Pearson相关系数：参与Spearman系数计算的实际上是原始数据的<strong>等级值</strong>：</p><ul><li>一般原始数据是<strong>能排序</strong>且<strong>不重复</strong>的数据</li><li>对于重复数据另外处理</li></ul></li><li><p>很明显处理的是两列数据</p></li></ul><p>计算公式<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-12/97151703.jpg" alt=""></p><p>下表清晰定义了d<sub>i</sub><sup>2</sup>的求法：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-12/15520407.jpg" alt=""></p><p><a href="http://blog.csdn.net/liuyuan_jq/article/details/52542211" target="_blank" rel="noopener">参考博客</a></p><h1 id="Kendall等级相关系数τ"><a href="#Kendall等级相关系数τ" class="headerlink" title="Kendall等级相关系数τ"></a>Kendall等级相关系数τ</h1><p>略</p><p><a href="http://blog.sciencenet.cn/blog-801621-688307.html" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>参数模型和非参数模型</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180312-62c1.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180312-62c1.html</url>
      
        <content type="html"><![CDATA[<p>任何模型的建立都会做出一定的假设</p><h1 id="参数模型-parametric-models"><a href="#参数模型-parametric-models" class="headerlink" title="参数模型(parametric models)"></a>参数模型(parametric models)</h1><p>要先假设<strong>总体</strong>服从某个分布（不同的分布有自己的分布参数，比如高斯分布的参数是均值和方差），然后通过<strong>样本</strong>来估计总体分布的参数</p><p>参数模型通过估计出的<strong>分布</strong>进行检验和预测。<a id="more"></a></p><h1 id="非参数模型-nonparametric-models"><a href="#非参数模型-nonparametric-models" class="headerlink" title="非参数模型(nonparametric models)"></a>非参数模型(nonparametric models)</h1><p>有时候样本不足以支撑我们取估计总体，或者总体本身没有明显的特征。</p><p>非参数模型对<strong>总体</strong>的分布没有要求，也就是说在计算分析过程中不会用到总体的概率分布表达式。</p><p>但是数据必须可以进行<strong>排序</strong>，因此能影响排序的因素（数据中有相等值）对模型估计结果影响巨大。</p><p>非参数模型通过<strong>数据本身</strong>进行检验和预测。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas模块-加载数据</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180308-ca22.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180308-ca22.html</url>
      
        <content type="html"><![CDATA[<h1 id="文本文件读取"><a href="#文本文件读取" class="headerlink" title="文本文件读取"></a>文本文件读取</h1><h2 id="pd-read-csv-…"><a href="#pd-read-csv-…" class="headerlink" title="pd.read_csv(…)"></a>pd.read_csv(…)</h2><p>详细记录pandas读取表格型数据文件的方法：<code>pd.read_csv()</code><br><a id="more"></a></p><blockquote><p>其实pytohn内置了一个可以处理简单规整csv文件的模块：<code>import csv</code><br>给 <code>csv.reader()</code> 传入<strong>文件型对象</strong>即可<br>什么？你不知道什么是文件型对象？ <code>open(fp,&#39;r&#39;)</code> 返回的就是文件型对象</p></blockquote><p>重要参数解析：</p><pre><code>path: 这个参数不解释，可以是本地路径，也可以是URLsep: 行内字段(列)分隔符，csv文件默认为逗号，还可以为正则表达式header: 标识列名的行号。默认为0，代表文件第一行是列名，没有列名时需要设为None    //当header=None时:    names: 字符串组成的列表，指定列名index_col: 标识行索引    简单行索引：列编号（整数）或者列名（字符串）    层次化索引：列编号/列名zucheng的列表        什么是层次化索引？将多个列作为索引，列之间将产生层次关系            a   a1                a2            b   b1                b2                b3            ...skiprows:    如果传入整数，表示需要从文件开始出算起需要忽略的行数            如果传入整数列表，表示需要跳过的行号列表（从0开始）skip_footer: 整型，从文件末尾算起需要忽略的行数nrows: 整型，需要读取的行数（从开始算起）na_value: 用于替换NaN的值comment: 当行末有注释信息时指定注释信息标志字符parse_dates: 尝试将数据解析为日期，默认为False    传入True：尝试将所有列都解析为日期（一般是行不通的）    传入列号/列名的列表：仅尝试将指定的（一些）列解析为日期    传入上一行列表的列表：尝试将多个列进行组合后进行解析（当日期不同部分分散在不同的列中时）        keep_date_col: 当组合多列解析时是否保留原始列，默认为Falsedayfirst: 当日期出现歧义时（如7/6/2018究竟是6月还是7月？)指定day的位置，默认为Falsedate_parser: 或者传入一个用于解析日期的函数converters: 列值预处理，传入一个字典d={列号/列名: 函数, ...}，表示对相应地列的值将执行相应地函数iterator: 用于逐块读取文件chunksize: 文件块的大小verbose: 是否打印日志encoding: 文本编码格式squeeze: 数据经过解析后只剩下一列，返回Series而不是DataFramethousands: 千分位分隔符</code></pre><h2 id="逐块读取"><a href="#逐块读取" class="headerlink" title="逐块读取"></a>逐块读取</h2><p>当文件特别大时我门可能只是想读取文件的一小部分或者逐块迭代</p><ul><li>如果我们只是想读文件开始几行，使用关键字参数 <code>nrows</code>。（Q: 那中间几行呢？）</li><li>逐块迭代：<code>read_csgv</code> 指定 <code>chunksize</code> 后将返回一个TextParser用于后续迭代<br>Q: 按固定字符数读取？If so, 貌似只适用于行字符数相同的文件?</li></ul><h2 id="XML文件读取"><a href="#XML文件读取" class="headerlink" title="XML文件读取"></a>XML文件读取</h2><p>略</p><hr><h1 id="二进制文件读取"><a href="#二进制文件读取" class="headerlink" title="二进制文件读取"></a>二进制文件读取</h1><h2 id="pickle序列化"><a href="#pickle序列化" class="headerlink" title="pickle序列化"></a>pickle序列化</h2><p>首先得了解<a href="#">python内置的pickle序列化</a><br>保存pandas对象到磁盘：<code>PD_OBJ.save(FILE_NAME)</code><br>从磁盘取回pandas对象：<code>PD_OBJ.load(FILE_NAME)</code></p><h2 id="HDF5格式"><a href="#HDF5格式" class="headerlink" title="HDF5格式"></a>HDF5格式</h2><blockquote><p><strong>高效</strong>读写磁盘上以二进制形式存储的科学数据<br>HDF: Hierarchical Data Format<br>高效<strong>分块读写</strong><br>python中有两个接口：PyTables + h5py<br>pandas建立HDFStore类，通过PyTables存储对象</p></blockquote><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>HDFStore类类似于字典，创建HDFStore对象后按照字典方式赋值即可。</p><pre><code>//&lt;class &apos;pandas.io.pytables.HDFStore&apos;&gt;store = pd.HDFStore(OUTPUT_FILE)store[&apos;obj1&apos;] = dataframestore[&apos;obj1_col&apos;] = dataframe[&apos;a&apos;]</code></pre><p><span style="color:red">对于IO密集型数据（而非CPU密集型数据），使用HDF5能够大大提升效率</span></p><h2 id="Excel格式"><a href="#Excel格式" class="headerlink" title="Excel格式"></a>Excel格式</h2><p>panda中相关的类：<code>ExcelFile</code><br>依赖包：xlrd, openpyxl</p><p>创建实例：<code>xls_file = pd.ExcelFile(XLS_FILE)</code></p><p>读取数据：<code>table = xls_file.parse(&#39;Sheet1&#39;)</code></p><h1 id="使用HTML和Web-API"><a href="#使用HTML和Web-API" class="headerlink" title="使用HTML和Web API"></a>使用HTML和Web API</h1><h1 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h1><h1 id="存取MongoDB中的数据"><a href="#存取MongoDB中的数据" class="headerlink" title="存取MongoDB中的数据"></a>存取MongoDB中的数据</h1>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas模块-Series类和DataFrame类</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180307-3057.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180307-3057.html</url>
      
        <content type="html"><![CDATA[<p>pandas是基于numpy构建的高级数据结构和操作工具。<a id="more"></a></p><h1 id="pandas的数据结构"><a href="#pandas的数据结构" class="headerlink" title="pandas的数据结构"></a>pandas的数据结构</h1><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>类似于<strong>一维数组</strong>的<strong>对象</strong>，索引即标签<br>导入： <code>from pandas import Series</code><br>初始化：</p><ul><li><code>obj = Series([-1, 3, 1, 4])</code></li><li><code>obj = Series([-1, 3, 1, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</code><br>pandas可以被当做字典使用~</li><li><code>obj = Series({&#39;a&#39;:-1, &#39;b&#39;:3, &#39;c&#39;:1})</code>：不指定index使用传入字典的键</li><li><code>obj = Series({&#39;a&#39;:-1, &#39;b&#39;:3, &#39;c&#39;:1}, index=[&#39;a&#39;,&#39;b&#39;])</code>：使用index时将按照index去字典中挑选，如果该字典中键值对不存在则设为NaN（缺失值）。<ul><li>使用 <code>obj.isnull()</code> 和 <code>obj.notnull()</code> 检测是否为缺失值</li><li><code>obj.isnull()</code> 等价于 <code>pd.isnull(obj)</code> , <code>notnull()</code> 类似</li></ul></li></ul><p>基本属性：</p><ul><li><code>obj.values</code> 查看值</li><li><code>obj.index</code> 查看索引</li><li><code>obj.name</code></li><li><code>obj.index.name</code></li></ul><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>表格型数据结构<br>数据以<strong>二维块</strong>存放，行列操作比较平衡，因为存放结构并不是简单的复合一维数据结构（如原生的嵌套列表，行的操作比列简单）<br>导入：<code>from pandas import DataFrame</code><br>初始化：</p><ul><li><p>传入字典：键为列的名称，值为等长的列表或者ndarray<br>此时索引默认为自然数0到N-1；或者通过 <code>index</code> 传入索引值。索引值对应的列如果没有值将设为NaN</p><p>↓↓↓ 未指定列的顺序，将按照列名称自动排序：传入的<strong>列名</strong>是<code>name age</code>, 实际存储的顺序是<code>age name</code><br><code>frame = DataFrame({&#39;name&#39;:[&#39;aa&#39;,&#39;cc&#39;,&#39;bb&#39;], &#39;age&#39;:[21, 24, 18]})</code></p><p>↓↓↓ 或者通过 <code>columns</code> 指定列的顺序：按照columnszhiding的顺序进行存储<br><code>frame = DataFrame({&#39;name&#39;:[&#39;aa&#39;,&#39;cc&#39;,&#39;bb&#39;], &#39;age&#39;:[21, 24, 18]}, columns=[&#39;name&#39;, &#39;age&#39;])</code></p></li><li><p>传入嵌套字典：外键被解释为列名(columns)，内键被解释为索引(index)，自动填充缺失数据<br>内键将会被重新排序形成<strong>有序的</strong>索引，可以使用<code>index=</code>显示指定索引的顺序，同时还能起到<strong>筛选</strong>的作用</p></li><li><p>实际上可以传入由<strong>列表</strong>、<strong>元组</strong>、<strong>ndarray</strong>、<strong>Series</strong>、<strong>字典</strong>复合而成的多种数据结构</p></li></ul><p>基本操作：</p><ul><li>获取列：<code>frame[&#39;name&#39;]</code> or <code>frame.name</code>，实际上是一个Series<br><span style="color:red">索引获取的列是原数据的<strong>视图</strong>，修改Series将反馈到原数据，复制请使用<strong>Series.copy()</strong></span></li><li>修改列：直接给列赋值<strong>标量</strong>或者<strong>向量</strong><ul><li>赋标量将自动广播</li><li>赋列表或者数组<strong>一定</strong>要保证长度一致</li><li>赋Series会对索引进行精确匹配，空位填上NaN</li></ul></li><li>添加列：用<code>frame[&quot;new_column_name&quot;]=...</code>进行赋值将自动添加新列，<code>frame.new_column_name</code>不可以</li><li>删除列：<code>del frame[&quot;existed_column_name&quot;]</code>，<code>del frame.existed_column_name</code>不可以</li><li>获取列名：<code>frame.columns</code></li><li>表的转置：<code>frame.T</code>，Q:是否是视图？</li><li>获取ndarray数组：<code>frame.values</code><br><span style="color:green">当列的数据类型不一致时返回数组的数据类型将使用能兼容所有列的数据类型的类型</span></li></ul><h1 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h1><p>管理轴标签、轴名称等额外数据<br>字符串索引：<code>&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;</code><br>自然数索引：<code>&lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;</code></p><p>index可以整体替换掉，但不能单个修改(immutable) → 安全共享</p><p>。。。。。。</p><h1 id="操作Seies和DataFrame中的数据"><a href="#操作Seies和DataFrame中的数据" class="headerlink" title="操作Seies和DataFrame中的数据"></a>操作Seies和DataFrame中的数据</h1><h2 id="重新索引-obj-reindex-…"><a href="#重新索引-obj-reindex-…" class="headerlink" title="重新索引 obj.reindex(…)"></a>重新索引 obj.reindex(…)</h2><ol><li><p>如果新索引中包含原索引中没有的值将产生缺失值，可以使用关键字<code>fill_value</code>指定缺失默认值</p></li><li><p><strong>时间序列</strong>的<strong>前向插值</strong>：时间轴上缺失的索引对应的值与比它<strong>大</strong>的<strong>原来存在</strong>的索引对应的值的相同（前向插值）</p><ul><li>使用前向差值：<code>obj.reindex(NEW_INDEX, method=&#39;ffill&#39;)</code></li><li>使用后向差值：<code>obj.reindex(NEW_INDEX, method=&#39;bfill&#39;)</code></li><li>实际上还有更精确的插值方式…</li></ul></li><li><p>DataFrame的重新索引</p><ul><li>行重新索引: <code>frame.reindex(NEW_INDEX)</code></li><li>列重新索引: <code>frame.reindex(columns=NEW_INDEX)</code></li><li>行列同时重新索引：<code>frame.reindex(NEW_ROW_INDEX, columns=NEW_COLUMN_INDEX)</code></li><li>插值：只能按行插，即按行索引插</li></ul></li></ol><h2 id="丢弃指定轴上的项-obj-drop-…"><a href="#丢弃指定轴上的项-obj-drop-…" class="headerlink" title="丢弃指定轴上的项 obj.drop(…)"></a>丢弃指定轴上的项 obj.drop(…)</h2><p><strong>将返回一个新对象！！</strong></p><p>原来的索引：[‘a’,’b’,’c’,’d’,’e’]<br>丢弃：<code>obj.drop(&#39;c&#39;)</code>，新索引：[‘a’,’b’,’d’,’e’]<br>丢弃：<code>obj.drop([&#39;c&#39;,&#39;d&#39;])</code>，新索引：[‘a’,’b’,’e’] </p><h2 id="索引、选取、过滤"><a href="#索引、选取、过滤" class="headerlink" title="索引、选取、过滤"></a>索引、选取、过滤</h2><ol><li>直接索引：<code>obj[&#39;c&#39;]</code></li><li><strong>切片包含末端！！！</strong></li><li>结合列的切片和布尔运算来选取行<ul><li><code>frame[frame[&#39;three&#39;] &gt; 3]</code>将以”three”列为依据选取”three”列中所有值大于3的行 → 所以实际选取的是特定的某些行</li><li><code>frame[frame &lt; 5 = 0]</code>给表中所有小于5的位置重新赋值为0</li><li><code>frame &lt; 5</code> 本身应该是布尔值（逻辑运算），所以会得到一个由布尔值组成的新DataFrame<br><span style="color:red">布尔运算的特性实际上应该继承自numpy</span></li></ul></li><li>索引关键字ix</li></ol><h2 id="算数运算和数据对齐"><a href="#算数运算和数据对齐" class="headerlink" title="算数运算和数据对齐"></a>算数运算和数据对齐</h2><p><strong>数据对齐</strong>：Series或者DataFrame对象间的加法会自动合并相同轴上的索引并自动填充NaN → 取并集</p><h3 id="DataFrame对象的算数运算（以加法为例）"><a href="#DataFrame对象的算数运算（以加法为例）" class="headerlink" title="DataFrame对象的算数运算（以加法为例）"></a>DataFrame对象的算数运算（以加法为例）</h3><pre><code>* `df = df1 + df2` 以df1为主表，将df2的行、列索引加到df1里面去：df1中存在的将执行加法，不存在的为NaN* `df = df1.add(df2, fill_value=0)` 可以这样理解：    * 先将df2的行列索引合并到df1中得到并集表df（暂时假设将所有值设为NaN）    * 再将主表df1中的存在的值填入df（去掉一部分NaN）    * 再将df中剩余的NaN位置改成`fill_value`（去掉所有NaN）    * 再将df2中所有元素加到df的相关位置（df2中所有索引必定已经存在于df中）    * （括号内的内容纯属方便理解，尚未验证，算不得数）* 其他运算类似：    * 减法 sub -    * 乘法 mul *    * 除法 div /</code></pre><h3 id="DataFrame和Series间的运算"><a href="#DataFrame和Series间的运算" class="headerlink" title="DataFrame和Series间的运算"></a>DataFrame和Series间的运算</h3><p>涉及广播机制（broadcasting），熟悉numpy的话应该也熟悉广播机制。。。</p><pre><code>* 最简单的广播：Series的索引与DataFrame的行/列索引相同* 上述索引不完全相同时，先对索引取并集，再进行广播</code></pre><h2 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h2><pre><code>* numpy中操纵数组元素的方法（如np.abs)也可以用来操纵pandas对象* 操纵pandas对象的行/列数组使用 `obj.apply(lambda x: x.min(), axis=1)`（一般用不上）* 使用元素级的python函数操纵pandas元素：例如`obj.applymap(lambda x: &quot;{:.2f}&quot;.format(x))`</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code>* Series按index排序：`obj.sort_index()`* Series按values排序：`obj.order()`,缺失值将按index排序后丢到末尾* DataFrame按指定轴的index排序：`df.sort_index(axis=0)`,默认为0* DataFrame按某列值排序：例如 `df.sort_index(by=&apos;a&apos;)`* DataFrame按多列值排序：例如 `df.sort_index(by=[&apos;a&apos;,&apos;b&apos;])`* 默认升序，降序设置 `ascending=False`</code></pre><h2 id="排名-ranking"><a href="#排名-ranking" class="headerlink" title="排名(ranking)"></a>排名(ranking)</h2><p><span style="color:red">根据某种规则破坏评级关系</span>。原著是这么说的，不过很费解不是吗</p><p>以 <code>obj = Series([7, -5, 7, 4, 2, 0, 4])</code> 为例，<code>obj.rank()</code> 返回的实际上是 <code>Series([6.5, 1.0, 6.5, 4.5, 3.0, 2.0, 4.5])</code>。<br>首先我们可以获取一个类似于argsort的序列[6, 1，7, 4, 3, 2, 5]，然后考虑相同的值：两个‘7’的位置分别为7和6，因此都改为均值(7+6)/2=6.5，两个‘4’的位置分别为7和6，因此都改为均值(5+4)/2=4.5，因此算出结果。（至于有什么用，现在我还不知道。。。）</p><p>关键词 <code>method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}</code> 指定排名方法：</p><ul><li>average：默认值，如上取相同值索引的平均值以保证每个相同的元素具有相同的排名<br>  <code>return Series([6.5, 1.0, 6.5, 4.5, 3.0, 2.0, 4.5])</code></li><li>first：与argsort功能相同，按值出现顺序排名，结果应该是连续的正整数<br>  <code>return Series([6.0, 1.0, 7.0, 4.0, 3.0, 2.0, 5.0])</code></li><li>min：相同值的排名全部取最小的那个<br>  <code>return Series([6.5, 1.0, 6.0, 4.0, 3.0, 2.0, 4.0])</code></li><li>max：相同值的排名全部取最大的那个<br>  <code>return Series([7.0, 1.0, 7.0, 5.0, 3.0, 2.0, 5.0])</code></li><li>dense：min和max会跳值，dense不会<br>  <code>return Series([5.0, 1.0, 5.0, 4.0, 3.0, 2.0, 4.0])</code></li></ul><h2 id="带有重复值的轴索引"><a href="#带有重复值的轴索引" class="headerlink" title="带有重复值的轴索引"></a>带有重复值的轴索引</h2><p>一般情况下轴索引的值唯一（类似于“键”的概念），但这并不是硬性要求。也就是说，轴索引可以重复@_@。（一般应该也用不上吧？）</p><p>判断pandas对象的索引值是否唯一：<code>obj.index.is_unique: bool</code>。（pandas对象指的是Series对象或者DataFrame对象）</p><p>对不唯一的索引进行访问将返回所有符合值构成的pandas对象，访问唯一索引返回标量</p><h1 id="常用的数学和统计方法"><a href="#常用的数学和统计方法" class="headerlink" title="常用的数学和统计方法"></a>常用的数学和统计方法</h1><h2 id="约简方法"><a href="#约简方法" class="headerlink" title="约简方法"></a>约简方法</h2><ul><li>求和：默认按列求和，自动排除NaN值：<code>df.sum(axis=0, skipna=True)</code>。按行求和指定 <code>axis=1</code>;禁用自动跳过NaN指定 <code>skipna=False</code></li><li><code>count</code>,<code>min</code>,<code>max</code>,<code>argmin</code>,<code>argmax</code>,<code>idxmin</code>,<code>idxmax</code>,<code>sum</code>,<code>mean</code>,<code>media</code>,<code>mad</code>,<code>var</code>,<code>std</code>,…</li></ul><h2 id="累计方法"><a href="#累计方法" class="headerlink" title="累计方法"></a>累计方法</h2><ul><li>累计求和：<code>df.cumsum()</code></li></ul><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><ul><li><code>df.describe()</code>：一次性产生多个统计结果（统计量)</li></ul><h2 id="有趣的统计量"><a href="#有趣的统计量" class="headerlink" title="有趣的统计量"></a>有趣的统计量</h2><ul><li>corr、corrwith：相关系数</li><li>cov：协方差（矩阵）</li></ul><p>。。。。</p><p>改天再看，顺便练习盲打。。。</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回归模型结果度量指标</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180306-c444.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180306-c444.html</url>
      
        <content type="html"><![CDATA[<p>回归模型因为预测值连续，很难用‘准确度’这类指标去衡量。<a id="more"></a><br>回归模型评估方法主要有：</p><h1 id="MAE-Mean-Absolute-Error-平均绝对误差"><a href="#MAE-Mean-Absolute-Error-平均绝对误差" class="headerlink" title="MAE (Mean Absolute Error, 平均绝对误差)"></a>MAE (Mean Absolute Error, 平均绝对误差)</h1><p>sklearn API: <code>from sklearn.metrics import mean_absolute_error</code><br>formula:<br>$$MAE=\frac1n\sum_{i=1}^n{|f_i-y_i|}$$</p><p>这个很矬，一般不用！</p><hr><h1 id="MSE-Mean-Squre-Error-均方误差"><a href="#MSE-Mean-Squre-Error-均方误差" class="headerlink" title="MSE (Mean Squre Error, 均方误差)"></a>MSE (Mean Squre Error, 均方误差)</h1><p>sklearn API: <code>from sklearn.metrics import mean_squared_error</code><br>formula:<br>$$MSE=\frac1n\sum_{i=1}^n{(f_i-y_i)^2}$$</p><p>这个很流行！</p><hr><h1 id="RMSE-Rooted-Mean-Square-Error-均方根误差"><a href="#RMSE-Rooted-Mean-Square-Error-均方根误差" class="headerlink" title="RMSE (Rooted Mean Square Error, 均方根误差)"></a>RMSE (Rooted Mean Square Error, 均方根误差)</h1><p>formula:<br>$$RMSE=\sqrt{MSE}$$</p><p>与上面的MSE没有区别，一般使用MSE即可！<br><strong>注意</strong>：如果是在迭代过程中作为loss函数，需要合理选择MSE/RMSE</p><hr><h1 id="R2-R-Squared"><a href="#R2-R-Squared" class="headerlink" title="R2 (R-Squared)"></a>R<sup>2</sup> (R-Squared)</h1><p>sklearn API: <code>from sklearn.metrics import r2_score</code><br>formula:<br>$$y_m=\frac1n\sum_{i=1}^n{y_{t_i}}$$<br>$$R^2=1-\frac{\sum_{i=1}^n{(y_{p_i}-y_{t_i})^2}}{\sum_{i=1}^n{(y_{t_i}-y_m)^2}}$$<br>$y_p$ means prediction while $y_t$ means truth.</p><p>将预测值与只使用均值的情况进行比较</p><ul><li>当 $y_{p_i}=y_m$时，$R^2=0$ $\rightarrow$ 完全不沾边，还不如使用均值</li><li>当 $y_{p_i}=y_{t_i}$ 时，$R^2=1$ $\rightarrow$ 完全匹配（实际上应该是达不到的）</li><li>据说 $0{\le}R^2{\le}1$，尚未亲身验证</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聚类结果度量指标</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180302-90e6.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/20180302-90e6.html</url>
      
        <content type="html"><![CDATA[<p>一个好的聚类结果： </p><ul><li><strong>簇内相似度</strong>(intra-cluster similarity)高</li><li><strong>簇间相似度</strong>(inter-cluster similarity)低</li></ul><p>聚类性能度量指标总体分为两类：</p><ul><li><strong>外部指标</strong>(external index)：与已知的“参考模型”的结果进行比较</li><li><strong>内部指标</strong>(internal index)：在自己结果的内部进行比较<a id="more"></a><hr><h1 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h1></li></ul><p>首先，将样本两两配对，N个样本将组成$C_n^2=\frac{n(n-1)}{2}$对<br>然后，将上述<strong>对子</strong>分成四类：</p><ol><li>a = |SS|: 在本模型中属于同一簇，在参考模型中也属于同一簇</li><li>b = |SD|: 在本模型中属于同一簇，但在参考模型中属于不同的簇</li><li>c = |DS|: 在本模型中属于不同的簇，但在参考模型中属于同一簇</li><li>d = |DD|: 在本模型中属于不同的簇，在参考模型中也属于不同的簇</li></ol><p><strong>注意</strong>： 每一个对子只可能属于上述四类中的一个</p><p>由上面四个集合导出下面常用的外部指标：</p><h2 id="杰卡德系数-Jaccard-Coefficient-JC"><a href="#杰卡德系数-Jaccard-Coefficient-JC" class="headerlink" title="杰卡德系数(Jaccard Coefficient, JC)"></a>杰卡德系数(Jaccard Coefficient, JC)</h2><p><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/88239646.jpg" alt=""></p><p>JC本来是用来度量两个集合的差异程度：$JC = \frac{交集}{ 并集}$。在这里实际上指的是如下集合：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/89315682.jpg" alt=""></p><h2 id="FM指数-FMI"><a href="#FM指数-FMI" class="headerlink" title="FM指数, FMI"></a>FM指数, FMI</h2><p><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/74771099.jpg" alt=""></p><p>FMI本来的定义是：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/69667805.jpg" alt=""></p><h2 id="Rand指数-RI"><a href="#Rand指数-RI" class="headerlink" title="Rand指数, RI"></a>Rand指数, RI</h2><p>观察到的阳性数据的比例<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/13123557.jpg" alt=""></p><p>上述四个指标取值 [0, 1]，值越大性能越好</p><p><hr></p><h1 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h1><p>首先，定义一个样本间的距离 <strong>dist(a, b)</strong></p><blockquote><p>距离的定义必须满足经典的四个性质：</p><ol><li>dist(a, b) ≥ 0 恒成立</li><li>当且仅当 a = b 时 dist(a, b) = 0</li><li>对称： dist(a, b) = dist(b, a)</li><li>三角不等式： dist(a, b) ≤ dist(a, c) + dist(c, b)</li></ol></blockquote><p>然后定义一下量：</p><ol><li><strong>avg(C)</strong>: 簇内两点间的平均距离</li><li><strong>diam(C)</strong>: 簇内样本间的最大距离</li><li><strong>d<sub>min</sub>(C<sub>i</sub>, C<sub>j</sub>)</strong>: 两个簇最近样本间的距离</li><li><strong>d<sub>cen</sub>(C<sub>i</sub>, C<sub>j</sub>)</strong>: 两个簇中心点间的距离</li></ol><p style="color:red;font-family:楷体">中心点各分量值就是簇内所有样本各分量值的平均值</p><p>基于上述定义导出常用的内部指标：</p><h2 id="DB指数，DBI"><a href="#DB指数，DBI" class="headerlink" title="DB指数，DBI"></a>DB指数，DBI</h2><p><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/11177646.jpg" alt=""></p><h2 id="Dunn指数，DI"><a href="#Dunn指数，DI" class="headerlink" title="Dunn指数，DI"></a>Dunn指数，DI</h2><p><img src="http://p33k8pinb.bkt.clouddn.com/18-3-2/8104484.jpg" alt=""></p><p><hr></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本节主要参考周志华西瓜书 P<sub>197</sub></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习与算法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-基于TFRecord加载图像数据</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180301-e69e.html"/>
      <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180301-e69e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是TFRecord文件？"><a href="#什么是TFRecord文件？" class="headerlink" title="什么是TFRecord文件？"></a>什么是TFRecord文件？</h1><p>将<strong>一组</strong>图像数据和它们对应的标签存在一个二进制文件里，这个文件就是TFRecord文件。<a id="more"></a></p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>自定义的牙骨项目<a href="https://github.com/barwe/practise/blob/master/TFRecordFileBuilder.py" target="_blank" rel="noopener">数据加载器</a></p><p>核心步骤：</p><ol><li><p>声明一个用于生成TFRecord文件的writer<br><code>with tf.python_io,TFRecordWriter(tfr_fp) as writer: …<br># tfr_fp是生成文件路径</code></p></li><li><p>获取图像的二进制数据：例如 <code>PIL::Image</code> 对象 <code>img</code> 可以使用 <code>img.tobytes()</code> 获取二进制信息</p></li><li>然后套用tensorflow提供的API：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-3-1/42164280.jpg" alt=""></li></ol><p>红色下划线为关键API<br>A：标识图像标签的key，加载TFRecord文件的时候会用到<br>B：注意类型对应：图像标签为int类型，图像内容为bytes类型<br>形参 <code>value</code> 的值注意加 <code>[]</code></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="1-老规矩，先定义队列"><a href="#1-老规矩，先定义队列" class="headerlink" title="1.老规矩，先定义队列"></a>1.老规矩，先定义队列</h2><pre><code>q = tf.train.string_input_producer([tfr_fp])这里传入的是 `[tfr_fp]` ，代表建立的实际上是一个文件名队列</code></pre><h2 id="2-定义读取TFRecord文件的阅读器"><a href="#2-定义读取TFRecord文件的阅读器" class="headerlink" title="2.定义读取TFRecord文件的阅读器"></a>2.定义读取TFRecord文件的<strong>阅读器</strong></h2><pre><code>reader = tf.TFRecordReader()</code></pre><h2 id="3-用这个reader读取TFRecord文件的文件名队列得到序列化的样例："><a href="#3-用这个reader读取TFRecord文件的文件名队列得到序列化的样例：" class="headerlink" title="3.用这个reader读取TFRecord文件的文件名队列得到序列化的样例："></a>3.用这个reader读取TFRecord文件的文件名队列得到序列化的样例：</h2><pre><code>_, serialized_example = reader.read(q)</code></pre><h2 id="4-从样例中解析出图像数据和图像标签"><a href="#4-从样例中解析出图像数据和图像标签" class="headerlink" title="4.从样例中解析出图像数据和图像标签"></a>4.从样例中解析出图像数据和图像标签</h2><pre><code>features = tf.parse_single_example(    serialized_example,    features = {        &apos;label&apos;: tf.FixedLenFeature([], tf.int64),        &apos;img_raw&apos;: tf.FixedLenFeature([], tf.string)    })</code></pre><h2 id="5-从二进制数据中解码图像"><a href="#5-从二进制数据中解码图像" class="headerlink" title="5.从二进制数据中解码图像"></a>5.从二进制数据中解码图像</h2><pre><code>img = tf.decode_raw(features[&apos;img_raw&apos;], tf.uint8)img = tf.reshape(img, SHAPE)</code></pre><h2 id="6-千万别忘了在session中开启线程，被坑傻了"><a href="#6-千万别忘了在session中开启线程，被坑傻了" class="headerlink" title="6.千万别忘了在session中开启线程，被坑傻了"></a>6.千万别忘了在session中开启线程，被坑傻了</h2><p><a href="http://barwe.top/deep-learning/2018-01-26/20180126111829/#start_queue" target="_blank" rel="noopener">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>假设检验原理2-卡方检验</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180228-5746.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80/20180228-5746.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-chi-2-分布？"><a href="#什么是-chi-2-分布？" class="headerlink" title="什么是$\chi^2$分布？"></a>什么是$\chi^2$分布？</h1><p>若k个独立随机变量 $Z_1,Z_2,…,Z_k$ 服从标准正态分布N(0,1)，则这k个随机变量的平方和$X=\sum{Z_i^2}$ 服从自由度为k的卡方分布。<br>记作 $X\sim\chi^2(k)$。卡方分布的期望为n，方差为2n。<br><a id="more"></a></p><h1 id="chi-2-适合性检验"><a href="#chi-2-适合性检验" class="headerlink" title="$\chi^2$适合性检验"></a>$\chi^2$适合性检验</h1><p><strong>适用范围</strong>：比较观测数与理论数是否符合</p><p><strong>检验假设</strong>：$H_0$: O - E = 0 (观测数与理论数间没有差异)</p><h1 id="chi-2-独立性检验"><a href="#chi-2-独立性检验" class="headerlink" title="$\chi^2$独立性检验"></a>$\chi^2$独立性检验</h1><p><strong>适用范围</strong>：常用来判定<strong>两个变量</strong>之间是独立的还是相互影响的</p><h2 id="列联表的独立性检验"><a href="#列联表的独立性检验" class="headerlink" title="列联表的独立性检验"></a>列联表的独立性检验</h2><h3 id="2x2列联表"><a href="#2x2列联表" class="headerlink" title="2x2列联表"></a>2x2列联表</h3><p><strong>检验假设</strong>：<br>$H_0$: 事件A和时间B无关<br>$H_1$: 事件A和时间B有关</p><p>连续性矫正</p><h3 id="r-times-c-列联表"><a href="#r-times-c-列联表" class="headerlink" title="$r{\times}c$ 列联表"></a>$r{\times}c$ 列联表</h3><p>这是一个 $2{\times}3$ 列联表：<br><img src="http://p33k8pinb.bkt.clouddn.com/18-2-28/29521663.jpg" alt=""><br>上表中一共有两个变量：</p><ul><li>性别：有2个取值（男、女）</li><li>肥胖程度：有3个取值（不肥胖、轻度肥胖、中/重度肥胖）</li></ul><p>$\chi^2$检验验证的是两个变量是否独立，即”性别和肥胖程度无关”</p>]]></content>
      
      
      <categories>
          
          <category> 统计学基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python自用进度条</title>
      <link href="/python%E7%BC%96%E7%A8%8B/20180201-ffef.html"/>
      <url>/python%E7%BC%96%E7%A8%8B/20180201-ffef.html</url>
      
        <content type="html"><![CDATA[<p>自定义一个简单的进度条，并没有考虑性能怎么样。。。<a id="more"></a></p><pre><code>import sysdef process_bar(i, n, pref_str=&apos;&apos;, suff_str=&apos;&apos;, char=&apos;=&apos;, num_chars=100):    &apos;&apos;&apos;    :param i: 计数器,从1开始    :param n: 计数器最大值    :param char: 进度条符号    :param pref_str: 进度条前置字符串    :param suff_str: 进度条后置字符串    &apos;&apos;&apos;    num = i * num_chars // n    pre = char * num    pro = &apos;&gt;&apos; + &apos; &apos; * (num_chars - 1 - num) if num - num_chars else &apos;&apos;    numerator = &apos; &apos; * (len(str(n)) - len(str(i))) + str(i)    if num - num_chars:        sys.stdout.write(&quot;%s|%s/%d|%s%s|%s%%|%s\r&quot; % (        pref_str, numerator, n, pre, pro, &apos; &apos; + str(num * 100 // num_chars), suff_str))    else:        sys.stdout.write(&quot;%s|%s/%d|%s%s|%s%%|%s\n&quot; % (pref_str, numerator, n, pre, pro, 100, suff_str))</code></pre><p><img src="http://p33k8pinb.bkt.clouddn.com/18-1-26/54604707.jpg" style="width:30px;margin:0;display:inline-block"><br><span style="display:inline-block;position:relative;top:-55px;left:40px"> <code>i</code> 取值从 <code>0</code> 到 <code>n-1</code> ，符合 <code>range</code> 函数习惯<br><span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青铜派森 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-基于队列和多线程加载数据</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180126-f29a.html"/>
      <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180126-f29a.html</url>
      
        <content type="html"><![CDATA[<h1 id="建立如下的文件-fileslist-csv"><a href="#建立如下的文件-fileslist-csv" class="headerlink" title="建立如下的文件 fileslist.csv"></a>建立如下的文件 <code>fileslist.csv</code></h1><p><img src="http://p33k8pinb.bkt.clouddn.com/18-1-26/36410313.jpg" alt=""><br><br><strong>注</strong>：建议采用<a href="https://baike.baidu.com/item/CSV/10739" target="_blank" rel="noopener">csv格式</a>，第一列是图像路径，第二列是标签（建议标签预处理成数字），分隔符为 <code>,</code> <a id="more"></a></p><hr><h1 id="将-fileslist-csv-按行加载到python内置列表，假设为-imgNames"><a href="#将-fileslist-csv-按行加载到python内置列表，假设为-imgNames" class="headerlink" title="将 fileslist.csv 按行加载到python内置列表，假设为 imgNames"></a>将 <code>fileslist.csv</code> 按行加载到python内置列表，假设为 <code>imgNames</code></h1><pre><code># pythonwith open(&apos;fileslist.csv&apos;,&apos;r&apos;) as fin:    imgNames = fin.read().strip().split(&apos;\n&apos;)</code></pre><hr><h1 id="建立文件名队列"><a href="#建立文件名队列" class="headerlink" title="建立文件名队列"></a>建立文件名队列</h1><h2 id="建队"><a href="#建队" class="headerlink" title="建队"></a>建队</h2><pre><code>#pythonfn_queue = tf.train.string_input_producer(imgNames)#Other opt-parameters#    num_epochs: 读取文件一次为一个epoch，默认无限次读取#    shuffle: 读取文件时是否乱序#    seed: 当shuffle为True时设置随机数种子(可选)#    capacity: 队列容量，默认为32(很显然需要大于batch-size)#    share_name, name, cancel_op</code></pre><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><pre><code>#pythonitem = fn_queue.dequeue()</code></pre><p><strong>注</strong>：    <br></p><ol><li>出队的只是一个符号(参考tensorflow计算图的概念)，真正的值要在Session中获取<br></li><li>此时 <code>item</code> 相当于 <code>fileslist.csv</code> 中的一行（一个记录），每个记录具有相同的形式！<br></li><li>显然 <code>item</code> 不是标准形式，还需要在后面进行进一步加工</li></ol><hr><h1 id="单个记录-item-数据标准化：根据图像-路径字符串-解析出-数组"><a href="#单个记录-item-数据标准化：根据图像-路径字符串-解析出-数组" class="headerlink" title="单个记录(item)数据标准化：根据图像 路径字符串 解析出 数组"></a>单个记录(<code>item</code>)数据标准化：根据图像 <em>路径字符串</em> 解析出 <em>数组</em></h1><h2 id="对记录-item-解码得到路径-img-path-和标签-img-label"><a href="#对记录-item-解码得到路径-img-path-和标签-img-label" class="headerlink" title="对记录 item 解码得到路径 img_path 和标签 img_label"></a>对记录 <code>item</code> 解码得到路径 <code>img_path</code> 和标签 <code>img_label</code></h2><pre><code>#pythonimg_path, img_label = tf.decode_csv(item, [[&apos;&apos;],[1]], field_delim=&apos;,&apos;)</code></pre><p><em>参数解释</em></p><ul><li><code>records</code> : 必须参数，字符串类型的张量，这里就是 <code>fn_queue</code> 出队的结果 <code>item</code></li><li><code>record_defaults</code> : 必须参数，指定返回值的类型(这里返回值类型的定义很有意思~~)<br>这里直观返回值类型为 <code>str, int</code> , 因此形参赋值 <code>[[&#39;&#39;], [1]]</code> (惊奇)<br>第一个 <code>[]</code> 内可以是任意 <code>str</code> 对象，第二个 <code>[]</code> 内可以是任意 <code>int</code> 对象</li><li><code>field_delim</code> : 建议显示声明，csv文件列间分隔符，默认为 <code>,</code></li><li><code>use_quote_delim</code> : unknown, unimportant</li><li><code>name</code></li><li><code>na_value</code> : NA/NaN格式选择，没啥用</li></ul><h2 id="解析-img-path-的内容"><a href="#解析-img-path-的内容" class="headerlink" title="解析 img_path 的内容"></a>解析 <code>img_path</code> 的内容</h2><pre><code>img_str = tf.read_file(img_path)</code></pre><p><img src="http://p33k8pinb.bkt.clouddn.com/18-1-26/54604707.jpg" style="width:30px;margin:0;display:inline-block"><br><span style="display:inline-block;position:relative;top:-55px;left:40px"><code>img_dtr</code> 实际上还是一个字符串，与包含<strong>文件名内容</strong>的 <code>img_path</code> 不同,<br><code>img_str</code> 包含的是<strong>文件内容</strong><span></span></span></p><h2 id="对图像内容字符串-img-str-进行解析，获取图像的数字信息"><a href="#对图像内容字符串-img-str-进行解析，获取图像的数字信息" class="headerlink" title="对图像内容字符串 img_str 进行解析，获取图像的数字信息"></a>对图像内容字符串 <code>img_str</code> 进行解析，获取图像的<strong>数字</strong>信息</h2><pre><code>img_data = tf.image.decode_jpeg(img_str, channels=3)</code></pre><p><em>参数解释</em></p><ul><li><code>content</code> : 必须，字符串张量，此处为 <code>img_str</code></li><li><code>channels=0</code> ： <span style="color:red">必须指定</span>，常见图像通道数可能取值有 1, 3, 4</li><li><code>ratio=1</code></li><li><code>fancy_upscaling=True</code></li><li><code>try_recover_truncated=False</code></li><li><code>acceptable_fraction=1</code></li><li><code>dct_method=&#39;&#39;</code></li><li><code>name=None</code></li></ul><h2 id="由flatten化的数字信息确定图像矩阵尺寸（说白了就是reshape）"><a href="#由flatten化的数字信息确定图像矩阵尺寸（说白了就是reshape）" class="headerlink" title="由flatten化的数字信息确定图像矩阵尺寸（说白了就是reshape）"></a>由flatten化的数字信息确定图像矩阵尺寸（说白了就是reshape）</h2><pre><code>img_array = tf.image.resize_images(img_data, [HEIGHT， WIDTH])</code></pre><p><em>可选参数</em></p><ul><li><code>method=ResizeMethod.BILINEAR</code> : 变形方法</li><li><code>align_corners=False</code></li></ul><p><img src="http://p33k8pinb.bkt.clouddn.com/18-1-26/54604707.jpg" style="width:30px;margin:0;display:inline-block"><br><span style="display:inline-block;position:relative;top:-55px;left:40px">此处图片的尺寸应写为[高，宽], 即<strong>行</strong>作为数组的第一维度<br><span></span></span></p><hr><h1 id="获取批次数据（batch-subset）"><a href="#获取批次数据（batch-subset）" class="headerlink" title="获取批次数据（batch subset）"></a>获取批次数据（batch subset）</h1><pre><code>images, labels = tf.train.shuffle_batch([img_array, img_label],                                         batch_size=8,                                         capacity=100,                                         min_after_dequeue=20)</code></pre><p><em>完整参数解释</em></p><ul><li><code>tensors</code> : 必须，待打包的记录列表，此处为 <code>[img_array, img_label]</code><br>因为 <code>img_array</code> 和 <code>img_label</code> 在这里都只是个符号，也就不难理解上述赋值了~</li><li><code>batch_size</code> : 必须，与训练过程的 <code>batch_size</code> 相同<br>因此在使用队列训练模型时，<code>batch_size</code>需要作为超参进行预赋值</li><li><code>capacity</code> : 建议，队列容量<br>注意这里的队列与前面的<strong>文件名队列</strong>不同</li><li><code>min_after_dequeue</code> : 建议，每次出队后队列中剩余的记录<br>此参数可用来衡量shuffle水平，剩余记录数量越大，shuffle程度越高</li><li><code>num_threads=1</code> ： 可选，入队线程数，通常情况下1个就够用了</li><li><code>seed=None</code> : 可选，设置shuffle随机种子</li><li><code>enqueue_many=False</code> : 可选，一个记录一个记录的入队还是多个一起入队</li><li><code>shapes=None</code></li><li><code>allow_smaller_final_batch=False</code> : 当每个epoch最后一个batch数目不足时是否允许灵活调整batch大小</li><li><code>share_name=None</code> : 多个Session共用数据加载队列时使用，一般用不上</li><li><code>name=None</code></li></ul><hr><p><br><br>然而，以上都是在定义队列加载的<strong>图</strong> 。。。</p><h1 id="Session里面如何使用开启队列？"><a href="#Session里面如何使用开启队列？" class="headerlink" title="Session里面如何使用开启队列？"></a><span id="start_queue">Session里面如何使用开启队列？</span></h1><pre><code>with tf.Session(...) as sess:    coord = tf.train.Coordinator()    threads = tf.train.start_queue_runners(sess=sess, coord=coord)    sess.run(tf.global_variables_initializer())    X, y = sess.run([images, labels])    利用feed_dict传入X,y进行训练...    coord.request_stop()    coord.join(threads=threads)</code></pre><hr><p style="font-size:16px;margin:0">Author: Barwe(YinChen)<br>Email: <a href="mailto:995488247@qq.com" target="_blank" rel="noopener">995488247@qq.com</a><br>本文地址: <a href="http://barwe.top/deep-learning/2018-01-26/20180126111829/" target="_blank" rel="noopener">http://barwe.top/deep-learning/2018-01-26/20180126111829/</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10系统将C盘的用户文件夹迁移至D盘</title>
      <link href="/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180125-f59f.html"/>
      <url>/OS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/20180125-f59f.html</url>
      
        <content type="html"><![CDATA[<p>C盘终极清理！<a id="more"></a></p><h1 id="一、win10默认禁用管理员账户："><a href="#一、win10默认禁用管理员账户：" class="headerlink" title="一、win10默认禁用管理员账户："></a>一、win10默认禁用管理员账户：</h1><h2 id="1、打开“计算机管理”："><a href="#1、打开“计算机管理”：" class="headerlink" title="1、打开“计算机管理”："></a>1、打开“计算机管理”：</h2><p>① 右键“我的电脑”- 管理</p><p>② cmd - 键入“计算机管理”- 打开</p><h2 id="2、激活管理员账户："><a href="#2、激活管理员账户：" class="headerlink" title="2、激活管理员账户："></a>2、激活管理员账户：</h2><p>@ 右键<strong>“计算机管理（本地）&gt;系统工具&gt;本地用户和组&gt;用户&gt;Administrator”</strong>选择<strong>属性</strong></p><p>@ 去掉“账户已禁用”的对勾</p><h1 id="二、切换至管理员"><a href="#二、切换至管理员" class="headerlink" title="二、切换至管理员"></a>二、切换至管理员</h1><h2 id="1、注销当前用户，切换至Administrator用户"><a href="#1、注销当前用户，切换至Administrator用户" class="headerlink" title="1、注销当前用户，切换至Administrator用户"></a>1、注销当前用户，切换至Administrator用户</h2><h2 id="2、打开cmd，执行-robocopy-quot-C-Users-USERNAME-quot-quot-D-Users-USERNAME-quot-E-COPYALL-XJ"><a href="#2、打开cmd，执行-robocopy-quot-C-Users-USERNAME-quot-quot-D-Users-USERNAME-quot-E-COPYALL-XJ" class="headerlink" title="2、打开cmd，执行 robocopy &quot;C:\Users\USERNAME&quot; &quot;D:\Users\USERNAME&quot; /E /COPYALL /XJ"></a>2、打开cmd，执行 <code>robocopy &quot;C:\Users\USERNAME&quot; &quot;D:\Users\USERNAME&quot; /E /COPYALL /XJ</code></h2><h2 id="3、可能需要安装文件解锁工具-LockHunter：程序接口位于右键菜单中！"><a href="#3、可能需要安装文件解锁工具-LockHunter：程序接口位于右键菜单中！" class="headerlink" title="3、可能需要安装文件解锁工具 LockHunter：程序接口位于右键菜单中！"></a>3、可能需要安装文件解锁工具 <em>LockHunter</em>：程序接口位于右键菜单中！</h2><h2 id="4、解锁-“C-Users-USERNAME”：右键菜单选择API进入解锁界面"><a href="#4、解锁-“C-Users-USERNAME”：右键菜单选择API进入解锁界面" class="headerlink" title="4、解锁 “C:\Users\USERNAME”：右键菜单选择API进入解锁界面"></a>4、解锁 “C:\Users\USERNAME”：右键菜单选择API进入解锁界面</h2><h2 id="5、删除”C-Users-USERNAME”：cmd中执行-rmdir-quot-C-Users-USERNAME-quot-S-Q"><a href="#5、删除”C-Users-USERNAME”：cmd中执行-rmdir-quot-C-Users-USERNAME-quot-S-Q" class="headerlink" title="5、删除”C:\Users\USERNAME”：cmd中执行 rmdir &quot;C:\Users\USERNAME&quot; /S /Q"></a>5、删除”C:\Users\USERNAME”：cmd中执行 <code>rmdir &quot;C:\Users\USERNAME&quot; /S /Q</code></h2><h2 id="6、建立软连接：cmd中执行-mklink-J-quot-C-Users-USERNAME-quot-quot-D-Users-USERNAME-quot"><a href="#6、建立软连接：cmd中执行-mklink-J-quot-C-Users-USERNAME-quot-quot-D-Users-USERNAME-quot" class="headerlink" title="6、建立软连接：cmd中执行 mklink /J &quot;C:\Users\USERNAME&quot; &quot;D:\Users\USERNAME&quot;"></a>6、建立软连接：cmd中执行 <code>mklink /J &quot;C:\Users\USERNAME&quot; &quot;D:\Users\USERNAME&quot;</code></h2>]]></content>
      
      
      <categories>
          
          <category> OS学习手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-计算资源控制</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180125-ff54.html"/>
      <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180125-ff54.html</url>
      
        <content type="html"><![CDATA[<p>控制GPU和CPU的使用。<a id="more"></a></p><h2 id="tf-ConfigProto-的参数"><a href="#tf-ConfigProto-的参数" class="headerlink" title="tf.ConfigProto()的参数"></a>tf.ConfigProto()的参数</h2><h4 id="使用CPU计算时指定核数"><a href="#使用CPU计算时指定核数" class="headerlink" title="使用CPU计算时指定核数"></a>使用CPU计算时指定核数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_count = &#123;<span class="string">'CPU'</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="使用GPU进行计算"><a href="#使用GPU进行计算" class="headerlink" title="使用GPU进行计算:"></a>使用GPU进行计算:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpu_options = tf.GPUOptions(</span><br><span class="line">    per_process_gpu_memory_fraction = <span class="number">0.25</span>,</span><br><span class="line">    allow_growth = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ul><li>per_process_gpu_memory_fraction 指定每个显存占用比例 <br></li><li>allow_growth 允许显存占用自适应增长</li></ul><h4 id="并行计算相关设置"><a href="#并行计算相关设置" class="headerlink" title="并行计算相关设置"></a>并行计算相关设置</h4><p>独立op间并行计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inter_op_parallelism_threads = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>op内部（如矩阵乘法）并行计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intra_op_parallelism_threads = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>是否打印设备分配日志<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_device_placement = <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>如果你指定的设备不存在，允许TF自动分配设备<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow_soft_placement = <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="构建config"><a href="#构建config" class="headerlink" title="构建config"></a>构建config</h2><p>选择必要参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config = tf.ConfigProto(</span><br><span class="line">   device_count = ... 使用CPU核心，可选</span><br><span class="line">   gpu_options = ... GPU显存控制，可选</span><br></pre></td></tr></table></figure></p><h2 id="将config传递给Session"><a href="#将config传递给Session" class="headerlink" title="将config传递给Session"></a>将config传递给Session</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = tf.Session(config=config)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
